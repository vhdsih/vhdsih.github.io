<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vhdsih</title>
  
  <subtitle>happy</subtitle>
  <link href="https://vhdsih.github.io/atom.xml" rel="self"/>
  
  <link href="https://vhdsih.github.io/"/>
  <updated>2023-10-25T15:23:10.227Z</updated>
  <id>https://vhdsih.github.io/</id>
  
  <author>
    <name>vhdsih</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>胡说八道</title>
    <link href="https://vhdsih.github.io/2099/12/24/mylogs/"/>
    <id>https://vhdsih.github.io/2099/12/24/mylogs/</id>
    <published>2099-12-23T16:00:00.000Z</published>
    <updated>2023-10-25T15:23:10.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2023-10-24"><a href="#2023-10-24" class="headerlink" title="2023-10-24"></a>2023-10-24</h2><p>今日有一大笔的支出，买了一把电吉他。时间好少，要学口琴、民谣吉他和电吉他，已经学不过来了哈哈哈。</p><p>时间除了浪费在发呆、刷手机，是一点也没有花费在学习技术上，都荒废掉了；工作嘛，就是那样吧，既没啥可做的，也不涨钱。</p><p>另，我好穷，而且看起来还会一直穷下去，哈哈😄。</p><h2 id="2023-10-17"><a href="#2023-10-17" class="headerlink" title="2023-10-17"></a>2023-10-17</h2><p>写博客是一件困难的事。想学的太多，落实的太少，大多都是无疾而终了。</p><p>加州旅馆我已经循环了好久，突然有了想要学会的冲动。想做的事情无需等待，等待只会消减来之不易的热情。吉他已经下单一段时间，最近仍然保持着练习的欲望。清晰地认知到自己天赋普通已经很多年了，不过应该努力的程度从未达到天赋的壁垒吧！</p><p>口琴虽然没有完全搁置，但是最近吹的次数少了很多，今年把告白之夜学熟练就好了。</p><p>我内心里是遵守规则的人，但是最近两次不知不觉闯了红灯，自责。</p><p>经常性地被拒绝真是一件很难让人开心的事情。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2023-10-24&quot;&gt;&lt;a href=&quot;#2023-10-24&quot; class=&quot;headerlink&quot; title=&quot;2023-10-24&quot;&gt;&lt;/a&gt;2023-10-24&lt;/h2&gt;&lt;p&gt;今日有一大笔的支出，买了一把电吉他。时间好少，要学口琴、民谣吉他和电吉他，已</summary>
      
    
    
    
    <category term="日常" scheme="https://vhdsih.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="胡说八道" scheme="https://vhdsih.github.io/tags/%E8%83%A1%E8%AF%B4%E5%85%AB%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>Learning Rust</title>
    <link href="https://vhdsih.github.io/2021/06/16/learning-rust/"/>
    <id>https://vhdsih.github.io/2021/06/16/learning-rust/</id>
    <published>2021-06-15T16:39:24.000Z</published>
    <updated>2023-10-25T14:45:53.687Z</updated>
    
    <content type="html"><![CDATA[<p>阅读  <a href="https://doc.rust-lang.org/book/">rust online book</a> 时记录的笔记，辅以备忘。</p><span id="more"></span><p>Rust具有安全高效等语言特性，提供了3个工具：</p><ul><li>cargo: 依赖管理和构建工具</li><li>rustfmt: 代码风格</li><li>Rust Language Server</li></ul><h1 id="一、开始学习rust"><a href="#一、开始学习rust" class="headerlink" title="一、开始学习rust"></a>一、开始学习rust</h1><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello, world"></a>hello, world</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个起点程序，和C语言类似，main 函数是 rust 程序的入口，函数体使用 ‘{}’ 包围，将左大括号和函数声明放在一行是 rust 推荐的编程习惯,此外，rust 语言风格使用 4 个空格来缩进，而非 TAB，且使用分号作为每个语句表达的结束。可以使用 rustfmt 工具格式化代码为官方推荐的格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> rustfmt main.rs</span></span><br></pre></td></tr></table></figure><p>和c语言有所区别的是，用于输出的语句 “println!” 非函数，而是 Rust macro，它和函数的直观上的区别在于是否有 “!”，若 “func_name” 则为一个普通的函数</p><p>对于简单的 rust 程序，可以使用 rustc 进行编译，并得到可运行的二进制文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> rustc main.rs</span></span><br></pre></td></tr></table></figure><p>然而对于复杂的工程，使用 cargo 来管理项目则是更好的选择。</p><h2 id="使用-Cargo"><a href="#使用-Cargo" class="headerlink" title="使用 Cargo"></a>使用 Cargo</h2><p>Cargo 是 Rust 语言系统中的依赖管理和构建工具。利用cargo创建新的项目，并创建所需的文件项，同时在非 git 仓库中将同时初始化 git 并添加 gitignore 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cargo new hello_cargo</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> tree hello_cargo</span></span><br><span class="line">  |- Cargo.toml</span><br><span class="line">  |- src</span><br><span class="line">    |- main.rs</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 Cargo.toml 文件中记录了项目相关信息和依赖项目，文件为TOML (Tom’s Obvious, Minimal Language) 格式。Cargo 设计希望将源码放到 src目录中，顶层目录放置 README、LICENSE 等。</p><p>构建和运行使用 Cargo 创建的项目很简单，在第一次构建完成后，在顶层目录将创建一个 Cargo.lock 文件用以记录依赖，无需手工管理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> hello_cargo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> write binary file into target/</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cargo build</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exec</span> the program</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cargo run</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> or <span class="built_in">exec</span> the binary file direcly</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ./target/debug/hello_cargo</span></span><br></pre></td></tr></table></figure><p>此外 Cargo 提供了快速检测代码但不生成二进制文件的命令，其速度快于 build，所以经常 check 一下刚刚写的代码是个很好的习惯。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cargo check</span></span><br></pre></td></tr></table></figure><p>当程序发版使用时，使用带有 –release 参数的 build 命令生成 release 版本，编译器优化将使程序具备更高效的运行效率，但是编译时间会更长。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cargo build --release</span></span><br></pre></td></tr></table></figure><h1 id="二、猜数程序实践"><a href="#二、猜数程序实践" class="headerlink" title="二、猜数程序实践"></a>二、猜数程序实践</h1><p>实践永远是学习新东西最快的方法。下面使用熟知的猜数游戏学习一些新的语言规则。</p><p>首先，使用在上一章 hello world 程序的基础上，引入了一些新的知识点：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> guess = <span class="built_in">String</span>::new();</span><br><span class="line">    io::stdin()</span><br><span class="line">        .read_line(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">        .expect(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Your guessd is: &#123;&#125;&quot;</span>, guess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下 rust 只引入了少量的类型，为了获取用户的输入输出，需要使用 use 引入 std::io 到作用域中，std 表示 io 是标准库的一部分。</p><p>rust 使用 let 关键字创建变量和常量，默认情况下，rust 提供的变量是不可变的，若需要可变的变量需要显式使用 mut 关键字指出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = bar;     <span class="comment">// immutable</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> foo = bar; <span class="comment">// mutable</span></span><br></pre></td></tr></table></figure><p>let mut guess = String::new() 语句中，guess 变量绑定到 String::new() 的返回结果，String 是标准库提供的可变的、utf-8 格式的字符串类型，”::” 表示 new 是 String 的一个关联函数，其无需实例化即可调用，类似其他语言的静态函数。new() 方法将创建一个新的 String 空实例。</p><p>为了和用户交互，使用了 std::io，io::stdin() 将返回 std::io::Stdin，即标准 I/O 的一个句柄，read_line 函数将从终端获取用户输入，并<strong>追加</strong>到 guess 字符串变量后，因此，guess 必须是一个可变对象。”&amp;” 表示使用了对象的引用，使用引用以避免对变量的重复拷贝。默认情况下，引用和变量相同，均为不可变，因此需要使用 “&amp;mut guess” 而非 “&amp;guess”。</p><p>‘.expect(“…”)’ 对函数返回结果的潜在风险进行处理。read_line 函数读取用户输入，并返回一个 io::Result 类型的数据。Result 类型广泛存在于 rust 的多个模块中，其实质是一个枚举类型，其值包括 Err、Ok，若得到的返回值为 Err，则将导致程序 crash 并使用expect提供的信息，若得到 Ok，则返回其携带的数值。若为使用 expect 函数，在编译过程中，rust 将给出警告。</p><p>rust 使用 “{}” 作为程序格式化输出的占位符：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x=&#123;&#125;, y=&#123;&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><p>其次，为了完成猜数游戏，需要学习如何获得随机数。rust 的标准库中并不提供随机数的支持，不过其拥有丰富的 crates 作为语言的扩展支持，修改 Cargo.toml 引入 rand 模块的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">rand = &quot;0.8.3&quot;</span><br></pre></td></tr></table></figure><p>cargo 在执行 build 时将自动构建对应的依赖关系，包括 rand 模块本身的依赖内容。其版本号符合 SemVer 标准，表明项目依赖的 rand 模块需要在 0.8.3 到 0.9.0 之间，高于或等于 0.9.0 则无法保证 api 的一致性。cargo build 将只对程序修改内容进行编译，引入的 crates 只会编译一次。Cargo.lock 指明了依赖项目的版本，从而保证任何时间、任何人都可以成功编译这份项目代码。在 crates 有可升级的版本时，请在项目根目录下执行 cargo update。若需要大版本的更新，请修改 Cargo.toml 文件。</p><p>下面使用 rand 生成 1 到 100 的随机数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="number">1</span>..<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rng trait 中定义了很多关于随机数生成方法的接口，为了使用这些方法，首先使用 use 引入。rand::thread_rng 提供了随机数生成器：在当前线程中并使用系统种子运行。利用 gen_range 生成 1 到 100 之间的随机数，范围左闭右开，当然，也可使用 “1..=100” 作为左闭右闭的参数。</p><p>当使用一个新的 crate 时，可以在项目目录中使用命令 cargo doc –open 查看当前项目中所有模块的文档。</p><p>接下来，需要对用户输入和随机数字进行比较：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> guess = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> secret_number = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">match</span> guess.cmp(&amp;secret_number) &#123;</span><br><span class="line">        Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">        Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">        Ordering::Equal =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>)</span><br><span class="line">            <span class="comment">// more</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了进行结果的比较，需要引入 Ordering，类似于 Result，其亦为枚举类型，不过其内包含 Greater、Less、Equal 三个元素。使用变量的内联方法 cmp 对两个数值结果进行比较，其将返回一个 Ordering 类型的结果，使用 match 对该结果进行分支比较，依次比较 3 种 Ordering 的可能值，当匹配成功则执行 =&gt; 后的语句，可以使用 “{}” 执行多条语句。</p><p>不过 cmp 函数需要比较相同的类型，如整数和 string 执行 cmp，将无法通过编译。rust 内置了一些基本的类型，比如数字的 i32，u32，i64，u64 等，分别表示有符号和无符号的 32 位和 64 位整形数据，在定义变量时可明确指出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> secret_number = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> guess = <span class="built_in">String</span>::new();</span><br><span class="line">    <span class="keyword">let</span> guess: <span class="built_in">u32</span> = guess.trim().parse().expect(<span class="string">&quot;Please input number!&quot;</span>);</span><br><span class="line">    <span class="comment">// get input from terminal here</span></span><br><span class="line">    <span class="keyword">match</span> guess.cmp(secret_number) &#123;</span><br><span class="line">        <span class="comment">// arms here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 rust 中，可以重复定义一个变量，这在将一个数据类型转换为其他数据类型的情况下很有用，无需定义两个不同类型的相同变量。trim 函数将去除字符串前后的空白字符，parse 函数则解析字符串并转换为数字，定义变量时通过 “: u32” 指明 guess 为无符号32位整型数据，因此，rust 在执行 cmp 时，即可隐式推断 secret_number 为一个 u32 类型数据。</p><p>rust 可以使用 loop 进行循环，并使用 break 和 continue 实现循环的跳转。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// loop body</span></span><br><span class="line">        <span class="comment">// break;</span></span><br><span class="line">        <span class="comment">// continue;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，可以为标准 io 提供更健壮的错误处理方式:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        io::stdin()</span><br><span class="line">            .read_line(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">            .expect(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> guess: <span class="built_in">u32</span> = <span class="keyword">match</span> guess.trim().parse() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="literal">Err</span>(\_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ok(num) 匹配附带一个参数的 Ok 枚举值，Err(_) 匹配附带任意参数的错误结果。完整程序如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="number">1</span>..=<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> guess = <span class="built_in">String</span>::new();</span><br><span class="line"></span><br><span class="line">        io::stdin()</span><br><span class="line">            .read_line(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">            .expect(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// let guess: u32 = guess.trim().parse()</span></span><br><span class="line">        <span class="comment">//                        .expect(&quot;Please input a number!&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> guess: <span class="built_in">u32</span> = <span class="keyword">match</span> guess.trim().parse() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="literal">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Your guessd is: &#123;&#125;&quot;</span>, guess);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> guess.cmp(&amp;secret_number) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too Big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123; </span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、语言基础"><a href="#三、语言基础" class="headerlink" title="三、语言基础"></a>三、语言基础</h1><p>在这一部分，主要学习 rust 语言的基础知识，如变量、数据类型、函数、注释以及控制流。</p><p>学习之前，请首先<a href="https://doc.rust-lang.org/book/appendix-01-keywords.html">了解 rust 保留的关键字</a>，在后续程序的编写过程中以避免使用这些关键字来定义自己的名称。</p><h2 id="变量及其可变性"><a href="#变量及其可变性" class="headerlink" title="变量及其可变性"></a>变量及其可变性</h2><p>正如第二章提到的，默认情况下，rust 定义的变量都是不可变的，这与其他语言有所区别，也同样因此使 rust 更具安全性和并发性。当然，也可以根据需要，令定义的变量可变。</p><p>如之前所提到的，rust 使用 let 来定义一个变量，如果该变量是不可变的，一旦这个变量绑定到某个值后，其值将不能被改变，当尝试编译如下的程序时，将会失败，并给出 “ cannot assign twice to immutable variable” 的警告。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rust 保证了声明为不可变的变量一旦绑定了数值后将永远不再改变，对于这种变量，无需考虑其在何时、何处以及怎样发生改变。</p><p>如果需要可变的变量，需要使用 mut 关键字显式声明，只需将 mut 放在变量名前即可。此时我们修改上述程序即可正常编译并运行，因为我们操纵的是一个可变的变量。使用变量的可变性是对错误和效率等问题的权衡和折中，不可变行提供了更高的安全性，而可变变量则可能避免了新变量的反复创建和拷贝等。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// let x = 5;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他语言中，有常量（constant）的概念，类似于 rust 的不可变变量，但是 rust 的常量和变量存在一些区别：</p><ul><li>不允许将 mut 和常量一起使用，因为常量是永远的恒值，而非默认为恒值；</li><li>当使用 const 而不是 let 来声明一个常量时，必须指明数据类型；</li><li>const 可以声明在任意作用域中，包括全局作用，而 let 无法声明在全局作用域中；</li><li>常量的值只能是常量表达式，不能是任意一个运行时获取的值。</li></ul><p>下面声明了两个常量，rust 建议使用大写作为常量的名称，否则将在编译器给出警告。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX: <span class="built_in">u32</span> = <span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">const</span> MIN: <span class="built_in">u32</span> = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;, MAX is &#123;&#125;, MIN is &#123;&#125;&quot;</span>, x, MAX, MIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除变量不可变的特性外，变量与其他语言仍有一个明显的特点：rust 支持对已定义的变量进行覆盖（常量不具有这样的特性，rust 将其称为 Shadowing），即在已定义的变量后，可以重新定义一个同名的变量来覆盖，如下面给出的程序，最后 x 的值为 7。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> x = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> x = x + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shadowing 和 mut 是不同的，若没有 let 关键字，这种 “x = x + 1” 对变量的操作是不允许的，通过Shadowing 可以对已有变量进行一些转换并得到新的不可变变量。</p><p>除了上述特性外，Shadowing 也可以实现不同类型的转换，这和 mut 是不同的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spaces = <span class="string">&quot;  &quot;</span>;        <span class="comment">// String</span></span><br><span class="line"><span class="keyword">let</span> spaces = space.len(); <span class="comment">// integer</span></span><br></pre></td></tr></table></figure><p>如果使用 mut 来定义 spaces，则无法通过编译，即我们不能改变 mut 变量名的类型。</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>rust 是静态类型语言，在编译期必须明确各个变量的数据类型。数据类型可以在代码中明确指定，除此外，也可以通过上下文推断。如猜数游戏中，定义 guess 必须指定其类型为 “u32”，否则，parse 函数通过编译。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> guess: <span class="built_in">u32</span> = <span class="string">&quot;42&quot;</span>.parse().expect(<span class="string">&quot;Not a number!&quot;</span>);</span><br></pre></td></tr></table></figure><p>下面介绍 rust 数据类型的两个子集：标量类型和复合类型。</p><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p>rust 中的标量类型，即在其他语言中常见的如整型、浮点类型、布尔类型和字符类型。</p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>在 rust 表示整形的方法为 “u/i位长度”，u 表示无符号数，i表示有符号整数，包括：</p><table><thead><tr><th align="center">长度</th><th align="center">有符号</th><th align="center">无符号</th></tr></thead><tbody><tr><td align="center">8-bits</td><td align="center">i8</td><td align="center">u8</td></tr><tr><td align="center">16-bits</td><td align="center">i16</td><td align="center">u16</td></tr><tr><td align="center">32-bits</td><td align="center">i32</td><td align="center">u32</td></tr><tr><td align="center">64-bits</td><td align="center">i64</td><td align="center">u64</td></tr><tr><td align="center">128-bits</td><td align="center">i128</td><td align="center">u128</td></tr><tr><td align="center">arch</td><td align="center">isize</td><td align="center">usize</td></tr></tbody></table><p>可以使用 “i/usize” 使用操作系统支持的整形长度，在对集合进行索引时常常使用到这种类型。此外，rust 支持多种进制的字面值表示：</p><table><thead><tr><th align="center">字面值类型</th><th align="center">表示</th></tr></thead><tbody><tr><td align="center">10进制</td><td align="center">123_456_789</td></tr><tr><td align="center">16进制</td><td align="center">0xABCD</td></tr><tr><td align="center">8进制</td><td align="center">0o77</td></tr><tr><td align="center">2进制</td><td align="center">0b1111_0000</td></tr><tr><td align="center">字符(u8)</td><td align="center">b’A’</td></tr></tbody></table><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>rust 使用 f32 和 f64 分别表示 32 位浮点数和 64 位浮点数，rust 默认使用 64 位浮点数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1.0</span>;        <span class="comment">// f64</span></span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">f32</span> = <span class="number">1.2</span>;   <span class="comment">// f32</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="built_in">f64</span> = <span class="number">2.2</span>;   <span class="comment">// f64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数值操作"><a href="#数值操作" class="headerlink" title="数值操作"></a>数值操作</h4><p>同样，rust 为数值类型提供了加减乘除的操作符，其计算结果绑定到一个变量上：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> dif = <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> mul = <span class="number">1</span> * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> div = <span class="number">2</span> / <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> m   = <span class="number">2</span> % <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>rust 使用 true、false 作为布尔值 bool 的字面值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> f: <span class="built_in">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p>rust 的 char 类型为 4 字节的长度的 unicode 支持的常量值，能够表示包括中文、日文等多种字符。使用单引号表示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> z = <span class="string">&#x27;ℤ&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> heart_eyed_cat = &#x27;😻&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>rust 的复合类型可以将多个数值集合到一个数据类型中来表示，主要有两种：元组（tuples）和数组（arrays）。</p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组是一种将多种不同类型数据集合到一起的常用的方法，其一旦创建，长度固定不可修改，元组使用圆括号表示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用元组，有方便的方法对其中的每个元素解包：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tup = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，可以通过元组索引来访问其中任意元素，使用 “tuple.index” 实现，其索引范围从 0 开始：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> five_hundred = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> six_point_four = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> one = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组中的每一个元素的数据类型必须相同，其长度是固定的，使用方括号表示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所需数据集合为相同类型且希望将数据分配在堆上而不是栈上或始终需要固定数量的数据时，使用数据可能是一个选择，不过，其不如 vector （标准库提供，后续介绍）灵活，后者可动态扩容。若无法明确使用数组或 vector，请使用 vector。</p><p>如，程序需要固定的一些信息，使用 array：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> months = [<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>,</span><br><span class="line">                <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明数组时，也可指明元素类型和长度：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>可以创建一个有相同元素的数组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>; <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>a 的值为 [3, 3, 3, 3, 3]。</p><p>数组的元素值可以使用索引访问：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> first = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> end   = a[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>在程序中，如果潜在索引越界，程序是可以编译成功的，但当运行时遇到越界问题，将导致程序运行失败。在其他语言中，当遇到越界问题时，程序会继续运行，而 rust 将阻止这种情况的发生，通过立即退出来阻止对非法内存的访问，这里利用所学的语言特性提供了例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;input index:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> index = <span class="built_in">String</span>::new();</span><br><span class="line"></span><br><span class="line">    io::stdin()</span><br><span class="line">        .read_line(&amp;<span class="keyword">mut</span> index)</span><br><span class="line">        .expect(<span class="string">&quot;Faile to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> index : <span class="built_in">usize</span> = index.trim().parse().expect(<span class="string">&quot;Index not a number&quot;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> element = a[index];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value is &#123;&#125;, index is &#123;&#125;&quot;</span>, element, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义和传参"><a href="#函数定义和传参" class="headerlink" title="函数定义和传参"></a>函数定义和传参</h3><p>rust 使用 fn 关键字来定义函数，如所见的 main 函数，我们同样可以定义其他函数，包括无参数函数、有参数函数等，函数参数必须指明数据类型，当然各个参数可以有各自的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    test();</span><br><span class="line">    test_args(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This is test fn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_args</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The arg is x:&#123;&#125;, y:&#123;&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="statements-和-expressions"><a href="#statements-和-expressions" class="headerlink" title="statements 和 expressions"></a>statements 和 expressions</h3><p>函数体由 statements 和 expressions 组成，expressions 是 statement 的一部分。rust 是基于表达式的语言 （ expression-based）。statement 执行一些动作但是不返回值，expression 总是能够推断出结果。如 let 语句为一个 statement：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果试图将 let 语句绑定到一个新的变量，将无法编译，因为 let 语句不能返回值，因此也不能绑定新的变量。因此，在 rust 中与类似于 C 语言的 x=y=1 的行为不同。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y = (<span class="keyword">let</span> x = <span class="number">6</span>); <span class="comment">// comile error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的函数定义也是一个 statement。而计算并可得到结果的表达式组成了 rust 程序的绝大部分，诸如 5 + 6、100、调用函数、调用宏等以及使用 “{}” 包裹的多条语句，都是或能够成为表达式，表达式的结尾不包含分号，否则其将转换为 statement，并且将不会返回值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;; <span class="comment">// 一个表达式，注意 x + 1 后无分号结尾，此 expression 结果为 11</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x out is &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y is &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>在 rust 中， 使用 “-&gt;” 来指明返回值类型，整个函数体和 “{}” 包裹的表达式是同义的。当然，函数可以使用 return 关键字提前返回结果，大多数函数隐式返回最后一个表达式。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">five</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = five();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数的最后一个语句加上了分号，且指明函数需要返回值或需要使用它的返回值，此时将无法编译，因为现在 expression 因为分号变成了 statement。</p><h2 id="程序注释"><a href="#程序注释" class="headerlink" title="程序注释"></a>程序注释</h2><p>支持 “//“ 的行注释和文档注释（后续章节中介绍）。</p><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>使用 if else 分支，当 if 后的条件为 true，将执行其后 “{}” 包裹的语句，或称 arms。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x &gt; 5&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x &lt;= 5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，rust 中，if 的条件<strong>必须显式为 bool 类型</strong>，否则不能通过编译，这与 C 的隐式转换不同。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> y &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;y is not 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 不能通过编译，不存在到 bool 的隐式转换。</span></span><br></pre></td></tr></table></figure><p>当存在多个条件状态时，使用 else if 语句处理：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 4&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 3&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当代码存在过多的 else if 需要进行重构，后续将介绍 match 来应对这种状况。</p><h3 id="表达式中的分支"><a href="#表达式中的分支" class="headerlink" title="表达式中的分支"></a>表达式中的分支</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">if</span> y &#123; <span class="number">199</span> &#125; <span class="keyword">else</span> &#123; <span class="number">299</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;z is &#123;&#125;&quot;</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，各个 arms 的值的类型必须相同，否则无法编译，rust 必须在编译器明确各个变量的类型。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>使用 loop 执行循环操作，配合 break 和 continue 来实现循环内复杂的跳转。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun main() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;again&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 c 语言不同的，rust 的循环也是一个表达式（expression），即其可以返回值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;result is &#123;&#125;&quot;</span>, result); <span class="comment">// result = 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带有条件的循环"><a href="#带有条件的循环" class="headerlink" title="带有条件的循环"></a>带有条件的循环</h3><p>和其他语言类似，rust 提供了带有条件的 while 循环，其行为和其他语言类似：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> number = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line"></span><br><span class="line">        number -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="范围for"><a href="#范围for" class="headerlink" title="范围for"></a>范围for</h3><p>当遍历一个集合时，for 循环是一个方便的选择：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如使用 for 逆序打印得 3、2、1：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).rev() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="四、所有权（ownership）"><a href="#四、所有权（ownership）" class="headerlink" title="四、所有权（ownership）"></a>四、所有权（ownership）</h1><p>所有权是 rust 语言的重要概念，其使 rust 在没有垃圾回收的概念下仍然保证了内存安全。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>继续学习 rust 之前，需要了解所有权的概念。对于包含 GC 的语言，使用者无需担忧内存的使用和释放，对于类似于 C 的语言，使用者则必须明确在动态分配的内存无用时显式释放。而 rust 则使用了另一种方法：其使用一系列的规则在编译期就明确了内存的所有权，所有权的特性不会在运行时拖慢程序的效率。</p><blockquote><p><strong>堆和栈</strong></p><p>存储在栈上的数据必须在编译器明确了使用内存的尺寸，对于运行期才能确定内存的变量，则分配在堆上。对于堆和栈中的变量的使用，前者的效率明显低于后者，因为前者伴随了内存分配器分配内存等一系列的复杂操作。对于追踪变量到底分配在堆或栈、减少堆中重复数据、及时释放不再使用的内存等，都属于所有权问题。</p></blockquote><h3 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h3><p>rust 所有权的基本规则如下：</p><ul><li>每一个值都有一个变量作为它的拥有者（owner）;</li><li>每一个值只能有一个 owner；</li><li>当 owner 变量离开其作用域（scope），该值将被丢弃（drop）；</li></ul><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>此部分并非 rust 独有的概念，其与 C 语言作用域的概念基本相同，变量在创建后生效，离开其所在的作用域失效：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s is not valid here, it’s not yet declared</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// s is valid from this point forward</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// do stuff with s</span></span><br><span class="line">&#125;                      <span class="comment">// this scope is now over, and s is no longer valid</span></span><br></pre></td></tr></table></figure><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>为了进一步说明作用域的概念，此处引入了更复杂的数据类型。前面提到的整型等数据类型，均分配在栈中，String 类型则是分配在堆上的一个例子。使用 String 的 from 函数创建一个初始化的字符串，并使用 push_str 来追加。当使用调用 from 函数时，rust 将在堆上分配内存并将一个字母串字面值赋予该变量，当字符串变量离开其作用域，一个类似于 free 的动作则必须且只能被自动执行一次以保证内存安全，这个函数在 rust 中是 <strong>drop</strong> 函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s.push_str(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// push_str() appends a literal to a String</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// This will print `hello, world!`</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s is valid from this point forward</span></span><br><span class="line">    <span class="comment">// do stuff with s</span></span><br><span class="line">&#125;                                  <span class="comment">// this scope is now over, and s is no</span></span><br><span class="line">                                    <span class="comment">// longer valid</span></span><br></pre></td></tr></table></figure><h3 id="数据在变量间的移动和拷贝"><a href="#数据在变量间的移动和拷贝" class="headerlink" title="数据在变量间的移动和拷贝"></a>数据在变量间的移动和拷贝</h3><p>相同的数据可以在不同的变量间进行交互，对于基本的数据类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br></pre></td></tr></table></figure><p>x 和 y 的值将同时为 1，因为 1 是一个固定长度的编译期已知的分配在栈上的简单数据。而对于更复杂的数据，其行为可能完全不同：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br></pre></td></tr></table></figure><p>对于字符串而言，其 owner 由三个部分组成：指向堆数据的指针、实际数据长度以及堆预分配内存的长度。当将 s1 赋值给 s2，仅仅操作以上三部分数据，而真实指向的数据却并不会拷贝。</p><p>然而，在 rust 中，以上并不是一个简单的浅拷贝，若符合浅拷贝的行为，则 s1 和 s2 两个 owner 将共享一份相同的数据，所以当 s1 和 s2 同时离开所属的作用域后，必然导致了堆相同数据的重复释放。</p><p>故，在 s1 赋值给 s2 后，s1 将失效，这也导致当 s1 离开其作用域时，将不会发生任何事情，这是一个<strong>移动</strong>操作，而非拷贝，字符串 “hello” 所占用的内存释放的任务将交由 s2 完成。因此，以下的行为将导致编译错误，因为 s1 已经是一个非法的变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br></pre></td></tr></table></figure><blockquote><p>rust 永远不会主动进行数据的深拷贝。</p></blockquote><p>若需要深拷贝的操作，请调用 clone 函数，此时，s1 和 s2 持有的是不同内存上的同值数据，clone 拷贝了堆数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.clone();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br></pre></td></tr></table></figure><p>然而，以上的概念对于只存在于栈上的数据而言，看起来是无效的。正如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br></pre></td></tr></table></figure><p>此时 x 和 y 同时拥有数值 5，没有调用 clone，也没有移动行为的发生（x 并未失效）。</p><p>原因在于，数据 1 是一个尺寸大小已知分配在栈上的整型数据，浅拷贝或深拷贝对于这种数据来说并没有什么不同。因此，对于这种简单数据类型，则忽略移动和克隆语义。</p><p>rust 为这种类型提供了 Copy trait，通过调用 Copy 可以将该数据存放在栈上。若一个数据类型实现了 Copy，则其不能实现 Drop，反之也相同。Copy 保证了赋值给新的数据后旧的数据仍然可用。</p><p>包括整型、布尔、浮点类型、字符类型、全部元素均含有 Copy 的 元组类型等，都实现了 Copy。</p><h3 id="所有权和函数"><a href="#所有权和函数" class="headerlink" title="所有权和函数"></a>所有权和函数</h3><p>rust 函数的参数和返回值，在使用上和其他语言有很大区别。传值给函数类似于给变量赋值。因此，对于实现了 Copy 的数据类型的数据，传给函数并离开函数作用域后，该数据仍然可用，对于实现了 Drop 的数据，当传递给函数后，相当于执行了移动语义，原始变量无效，此数据的生命周期将交由函数管理。</p><p>这个例子可以清晰地说明这个问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s comes into scope</span></span><br><span class="line"></span><br><span class="line">    takes_ownership(s);             <span class="comment">// s&#x27;s value moves into the function...</span></span><br><span class="line">                                    <span class="comment">// ... and so is no longer valid here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;                      <span class="comment">// x comes into scope</span></span><br><span class="line"></span><br><span class="line">    makes_copy(x);                  <span class="comment">// x would move into the function,</span></span><br><span class="line">                                    <span class="comment">// but i32 is Copy, so it&#x27;s okay to still</span></span><br><span class="line">                                    <span class="comment">// use x afterward</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// Here, x goes out of scope, then s. But because s&#x27;s value was moved, nothing</span></span><br><span class="line">  <span class="comment">// special happens.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_ownership</span></span>(some_string: <span class="built_in">String</span>) &#123; <span class="comment">// some_string comes into scope</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// Here, some_string goes out of scope and `drop` is called. The backing</span></span><br><span class="line">  <span class="comment">// memory is freed.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">makes_copy</span></span>(some_integer: <span class="built_in">i32</span>) &#123; <span class="comment">// some_integer comes into scope</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// Here, some_integer goes out of scope. Nothing special happens.</span></span><br></pre></td></tr></table></figure><p>同样，对于函数的返回值，在返回后将移动给调用者，并由其调用者管理生命周期。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = gives_ownership();         <span class="comment">// gives_ownership moves its return</span></span><br><span class="line">                                        <span class="comment">// value into s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 comes into scope</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s3 = takes_and_gives_back(s2);  <span class="comment">// s2 is moved into</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back, which also</span></span><br><span class="line">                                        <span class="comment">// moves its return value into s3</span></span><br><span class="line">&#125; <span class="comment">// Here, s3 goes out of scope and is dropped. s2 goes out of scope but was</span></span><br><span class="line">  <span class="comment">// moved, so nothing happens. s1 goes out of scope and is dropped.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gives_ownership</span></span>() -&gt; <span class="built_in">String</span> &#123;             <span class="comment">// gives_ownership will move its</span></span><br><span class="line">                                             <span class="comment">// return value into the function</span></span><br><span class="line">                                             <span class="comment">// that calls it</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> some_string = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>); <span class="comment">// some_string comes into scope</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// some_string is returned and</span></span><br><span class="line">                                             <span class="comment">// moves out to the calling</span></span><br><span class="line">                                             <span class="comment">// function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back will take a String and return one</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(a_string: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123; <span class="comment">// a_string comes into</span></span><br><span class="line">                                                      <span class="comment">// scope</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// a_string is returned and moves out to the calling function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用函数后仍然希望使用原有的参数呢？可以考虑将参数返回后在继续使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s2, len) = calculate_length(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: <span class="built_in">String</span>) -&gt; (<span class="built_in">String</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> length = s.len(); <span class="comment">// len() returns the length of a String</span></span><br><span class="line"></span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，rust 提供的引用将更好地解决这个问题。</p><h2 id="引用和借用-（Reference-and-Borrowing）"><a href="#引用和借用-（Reference-and-Borrowing）" class="headerlink" title="引用和借用 （Reference and Borrowing）"></a>引用和借用 （Reference and Borrowing）</h2><p>如上一小节所述，在函数调用发生后仍然需要使用原有参数变量是常见的需求，除了函数再次返回该参数作为解决方案外，还可以使用引用，使用引用将能够关联一些数据并无需接管其生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与引用相反的操作是：解引用 *，此处不做介绍。</p></blockquote><p>我们传递 “&amp;s1” 作为函数的参数，且，函数参数 “s: &amp;String” 表明其接受一个 String 类型的引用。函数参数在函数内有效，当离开函数作用域后，s 不会释放 s1 所持有的数据。</p><p>我们把使用引用作为函数参数成为借用。注意，正如变量的不可变，引用在默认情况下同样不可改变其引用的数据，如下的例子试图修改引用的数据，将无法通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    change(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何修改被引用的数据？需引用一个 mut 变量，并在函数签名中使用 “&amp;mut”：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，rust 要求一个变量在一个作用域中只能接受一个可变引用，否则将编译失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br></pre></td></tr></table></figure><p>这种限制防止了数据竞争，尤其在以下几种场景中：</p><ul><li>多个指针同时指向相同的数据；</li><li>至少一个指针正在写数据；</li><li>没有数据同步机制；</li></ul><p>rust 通过这种机制避免了数据的竞争，它甚至在有潜在数据竞争发生的可能下禁止编译这份代码。</p><p>当然，可以在不同作用域中使用多个可变引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125; <span class="comment">// r1 goes out of scope here, so we can make a new reference with no problems.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure><p>此外，当存在一个可变引用时，无法存在不可变引用，因为需要在不可变引用存续期间保证变量的不可变性，不过多个不可变引用可以同时存在：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// BIG PROBLEM</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure><p>只有在不可变引用最后一次使用后，才能定义新的可变引用，因为此时无需保证数据的不变性：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line"><span class="comment">// r1 and r2 are no longer used after this point</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// no problem</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r3);</span><br></pre></td></tr></table></figure><p>还有一个问题是，可能存在空悬引用，在使用指针的语言系统中，这是一个常见的问题，不过 rust 的编译器保证了空悬引用不会存在，当存在这种情况将不能通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> reference_to_nothing = dangle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123; <span class="comment">// dangle returns a reference to a String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s is a new String</span></span><br><span class="line"></span><br><span class="line">    &amp;s <span class="comment">// we return a reference to the String, s</span></span><br><span class="line">&#125; <span class="comment">// Here, s goes out of scope, and is dropped. Its memory goes away.</span></span><br><span class="line">  <span class="comment">// Danger!</span></span><br></pre></td></tr></table></figure><p>函数试图返回一个已经离开声明周期的变量的引用是危险的操作，不过 rust 已经在编译器帮我们避免了这些可能。如果返回的是变量，则会通过移动将生命周期移交，不会存在这种问题。</p><blockquote><p>引用</p><p>任何时候，只能存在一个可变引用或多个不可变引用，且引用存在期间必须合法。</p></blockquote><h2 id="切片类型（The-Slice-Type）"><a href="#切片类型（The-Slice-Type）" class="headerlink" title="切片类型（The Slice Type）"></a>切片类型（The Slice Type）</h2><h3 id="不使用切片可能会产生的问题"><a href="#不使用切片可能会产生的问题" class="headerlink" title="不使用切片可能会产生的问题"></a>不使用切片可能会产生的问题</h3><p>除了引用没有所有权外，另一个没有所有权的类型是切片。通过切片可以借用字符串、数组等数据的一部分或全部，从而避免使用索引后原有数据发生改变导致索引无效的问题。</p><p>这里给出一个简单的例子，创建一个函数来获得一个字符串的第一个单词。注意声明函数的格式，包括参数、返回值类型以及最后一个语句没有冒号（expression 而非 statement）。在不引入切片时，函数可以返回第一个空白字符的位置作为第一个单词结尾的索引。此处使用 String 的 as_bytes 将 String 转为字符数组，使用数据的 iter 函数获取迭代器，使用迭代器的 enumerate 函数将返回数组的索引和对应索引的元素所组成的元组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，存在的一个问题是，当调用函数后，原始字符串发生了改变，则返回的索引将失效，这导致了潜在的 bug：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> word = first_word(&amp;s); <span class="comment">// word will get the value 5</span></span><br><span class="line"></span><br><span class="line">    s.clear(); <span class="comment">// this empties the String, making it equal to &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// word still has the value 5 here, but there&#x27;s no more string that</span></span><br><span class="line">    <span class="comment">// we could meaningfully use the value 5 with. word is now totally invalid!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，可以来判断 s 的 size，但是，这又如何判断此时的 s 是否是原有的 s 呢？</p><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><p>使用切片可以解决上述问题，字符串切片在 rust 中使用 “&amp;str” 来表示，注意，其和 String 并不是相同的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> world = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure><p>字符串切片使用 &amp;string_name[begin..end] 来表示，左闭右开。若 begin 为字符串开始，可省略，若 end 为字符串结尾，可省略：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = &amp;s[..<span class="number">5</span>];  <span class="comment">// hello 的类型为 &amp;str，非 String</span></span><br><span class="line"><span class="keyword">let</span> world = &amp;s[<span class="number">6</span>..];</span><br><span class="line"><span class="keyword">let</span> hello_world = &amp;s[..];</span><br></pre></td></tr></table></figure><p>字符串切片实际上是对字符串一部分的引用，其所属权的规则与引用相同。需要注意，在使用字符串引用时，需保证其字符串为utf-8有效编码。</p><p>使用切片，可以重写上一个例子，需要注意返回值的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，在调用这个函数时后而未使用 word 前，若尝试修改 s 将无法通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> word = first_word(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.clear(); <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first word is: &#123;&#125;&quot;</span>, word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在引入引用和借用概念时，提到过<strong>当存在不可变引用时，不能创建可变引用</strong>，调用函数后返回了 s 的一个切片，即一个不可变引用（切片默认为不可变引用），当试图修改字符串 s 时，此时需要使用数据的一个可变引用，故失败。当最后一次使用 word后，我们才能修改 s。</p><p>使用切片保持了 word 相对于 s 的状态。</p><h3 id="字符串字面值是一个切片"><a href="#字符串字面值是一个切片" class="headerlink" title="字符串字面值是一个切片"></a>字符串字面值是一个切片</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// the type of s is &amp;str</span></span><br></pre></td></tr></table></figure><p>“Hello, world!” 是一个字符串字面值，其真实的数据类型为字符串切片，即 &amp;str，因此字符串字面值是不可变的。</p><h3 id="字符串切片作为函数参数"><a href="#字符串切片作为函数参数" class="headerlink" title="字符串切片作为函数参数"></a>字符串切片作为函数参数</h3><p>除了上述作为返回值，切片同样可以作为函数参数传入:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="comment">// fn body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用字符串切片作为参数具有更高的适用性，如果参数类型是 String，则无法传入切片，相反，却能够简单地将字符串作为参数传入函数:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> my_string = <span class="built_in">String</span>::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word works on slices of `String`s</span></span><br><span class="line">    <span class="keyword">let</span> word = first_word(&amp;my_string[..]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> my_string_literal = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word works on slices of string literals</span></span><br><span class="line">    <span class="keyword">let</span> word = first_word(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Because string literals *are* string slices already,</span></span><br><span class="line">    <span class="comment">// this works too, without the slice syntax!</span></span><br><span class="line">    <span class="keyword">let</span> word = first_word(my_string_literal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他类型的切片"><a href="#其他类型的切片" class="headerlink" title="其他类型的切片"></a>其他类型的切片</h3><p>不止 String，还有一些数据类型也有切片的概念，如元素类型为 u32 的数组，其切片类型表示为 &amp;[u32]，此处仅简单了解即可，后续会有更详细的介绍。</p><h1 id="五、数据结构"><a href="#五、数据结构" class="headerlink" title="五、数据结构"></a>五、数据结构</h1><p>此章节学习 rust 中数据结构的定义和使用。</p><h2 id="定义并实例化-struct"><a href="#定义并实例化-struct" class="headerlink" title="定义并实例化 struct"></a>定义并实例化 struct</h2><p>使用关键字 struct 可以将许多不同类型的数据组织在一起，例如，定义一个简单的结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;           <span class="comment">// the name of the struct is User</span></span><br><span class="line">    username: <span class="built_in">String</span>,   <span class="comment">// ver_name: ver_type,</span></span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该结构时，使用 struct_name { key: value} 的形式来创建其实例。注意，无需在意变量的顺序，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以使用 “.” 方法来读取数据，对于可变的实例，可以使用 “.” 方法修改数据，此时整个结构的所有变量均可变，rust 不允许结构部分变量可变：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user1.email = <span class="built_in">String</span>::from(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br></pre></td></tr></table></figure><p>当然可以使用函数来实例化一个结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email: email,</span><br><span class="line">        username: username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，rust 提供了更方便的特性来避免函数参数在实例化结构体时需要显式指明的问题，若函数参数名和结构体的元素名相同时，可以省略其value，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，只需要使用 email 替代 email: email 即可。为了创建与已有 struct 仅存在少量区别时，使用 update 语法可以更简单地实现这个需求。例如，已有 user1，此时需要建立一个 user2，其只有 email 和 username 是不同的，则可以在指明新变量的 key: value 后，使用 ..user1 指明 user2 的其他域元素均和 user1 相同，并从 user1 的value 进行实例化对应参数。注意，此时 user2 是一个新的实例。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">&quot;anotherusername567&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了上述 struct 的形式外，rust 还支持 tuple struct 的定义。与上述的普通 struct 相比，其内各个 fields 没有变量名:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>当我们需要为 tuple 类型指明一个名字时，即可以这样定义，如上述例子，black 是 Color 的一个实例，origin 是一个 Point 的一个实例。但是，尽管 Color 和 Point 的定义形式相同，但它们不是相同的类型，故需要 Color 参数的函数不接受 Point 类型的参数。tuple struct 的其他行为类似于普通的 tuple，如 “.index” 来索引元素、解元组操作等。</p><p>struct 也支持空的定义，即无任何 fields。这对于某些类型：不包含任何数据，但是其支持某些函数操作，是有用的。</p><p>struct 的元素支持引用类型，但是，此时需要使用 rust 生命周期的特性，来保证 struct 中的元素的生命周期长于 struct 结构，如下的使用方法是无法通过编译的。关于如何修复这个问题后续会有介绍。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: &amp;<span class="built_in">str</span>,</span><br><span class="line">    email: &amp;<span class="built_in">str</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">        email: <span class="string">&quot;someone@example.com&quot;</span>,</span><br><span class="line">        username: <span class="string">&quot;someusername123&quot;</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在程序中使用-struct"><a href="#在程序中使用-struct" class="headerlink" title="在程序中使用 struct"></a>在程序中使用 struct</h2><p>此节使用 struct 实现了一个计算长方形面积的程序，除了使用到了所学到的 struct 外，还使用了数据借用等知识点：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = Rectangle &#123;</span><br><span class="line">        width: <span class="number">50</span>,</span><br><span class="line">        height: <span class="number">30</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// need define Display to use &#123;&#125; for Rectangle</span></span><br><span class="line">    <span class="comment">// println!(&quot;rect &#123;&#125; area is &#123;&#125;&quot;, rect, area(&amp;rect));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// need define Debug or</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect &#123;:?&#125; area is &#123;&#125;&quot;</span>, rect, area(&amp;rect));</span><br><span class="line">     <span class="comment">// add #[derive(Debug)] before struct Rectangle</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect &#123;:#?&#125; area is &#123;&#125;&quot;</span>, rect, area(&amp;rect));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(rect: &amp;Rectangle) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    rect.width * rect.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中，试图打印 Rectangle 结构，我们尚未了解 struct 的方法，若使用 “{}” 来做占位符，则必须实现 Display，此外，我们还可以使用 “{:?}” 和 “{:#?}” 来作为占位符打印调试信息，此时必须定义 Debug 或在定义结构体前添加 “#[derive(Debug)]”，二者的区别在于前者只输出简单的字符串，后者更清晰地显示 struct 结构。</p><h2 id="struct-的方法"><a href="#struct-的方法" class="headerlink" title="struct 的方法"></a>struct 的方法</h2><p>方法类似于函数，不同的是其声明于 struct 内部，而且其第一个参数总是 self（想到python了没~）来表示 struct 本身，通过使用方法，我们可以将 上述程序重写如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = Rectangle &#123;</span><br><span class="line">        width: <span class="number">50</span>,</span><br><span class="line">        height: <span class="number">30</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;area is &#123;&#125;&quot;</span>, rect.area());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 impl 关键字，将 Rectangle 所拥有的方法定义在其后的 “{}” 中，方法的第一个参数是 “&amp;self”，并未明确指明其类型，如 “self: Rectangle”，因为 rust 可以自行推断。使用了引用，表示了该方法仅仅借用了实例的变量，不拥有其生命周期，若需要更改实例的变量值，必须使用 “&amp;mut self” 作为第一个参数，直接使用无引用的 “self” 作为第一个参数是很少见的，不过在将本实例转换为其他实例时可能会用到。</p><p>不论方法的第一个参数是 “self”, “&amp;self”, “&amp;mut self”，在使用方法时都无需关心是否需要对方法所属的实例的引用问题，rust 自动提供了对应内容，如例所示，二者是等价的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.distance(&amp;p2);</span><br><span class="line">(&amp;p1).distance(&amp;p2);</span><br></pre></td></tr></table></figure><p>当然，也可以为方法提供更多的参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt;= other.width &amp;&amp; <span class="keyword">self</span>.height &gt;= other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，在 impl 的作用域中，我们还可以定义关联函数（Associated Functions），这些函数不需要 self 参数。他们和 struct 关联在一起。关联函数通常用于返回该结构对应的新实例，例如 String 的 from 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，可以初始化一个正方形。对于关联函数来讲，使用 “::” 来调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sq = Rectangle::square(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>每个 struct 可以有多个 impl 区域，因此多个方法可以分别定义在不同的 impl 中。</p><h1 id="六、枚举和模式匹配"><a href="#六、枚举和模式匹配" class="headerlink" title="六、枚举和模式匹配"></a>六、枚举和模式匹配</h1><h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><h3 id="定义和使用简单的枚举"><a href="#定义和使用简单的枚举" class="headerlink" title="定义和使用简单的枚举"></a>定义和使用简单的枚举</h3><p>我们可以通过枚举来定义事件的所有不同的可能性，如 ip 地址的种类，包括 ipv4 和 ipv6，则为了后续的区分，可以定义一个枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们可以创建该枚举的实例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> four = IpAddrKind::v4;</span><br><span class="line"><span class="keyword">let</span> six  = IpAddrKind::v6;</span><br></pre></td></tr></table></figure><p>枚举中的所有的元素都属于该枚举命名空间，此时，four 和 six 同属于 IpAddrKind 类型，我们可以在函数传入参数来使用枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">use_enum</span></span>(ip_kind: IpAddrKind) &#123;</span><br><span class="line">    <span class="comment">// fn body</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> ipv4 = IpAddrKind::v4;</span><br><span class="line">    use_enum(ipv4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将枚举与数据绑定"><a href="#将枚举与数据绑定" class="headerlink" title="将枚举与数据绑定"></a>将枚举与数据绑定</h3><p>与 C 语言中常见的枚举类型不同的是，rust 可以将数据和枚举中的元素绑定到一起。例如，当我们需要明确每个 ip 地址是 v4 版本还是 v6版本的，按照往常的思路：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123; V4, V6&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    addr: <span class="built_in">String</span>,</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上述写法是正确的，但是有更方便的用法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">String</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，枚举的每个具体值可以和一个 String 类型的数据绑定：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="built_in">String</span>::from(<span class="string">&quot;my.home.com&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> remote = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure><p>因此，就不需要额外的 struct。然而，这并不是 enum 特性的终点：rust 中 enum 的不同元素可以绑定不同的数据类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，标准库 IpAddr 的定义方法如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ipv4Addr</span></span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ipv6Addr</span></span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(Ipv4Addr),</span><br><span class="line">    V6(Ipv6Addr),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在之前的代码中，我们定义了自己的 IpAddr，尽管标准库中也提供了相同的名字，但是由于我们并没有将其引入程序的命名空间，因此并不会发生冲突！</p></blockquote><h3 id="枚举与方法"><a href="#枚举与方法" class="headerlink" title="枚举与方法"></a>枚举与方法</h3><p>使用枚举可以有更多的想象空间，如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且可以为其定义附带的方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Message &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// method body would be defined here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = Message::Write(<span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们为使用 struct 实现上述操作，需要为每种动作定义一个类型，那么，处理起来将不那么方便！枚举方法的定义同 struct。</p><h3 id="Option-enum"><a href="#Option-enum" class="headerlink" title="Option enum"></a>Option enum</h3><p>Option 类型是标准库中定义的另一种枚举类型，该枚举使用广泛，其可以代表 something，也可以表示 nothing。实际上，<strong>rust 不像其他语言一样，它没有 null</strong>，null 表示由于某种原因当前没有值或当前无效的值，在有 null 概念的语言中，其值或是 null，或是非 null，而且，当把 null 作为非 null 来使用的时候，往往会造成不可估量的后果。</p><p>rust 不提供 null，但是它有一个枚举可以用来编码值的存在与否，即 “Option&lt;T&gt;“，其被标准库定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Option&lt;T&gt; 已经包含的程序的作用域中，无需引用，同时，使用 Some 和 None 也无需使用 “Option::” 前缀。”&lt;T&gt;“ 是 rust 中的泛型参数，此时，我们只需了解 “&lt;T&gt;“ 表示Some 可以保存任意类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> some_string = <span class="literal">Some</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> absent_number: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure><p>当使用 None 时，需要明确指明该数据的类型，以保证 rust 在编译期可以推断数据类型。此时需要注意的是，T 和 Option&lt;T&gt; 属于不同的类型，下面的代码无法通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">i8</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">Option</span>&lt;<span class="built_in">i8</span>&gt; = <span class="literal">Some</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = a + b;</span><br></pre></td></tr></table></figure><p>当我们使用 T 时，编译器可以保证我们使用的永远都是合法的数据，而无需检查其是否为空，只有当我们使用 Option&lt;T&gt; 时，我们才需要担心是否有非法数据的使用风险，因此，我们必须对其进行检查后才能继续使用，即我们必须显式将 Option&lt;T&gt; 转换为 T 类型，并且明确指明当其为空值时的处理方式。具体内容阅读<a href="https://doc.rust-lang.org/std/option/enum.Option.html">文档</a>。</p><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p>match 是 rust 提供的一种非常强大的控制流操作符，其可以在一系列的模式（Patterns）中进行匹配，并执行匹配成功后的模式所对应的代码。此中的模式可以是字面值、变量名、通配符（wildcards）以及其他多种类型。使用 match，具有强大的匹配能力，此外，其处理了所有可能性来保证程序的安全性。</p><p>文档给出了一个生动的例子：可以将 match 操作符工作的过程理解为硬币分拣的流程，不同面值的硬币其直径不同，这些硬币依次通过尺寸从小到大的孔洞，当某个硬币的直径和对应孔的直径匹配的时候，便筛选出这枚硬币，使用 rust 的 match 来实现一个硬币面值英文名与其数值匹配的程序：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">            <span class="number">10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>match 关键字后跟随待匹配的对象，其与 if 不同的是，if 要求其表达式的值必须为 bool 类型，而 match 的匹配值可以为任意类型。由 “{}” 包裹并由 “,” 分隔的是 match 的多个 arms，每个 arm 包含符号 “=&gt;” 左侧的待匹配模式和右侧的匹配后执行的代码。match 按照 arms 的顺序依次匹配检查，如果模式不能匹配，则继续执行下一个匹配，匹配后执行的代码是一个表达式，其表达式的值是 match 操作的返回值。如果匹配后需要执行多行代码，则可以使用 “{}” 将其包围。</p><p>当一个 arm 被匹配并执行后，将不会继续匹配。</p><p>match 的另一个有用的特性，其每个 arm 的 pattern 可以用以匹配绑定值的枚举，即：当 match 匹配一个绑定了值的枚举时，可以在匹配过程将其值绑定到指定的变量中。如下例子，coin 若匹配了 Coin::Quarter(UsState) 则 UsState 的值将绑定到 state 上，并在执行该 arm 对应的代码时使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    YiJiao,</span><br><span class="line">    WuJiao,</span><br><span class="line">    YiYuan,</span><br><span class="line">    BuCunZai(<span class="built_in">u32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">match_coin</span></span>(coin: Coin) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::YiJiao =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::WuJiao =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::YiYuan =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::BuCunZai(value) =&gt; value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> coin1 = Coin::WuJiao;</span><br><span class="line">    <span class="keyword">let</span> coin2 = Coin::YiJiao;</span><br><span class="line">    <span class="keyword">let</span> coin3 = Coin::YiYuan;</span><br><span class="line">    <span class="keyword">let</span> coin4 = Coin::BuCunZai(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot; value=&#123;&#125;&quot;</span>, match_coin(coin1));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot; value=&#123;&#125;&quot;</span>, match_coin(coin2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot; value=&#123;&#125;&quot;</span>, match_coin(coin3));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot; value=&#123;&#125;&quot;</span>, match_coin(coin4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>match 还可以用以匹配 Option&lt;T&gt; 类型（之前学习过，其为枚举类型，内含 None 和 Some(val) 两种变体，用以处理空的情况）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> y = plus_one(<span class="literal">Some</span>(x));</span><br><span class="line">    <span class="keyword">let</span> z = plus_one(<span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125; &#123;:?&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 rust 中，使用 match 匹配一个枚举，绑定数据，并使用该数据进行后续处理是常见的情景。</p></blockquote><p>使用 match 时，特别需要注意的是，必须处理枚举所有可能的值，否则无法通过编译，这也增加了代码的安全性。那么如果无法列出所有的情况该如何？使用占位符（Placeholder) “_”，占位符可以匹配任何值，这种情况下，如果不使用占位符，同样无法通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="number">0u8</span>;</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;five&quot;</span>),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;seven&quot;</span>),</span><br><span class="line">    _ =&gt; (), <span class="comment">// () 表示一个 unit value，不会发生任何事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于复杂的匹配场景来说，match 是有用的，但是如果只有简单的匹配问题呢，我们应该使用 if let。</p><h2 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a>if let</h2><p>使用 if let 可以使用更少的代码处理只匹配一种值的情形，例如，只处理一个值时：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">1</span> = x &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x = 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，等号右边是待匹配的值，左边是与之匹配的值。如果使用 match，还需要使用占位符处理其他情况。不过，使用 if let 就意味着放弃了 match 的安全性。当然，if let 也可以和 else 一起使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Coin::Quarter(state) = coin &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、Packages-Crates-and-Modules"><a href="#七、Packages-Crates-and-Modules" class="headerlink" title="七、Packages, Crates, and Modules"></a>七、Packages, Crates, and Modules</h1><p>直至本节开始之前，学习的代码都在一个文件、一个 module 中。随着项目愈加复杂，我们需要更高效的代码管理方法，如：拆分代码到多个文件、多个 modules；引入封装来重用代码和指定私有属性和共有接口等、引入 scope 来处理命名问题等。</p><p>本章将主要内容：</p><ul><li>Packages：Cargo 提供的功能，帮助我们构建、测试和分享创建的 crates；</li><li>Crates：模块树用以生成库或可执行文件（ A tree of modules that produces a library or executable）；</li><li>Modules and use: Let you control the organization, scope, and privacy of paths；</li><li>Paths：命名项目的方式（如 struct、函数、module等）。</li></ul><h2 id="Packages-and-Crates"><a href="#Packages-and-Crates" class="headerlink" title="Packages and Crates"></a>Packages and Crates</h2><p>在模块系统中，首先学习 packages 和 crates。</p><p>crate 是一个二进制或者库（library）。crate root 是一个源文件，rust编译它并构成 crate 的 root module。</p><p>package 由一个或者多个 crate 组成并提供一系列功能，它包含一个 Cargo.toml 文件，以表示如何构建这些 crates。一个 package 必须包含 0 个或者 1 个 library crate，不能多于 1 个；同时可以包含任意数量的 binary crates，但是一个 package 中包含的 library crate 和 binary crate 的数量必须大于等于 1。</p><p>当我们使用 cargo 创建一个新的 rust 项目后，cargo 默认为我们创建了如下文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo new project &amp;&amp; <span class="built_in">cd</span> project</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree</span></span><br><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br><span class="line"></span><br><span class="line">1 directory, 2 files</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat Cargo.toml</span></span><br><span class="line">[package]</span><br><span class="line">name = &quot;show&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">authors = [&quot;vhdsih &lt;vhdsih@hotmail.com&gt;&quot;]</span><br><span class="line">edition = &quot;2018&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><p>此时我们新建的 project 是一个 package，src/main.rc 是 binary crate 的 root，若存在 src/lib.rs 则其为 library crate 的 root，一个 package 有多个 binary crates，并把它们放在 src/bin 下，此时每个文件是一个单独的 binary crate。</p><p>src/main.rs 和 src/lib.rs 可以理解为此 package 的编译入口，并将其传给 rustc，二者可以同时存在，main.rs 将生成二进制可运行的文件，lib.rs 将可被其他项目引用。仔细观察 Cargo.toml 可以发现并没有明确指明这两个文件作为 root，这是因为这是默认指定的特性。</p><p>每个 crate 内部的方法独属于该 crate 的命名空间，因此，不同的 crate 可以定义相同的名字而不会发生冲突，但是相同的 crate 不能定义相同的名字，例如 rand 这个 crate 中的 Rng，我们可以在自己的 main.rs 中定义 struct Rng，同时使用 rand::Rng 来使用 rand crate 中的 Rng。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>我们可以通过 modules 在一个 crate 中组织代码以达到更好的可读性和更高的易用性，同时，module 也为 crate 提供了访问权限控制：允许某些变量和方法公用或者私有。</p><p>使用 cargo 创建一个 library：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo new --lib restaurant</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> restaurant</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .</span></span><br><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── lib.rs</span><br><span class="line"></span><br><span class="line">1 directory, 2 files</span><br></pre></td></tr></table></figure><p>可以将 lib.rs 中的代码更改为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">serve_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 mod 关键字定义 module，而且在一个 module 中可以定义其他 module，此外，module 中还可以定义 struct，enum，constants，traits，函数等。</p><p>src/msin.rs 和 src/lib.rs 是 crate root，其内的 module 组成了 module tree 的根部，如上所示的 modules，其组成如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure><p>为了使用在 module tree 中的某个 module，该如何进行引用？</p><h2 id="引用模块树中某个对象的路径"><a href="#引用模块树中某个对象的路径" class="headerlink" title="引用模块树中某个对象的路径"></a>引用模块树中某个对象的路径</h2><p>类似于文件系统，rust 提供的 module 系统也提供了两种引用方式：</p><ul><li>从 crate root 开始的绝对引用：使用crate 的名字或者 crate 关键字；</li><li>从当前 module 的相对引用，使用 self、super 或者当前模块的 id。</li></ul><p>模块的路径使用 “::” 进行连接，下面，简单地使用这两种方法来进行模块方法的调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Absolute path</span></span><br><span class="line">    crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line">    <span class="comment">// Relative path</span></span><br><span class="line">    front_of_house::hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处，eat_at_restaurant 作为 module 的公共 api 暴露给使用者，故使用 pub 标记，后面将详细介绍。注意两种路径引用的方法：当使用绝对路径引用时，由于 eat_at_restaurant 方法和 front_of_house 在相同的 crate 中，因此，绝对路径的根可以使用 crate 关键字，在 crate 关键字后，按序索引到目标函数；相对路径引用则以 module 名作为开始，直至索引到目标函数。</p><p>二者的选择依据需求，但是绝对路径引用在移动代码后，不需要更改引用路径。</p><p>在试图编译上述代码时，将无法通过编译，尽管引用路径是正确的，但是，还存在所有权问题。使用 module 可以实现对代码细节的封装，并决定某些 api 可以暴露给外面。rust 默认所有的 module、function、struct、enum 等，都是私有的，即不加指明，不能使用，此时，父模块不能直接使用子模块的内容，但是子模块可以使用父模块的内容，因为子模块的封装向其外部隐藏了实现的细节，而同时可以看到声明该子模块的上下文。</p><p>为了给外部提供可用的接口，需要使用 pub 关键字指明其共有属性：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要同时指明 hosting 和 add_to_waitlist 为 pub。仍需要注意的是，由于 front_of_house 和 eat_at_restaurant 定义在同一个 crate 下，因此，即使 front_of_house 没有 pub 标记，其仍然对 eat_at_restaurant 可见，但是对于此 module 包含的内容，需要明确权限决定是否暴露给外部使用。</p><p>对于相对路径引用，还可以使用 super 关键字，类似于文件系统中的 “..”，其指向所在路径的上一级。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">server_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fix_incorrect_order</span></span>() &#123;</span><br><span class="line">        cook_order();</span><br><span class="line">        super::server_order();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cook_order</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 fix_incorrect_order 是 module back_of_house 的函数，因此，在该函数内部可以直接引用该 module 的函数 cook_order，同时，通过 super 关键字将路径指向所在 module 的父路径，从而获得函数 server_order。从这一点来讲，若能够从始至终保证 super 所引用的对象和发生的引用位置相对不变，可以使用 super。</p><p>除此以外，在 module 中设计 struct、enum 等对象时，也需要有所有权的考虑。对于 struct，除了在类型关键字前使用 pub 表示该对象是可访问之外，其内部元素默认是私有的，除非使用 pub 来标识可访问：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Breakfast</span></span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="built_in">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="built_in">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Breakfast &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">summer</span></span>(toast: &amp;<span class="built_in">str</span>) -&gt; Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="built_in">String</span>::from(toast),</span><br><span class="line">                seasonal_fruit: <span class="built_in">String</span>::from(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Order a breakfast in the summer with Rye toast</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> meal = back_of_house::Breakfast::summer(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    <span class="comment">// Change our mind about what bread we&#x27;d like</span></span><br><span class="line">    meal.toast = <span class="built_in">String</span>::from(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please&quot;</span>, meal.toast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The next line won&#x27;t compile if we uncomment it; we&#x27;re not allowed</span></span><br><span class="line">    <span class="comment">// to see or modify the seasonal fruit that comes with the meal</span></span><br><span class="line">    <span class="comment">// meal.seasonal_fruit = String::from(&quot;blueberries&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 enum，只要在 关键字前标记 pub，则其内容均可访问，不过 enum 默认情况下也是可访问的，而非私有。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Appetizer</span></span> &#123;</span><br><span class="line">        Soup,</span><br><span class="line">        Salad,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> order1 = back_of_house::Appetizer::Soup;</span><br><span class="line">    <span class="keyword">let</span> order2 = back_of_house::Appetizer::Salad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过-use-将路径引入作用域"><a href="#通过-use-将路径引入作用域" class="headerlink" title="通过 use 将路径引入作用域"></a>通过 use 将路径引入作用域</h2><p>以上，我们学习通过绝对路径或者相对路径以使用对应目标，但是过于繁琐，可以通过 use 关键字将直接将目标路径引入当前作用域中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"><span class="comment">// use self::front_of_house::hosting;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 use，将 mod hosting 引入到 crate root，因此，hosting 将成为当前作用域的一个合法的名字。可以直接使用 hosting::xxxx 来引用对应的目标了。习惯上，对于 mod 中的函数，引入层级将到达其 mod 层，以明确该函数定义在其他模块中。use 可以使用相对路径或绝对路径。</p><p>除此以外，use 也为模块引入提供了别名功能：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult</span><br></pre></td></tr></table></figure><p>使用 pub use 可以实现名字的 Re-exporting（待研究，不懂啥意思，大概是虽然此处未实现该接口，但是可以通过 pub use 将该接口暴露到此位置，作为此处的接口。。。）</p><p>以上，是引入自己实现的模块，若需要使用外部模块，则需要修改 Cargo.toml 文件，加入待引入的模块和版本号：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.3&quot;</span></span><br></pre></td></tr></table></figure><p>此时，Cargo 将从 crates.io 下载所有的依赖，并在该项目中可以使用 rand 模块。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="number">1</span>..<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，引入标准库 std 不需要修改 toml 文件，但需要显式 use 来导入需要使用的对象名到当前作用域中。</p><p>若需要引入相同模块下不同的子模块，以下是更简便的方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br></pre></td></tr></table></figure><p>又如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure><p>若需要引入某个模块下的所有内容，使用 * ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure><h2 id="将模块拆分到不同文件"><a href="#将模块拆分到不同文件" class="headerlink" title="将模块拆分到不同文件"></a>将模块拆分到不同文件</h2><p>随着代码量的增大，在一个文件中书写并不是一个好的代码组织方式。</p><p>当将代码拆分到多个文件时，遵循如下原则：</p><ol><li>在使用其他文件中代码的文件的开始使用 “mod mod_name;” 告诉编译器导入这份代码；</li><li>代码可以声明在一个文件中，但是定义在另一个位置。</li></ol><p>例如，使用模块的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/front_of_house</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个模块代码可以声明与定义分离：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/front_of_house.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/front_of_house/hosting.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>此时，调用仍然成功。</p><h1 id="八、常见的集合"><a href="#八、常见的集合" class="headerlink" title="八、常见的集合"></a>八、常见的集合</h1><p>rust 的标准库中提供了一些有用的数据结构（collections），相比于前几章学习过的整型、浮点型等数据类型，这些 collections 具备表示更多数据的能力，同时，和内建的数组、元组不同，这些 collections 构建在堆上，因此无需在编译期指明其容量，还能在运行时动态改变其容量。对于这些不同的数据结构，根据其原理不同，有着不同的使用代价。</p><p>本节讨论的内容如下：</p><ol><li>使用 vector 在连续空间中存储数据；</li><li>使用 string 在连续空间中存储字符；</li><li>使用 hash map 存储 key、value 对。</li></ol><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector 用于存储相同类型的数据的集合，存储于内存的连续空间中。Vector 无需显式引入，在 rust 中使用 Vec&lt;T&gt; 表示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的，容纳 i32 类型数据的 vector</span></span><br><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br></pre></td></tr></table></figure><p>上述定义明确指明了 Vector 存储的数据类型为 i32，若定义时指明了其容纳的数据，rust 可以推断出其数据类型，当尝试创建有一些初始值的 vector 时，可以使用 rust 提供的宏 “vec!”，使用这个宏将创建一个复合所提供数据类型的 Vector：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Vec&lt;i32&gt;</span></span><br><span class="line"><span class="keyword">let</span> u = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>可以使用 push 向 Vector 中添加元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::new();</span><br><span class="line">v.push(<span class="number">1</span>);</span><br><span class="line">v.push(<span class="number">2</span>);</span><br><span class="line">v.push(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>使用 pope 弹出 Vector 中的最后一个元素，注意可变性：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">v.pop();</span><br></pre></td></tr></table></figure><p>需要注意的是，若需要改变 Vector，必须使用 mut 关键字指明其可变性！此外，创建可变 Vector 时，若没有指明其数据类型，则在 push 时推断，后续 push 的数据类型必须相同，且不存在隐式转换（如 float 转 int)</p><p>类似于其他数据结构，当 Vector 离开其作用域，将被丢弃销毁，其容纳的数据同样被销毁：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="comment">// do stuff with v</span></span><br><span class="line">&#125; <span class="comment">// &lt;- v goes out of scope and is freed here</span></span><br></pre></td></tr></table></figure><p>对于读取或引用 Vector 中的数据，有两种方法，其一使用索引访问，其二使用 get 方法，区别在于前者在越界时将导致 panic，而后者越界后将返回 None，因为 get 方法返回的是 Option&lt;T&gt; 类型，因此可以使用 match 来进行进一步的处理：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点需要注意，在引用 vector 元素后，不允许 push，这一点和前面提到的引用和借用的概念相关。当对 Vector 执行 push 操作后，可能会导致因空间不足而重新分配空间，此时之前获得的引用将指向一块被销毁的内存，这一点是不被允许的，有 Cpp 编程经验的人应该不会对此陌生：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = &amp;v[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">v.push(<span class="number">6</span>); <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The first element is: &#123;&#125;&quot;</span>, first);</span><br></pre></td></tr></table></figure><p>通过 for 循环可以遍历整个 Vector：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，以上使用的引用皆为不可变引用，因此不能更改 Vector 中的数据值，若希望对 Vector 已存在的数据进行更改，请使用可变引用，此时，使用解引用符号 “*” 对引用指向的数据重新赋值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> idx = &amp;<span class="keyword">mut</span> v[<span class="number">1</span>];</span><br><span class="line">*idx = <span class="number">10000</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;v is &#123;:#?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure><p>这里还有一个小技巧，即：如果希望在 Vector 中存储更多样的数据该怎么办？前文已经强调过，Vector 只能存储相同类型的数据，不过结合 rust 中 enum 类型，可以实现这一需求：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>),</span><br><span class="line">    Float(<span class="built_in">f64</span>),</span><br><span class="line">    Text(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>rust 语言底层提供了 str 作为 string 的类型表示，与之相关的是对 string 数据的借用，即 &amp;str。而 String 并不是 rust 语言的核心所提供的，其存在于标准库中，其提供了可变的、可动态增长的利用 utf8 编码的 string 类型。rust 标准库中另外提供了其他类型的 String 对象，比如 OsString、OsStr，CString，CStr 等。</p><p>类似于 Vec&lt;T&gt;，使用 new 来创建一个空的 String：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br></pre></td></tr></table></figure><p>使用 to_string() 将 str 数据转换为 String：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s = data.to_string();</span><br></pre></td></tr></table></figure><p>使用 String::from(VALUE) 来定义并初始化一个 String：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>值得注意的是，String 编码为 utf-8，故可以使用 String 来定义更多样的字符串数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">&quot;السلام عليكم&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">&quot;Dobrý den&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">&quot;שָׁלוֹם&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">&quot;नमस्ते&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">&quot;こんにちは&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">&quot;안녕하세요&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">&quot;Olá&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">&quot;Здравствуйте&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">&quot;Hola&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用 push_str 来追加字符串：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">s.push_str(<span class="string">&quot;new string&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用 push 方法追加单个字符</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hell&quot;</span>);</span><br><span class="line">s.push(<span class="string">&#x27;o&#x27;</span>)</span><br></pre></td></tr></table></figure><p>String 可以拼接：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = s1 + &amp;s2; <span class="comment">// note s1 has been moved here and can no longer be used</span></span><br></pre></td></tr></table></figure><p>执行拼接后，s1 将被移动到 s3，原有 s1 将无效，’+’ 操作符会调用 add 方法，此时，add 方法的可以形象地表示如下（当然，只用来举例，并不确切，在标准库中，add 将使用泛型来定义）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, s: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line"><span class="comment">// more code here</span></span><br></pre></td></tr></table></figure><p>在执行 s1 拼接 s2 为 s3 的过程，s1 调用 add，使用参数 s2 的引用，返回一个 String，因此执行拼接，第二个字符串必须为引用类型，两个 String 类型无法执行加操作，编译器可以将 &amp;String 转换为 &amp;str。在执行过程中，add 不接管 s2 的生命周期，故 s2 在执行 add 后继续可用。</p><p>拼接时，String 可以直接与 str 字面值拼接，也可以执行多次拼接，但是，除了第一个 String 外，其他需为 &amp;String：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s = s1 + <span class="string">&quot;-&quot;</span> + &amp;s2 + <span class="string">&quot;-&quot;</span> + &amp;s3;</span><br></pre></td></tr></table></figure><p>在其他语言中，可以使用索引来访问字符串中的任意一个字符，然而，在 rust 中试图这样访问将不能通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个错误的例子</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> c = s[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>Rust 的 String 不提供索引操作。为了解释这个问题，首先需要了解 String 的存储模式。String 基于 Vec&lt;u8&gt;，用以存储 utf-8 字符集合。若简单地存储一些 ascii 字符串：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">&quot;halo&quot;</span>);</span><br></pre></td></tr></table></figure><p>则 hello 占用 4 字节的内存，但是对于非ascii 字符集来说，情况就有些复杂，如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br></pre></td></tr></table></figure><p>此时，hello 占用的字符并不能明显的看出了，此时，若 rust 对字符串的索引是合法的，那么 &amp;hello[0] 的值是？答案是 ‘3’，但在utf8编码来讲，其表示为 208，不过 208 并不是用户需要看到的表示结果，故为了避免返回不期望的结果而导致 Bug，rust 在编译期不会允许带有这种特性的代码编译通过。</p><p>使用 utf-8 编码字符串，这里有 3 中方法，例如  “नमस्ते”，使用 u8 表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,</span><br><span class="line">224, 165, 135]</span><br></pre></td></tr></table></figure><p>若使用 unicode：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;न&#x27;, &#x27;म&#x27;, &#x27;स&#x27;, &#x27;्&#x27;, &#x27;त&#x27;, &#x27;े&#x27;]</span><br></pre></td></tr></table></figure><p>若使用 grapheme clusters：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]</span><br></pre></td></tr></table></figure><p>使用 &amp;string[begin..end] 获得 String 的切片，但是若引用非 ascii 编码的切片会出现问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的代码</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>那么如何访问字符串中的字符？使用 chars() 将 String 拆分为 unicode 字符，使用 bytes() 将 String 拆分为 u8</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.chars() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.bytes() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hash-Map"><a href="#Hash-Map" class="headerlink" title="Hash Map"></a>Hash Map</h2><p> Waiting for update later</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;阅读  &lt;a href=&quot;https://doc.rust-lang.org/book/&quot;&gt;rust online book&lt;/a&gt; 时记录的笔记，辅以备忘。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="rust" scheme="https://vhdsih.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>wiredtiger 数据库的介绍和入门</title>
    <link href="https://vhdsih.github.io/2021/06/03/wiredtiger/"/>
    <id>https://vhdsih.github.io/2021/06/03/wiredtiger/</id>
    <published>2021-06-03T10:50:11.000Z</published>
    <updated>2023-10-25T14:47:14.729Z</updated>
    
    <content type="html"><![CDATA[<p>Wiredtiger数据库的简单整理和总结。</p><span id="more"></span><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>文档：<a href="http://source.wiredtiger.com/">link</a></p><p>GitHub：<a href="https://github.com/wiredtiger/wiredtiger">link</a></p><p>公众号文章：MongoDB中文社区对wiredtiger的一些介绍。<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTA2NTM0Ng==&mid=2247486377&idx=1&sn=307b14fd7ae11778037ea26b0c3f1c64&chksm=fd4c0444ca3b8d52cab16ca5867e8d2ca53be691816ae02d9b4c4674a9a2a9366eab8dcd30d3&scene=21#wechat_redirect">link</a></p><p>wiredtiger演讲， 2015：<a href="https://www.mongodb.com/presentations/a-technical-introduction-to-wiredtiger">link</a></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a><a href="http://source.wiredtiger.com/3.2.1/build-posix.html">编译</a></h3><p>几个注意事项：</p><ol><li>若需使用内置压缩引擎，需在编译时开启。内置的引擎包括lz4、snappy、zlib、zstd等，此外还可通过<strong>WT_COMPRESSOR</strong>来自定义压缩引擎（<a href="http://source.wiredtiger.com/3.2.1/compression.html">link</a>）。</li><li>使用**-–with-builtins=xxx**可以将压缩引擎打包到wiredtiger中，可避免运行时加载额外的库文件。</li><li>若需使用 python 或 java api，需在编译期开启。</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>数据库文件介绍</p><p>wiredtiger数据库名称依赖于 wiredtiger_open 或环境变量 WIREDTIGER_HOME，数据库以文件夹为单位组织，其内包含多个文件。优先使用wiredtiger_open指定，若环境变量未指定，则使用当前文件夹。文件夹内各个文件的基本介绍如下：</p><table><thead><tr><th align="center">文件名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">table_name.wt</td><td align="center">用于B树的表数据存储，一个表一个文件</td></tr><tr><td align="center">table_name.lsm</td><td align="center">用于lsm树的表数据存储，一个表一个文件</td></tr><tr><td align="center">index_name.wti</td><td align="center">用于B树的索引数据存储，一个索引一个文件</td></tr><tr><td align="center">WiredTiger.lock</td><td align="center">运行实例锁，防止多个进程同时连接一个WiredTiger实例</td></tr><tr><td align="center">WiredTiger</td><td align="center">内含当前数据库的WiredTiger版本号和编译时间</td></tr><tr><td align="center">WiredTiger.wt</td><td align="center">存储的是所有集合（包含系统自带的集合）相关数据文件和索引文件的checkpoint信息</td></tr><tr><td align="center">WiredTigerLAS.wt</td><td align="center">内存里面lookaside table的持久化的数据,当对一个page进行reconcile时，如果系统中还有之前的读操作正在访问此page上的修改数据，则会将这些数据保存到lookaside table；当page再被读时，可以利用此lookaside table中的数据重新构建内存page</td></tr><tr><td align="center">WiredTiger.turtle</td><td align="center">存储的是WiredTiger.wt这个文件的checkpoint数据信息。相当于对保存有所有集合checkpoints信息的文件WiredTiger.wt又进行了一次checkpoint</td></tr><tr><td align="center">WiredTigerLog.n、WiredTigerPreplog.n</td><td align="center">n为整数，左端以0补齐，日志文件</td></tr></tbody></table></li><li><p>主要的操作对象</p><ul><li><p><a href="http://source.wiredtiger.com/3.2.1/struct_w_t___c_o_n_n_e_c_t_i_o_n.html#af535c517df851eeac8ebf3594d40b545">connection</a>：一个数据库的连接，connection中包含的所有方法都是线程安全的。程序停止前需要显示关闭connection以保证数据落盘，关闭connection同时将释放在其上打开的所有资源，若未关闭且未开启日志恢复功能，可能造成数据丢失。</p></li><li><p><a href="http://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html">session</a>：数据库操作的上下文，在connection之上打开，每个线程打开一个session用于数据库操作，使用session-&gt;close关闭；</p></li><li><p><a href="http://source.wiredtiger.com/3.2.1/struct_w_t___c_u_r_s_o_r.html">cursor</a>：数据库数据之上的游标，对应一个数据位置，可通过访问对应位置的key和value，可使用search、search_near将游标放置到指定位置，可通过对cursor设置key或key和value来执行删除或插入、更新等操作，使用cursor-&gt;close关闭并释放资源；</p></li></ul></li><li><p>wiredtiger中的表和索引</p><p>wiredtiger是key-value数据库，但支持更复杂的表结构，但是复杂的表结构同样是基于key-value组织的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open connection first</span></span><br><span class="line"><span class="comment">// then open a session on connection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create table</span></span><br><span class="line">session.create(<span class="string">&quot;table:poptable&quot;</span>,</span><br><span class="line">               <span class="string">&quot;key_format=r,value_format=5sHQ,&quot;</span></span><br><span class="line">               <span class="string">&quot;columns=(id,country,year,population),colgroups=(main,population)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create colgroups</span></span><br><span class="line">session.create(<span class="string">&quot;colgroup:poptable:main&quot;</span>, <span class="string">&quot;columns=(country,year,population)&quot;</span>);</span><br><span class="line">session.create(<span class="string">&quot;colgroup:poptable:population&quot;</span>, <span class="string">&quot;columns=(population)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create index</span></span><br><span class="line">session.create(<span class="string">&quot;index:poptable:country&quot;</span>, <span class="string">&quot;columns=(country)&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><p>数据类型：wiredtiger细分了多种数据类型，包括int8_t(b)、uint8_t(B), int16_t(h), …, int64_t(q), uint64_t(Q), char[] with fixed length(s), char[] with ‘\0’ terminated(S), raw byte array WT_ITEM*(u)等。同类型数据保证数据能够按自然顺序增序排序。使用WT_ITEM可以实现二进制数据读写。</p></li><li><p>创建表的过程：需要指明key类型，value类型，columns按照key-value的顺序依次指明列名。使用colgroups可以将一部分数据聚集在一个文件中存储，在某些场景下可以单独载入该文件以提高效率。表数据将以key有序排列。</p></li><li><p>索引：wiredtiger将自动在插入和删除过程中维护索引项目。但是索引是只读的，无法对其进行更新和删改。可以在创建过程中指定索引不可变，此后主表将不会在增删改过程中维护该索引。</p><p>索引将按照其各个项目依次有序排列，对于整数类型，其以自然顺序升序有序，字符串类型按字典序升序有序。查询过程可使用投影访问全表的全部或部分数据。</p></li></ul></li><li><p>增删查改</p><p>wiredtiger 的增删查改操作基于 <a href="http://source.wiredtiger.com/3.2.1/cursors.html">cursor</a>。cursor保存了对应位置的数据资源，且cursor占用将导致对应页面无法驱逐。可通过<a href="http://source.wiredtiger.com/3.2.1/struct_w_t___c_u_r_s_o_r.html#afc1b42c22c9c85e1ba08ce3b34437565">WT_CURSOR::reset</a> 重置游标并释放资源。</p><ul><li><p>raw模式数据</p><p>于<a href="http://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d">WT_SESSION::open_cursor</a> 指明raw模式。</p><p>通过<a href="http://source.wiredtiger.com/3.2.1/struct_w_t___c_u_r_s_o_r.html#af19f6f9d9c7fc248ab38879032620b2f">WT_CURSOR::get_key</a>、<a href="http://source.wiredtiger.com/3.2.1/struct_w_t___c_u_r_s_o_r.html#af85364a5af50b95bbc46c82e72f75c01">WT_CURSOR::get_value</a>、 <a href="http://source.wiredtiger.com/3.2.1/struct_w_t___c_u_r_s_o_r.html#ad1088d719df40babc1f57d086691ebdc">WT_CURSOR::set_key</a>、<a href="http://source.wiredtiger.com/3.2.1/struct_w_t___c_u_r_s_o_r.html#a27f7cbd0cd3e561f6a145704813ad64c">WT_CURSOR::set_value</a> 读写单个WT_ITEM类型的key和value。</p><p>使用<a href="http://source.wiredtiger.com/3.2.1/struct_w_t___e_x_t_e_n_s_i_o_n___a_p_i.html#a353dd240d0f7b32910d1bb97c0762ee8">WT_EXTENSION_API::struct_pack</a> 以及wiredtiger_struct_pack、wiredtiger_struct_unpack对raw item解析。</p></li><li><p>普通数据，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   cursor-&gt;set_key(cursor, key1, key2, ..., keym);</span><br><span class="line">cursor-&gt;get_key(cursor, &amp;key1, &amp;ke2, ..., &amp;keym);</span><br><span class="line">   cursor-&gt;set_value(cursor, val1, val2, ..., valn);</span><br><span class="line">cursor-&gt;get_value(cursor, &amp;val1, &amp;val2, ..., valn);</span><br></pre></td></tr></table></figure></li><li><p>更新、插入、删除、查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cursor-&gt;insert(cursor)；<span class="comment">// 若设置overwrite=false，无法insert已有数据；</span></span><br><span class="line">cursor-&gt;update(cursor); <span class="comment">// 若设置overwrite=false，需使用update更新；</span></span><br><span class="line">cursor-&gt;remove(cursor);</span><br><span class="line">cursor-&gt;search(cursor); <span class="comment">// 精确查找</span></span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line">cursor-&gt;search_near(cursor, &amp;pos); <span class="comment">// 找到与目标最邻近的cursor位置，pos以确定当前与目标的相对位置</span></span><br></pre></td></tr></table></figure></li><li><p>顺序遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重置cursor位置</span></span><br><span class="line">cursor-&gt;reset(cursor);</span><br><span class="line"><span class="keyword">while</span> (cursor-&gt;next(cursor) == <span class="number">0</span>) &#123; <span class="comment">// reset cursor后，第一次调用next将使cursor定位到第一条数据的位置，直到没有数据返回非0</span></span><br><span class="line">    <span class="comment">// read data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置cursor位置</span></span><br><span class="line">cursor-&gt;reset(cursor);</span><br><span class="line"><span class="keyword">while</span> (cursor-&gt;prev(cursor) == <span class="number">0</span>) &#123; <span class="comment">// reset cursor后，第一次调用prev将使cursor定位到最后一条数据的位置，直到没有数据返回非0</span></span><br><span class="line">    <span class="comment">// read data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>btree和lsm-tree</p><p>wiredtiger同时支持btree和lsm-tree两种数据结构。可在创建表、索引的过程中指定其使用btree或lsm-tree。对btree，当cache不足，性能将显著下降。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a table with lsm tree</span></span><br><span class="line"><span class="comment">// you can create index as the same way</span></span><br><span class="line">session-&gt;create(session, <span class="string">&quot;table:bucket&quot;</span>, <span class="string">&quot;type=lsm,key_format=S,value_format=S&quot;</span>);</span><br></pre></td></tr></table></figure><p>实际使用中，每个表在数据库文件夹中会有大量的小文件，而非btree那样一个文件。</p></li><li><p>数据压缩</p><p>wiredtiger内置支持一些数据压缩引擎，但需要在编译过程中将其编译在内，包括lz4，snappy，zlib，zstd。<a href="http://source.wiredtiger.com/3.2.1/compression.html">link</a></p><p>lz4的使用方法如下，其他类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若独立编译了libwiredtiger_lz4.so，需要在wired_open时加载该插件</span></span><br><span class="line">wiredtiger_open(home, <span class="literal">NULL</span>,</span><br><span class="line">      <span class="string">&quot;create,&quot;</span></span><br><span class="line">      <span class="string">&quot;extensions=[/path/to/libwiredtiger_lz4.so]&quot;</span>,</span><br><span class="line">      &amp;conn);</span><br><span class="line"><span class="comment">// 在创建表、索引等对象时，指定块压缩引擎</span></span><br><span class="line">session-&gt;create(</span><br><span class="line">      session, <span class="string">&quot;table:mytable&quot;</span>, <span class="string">&quot;block_compressor=lz4,key_format=S,value_format=S&quot;</span>);</span><br></pre></td></tr></table></figure><p>此外，还可以自定义压缩引擎。</p></li><li><p>事务</p><p>MVCC，乐观并发，轻量级。支持ACID：最大程度的隔离支持快照隔离、通过日志和检查点执行事务更新、对于未提交事务必维持在内存中，直到事务提交才写到日志中。</p><p>事务接口位于 <a href="http://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html">WT_SESSION</a>。</p><p>通过<a href="http://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html#a7e26b16b26b5870498752322fad790bf">WT_SESSION::begin_transaction</a> 开启事务，随后在该session上发生的操作将属于事务的一部分。</p><p>通过<a href="http://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html#a712226eca5ade5bd123026c624468fa2">WT_SESSION::commit_transaction</a>提交事务。</p><p>通过<a href="http://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html#ab45f521464ad9e54d9b15efc2ffe20a1">WT_SESSION::rollback_transaction</a>回滚事务。</p></li><li><p><a href="http://source.wiredtiger.com/3.2.1/error_handling.html">错误处理</a></p><p>wiredtiger api 通过返回一个int值来标识操作的正确性，若返回值为0，标识操作正确执行，否则将返回一系列非零的错误码标识操作错误类型。</p><p>使用 <a href="http://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html#abe03ccb716e097ed1bb4d42eb733c1f9">WT_SESSION::strerror</a> 和 <a href="http://source.wiredtiger.com/3.2.1/group__wt.html#gae8bf720ddb4a7a7390b70424594c40fd">wiredtiger_strerror</a> 以翻译错误信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret = error_code_of_wiredtiger_return_value;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error message is %s\n&quot;</span>, wiredtiger_strerror(ret));</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>wiredtiger使用配置字符串进行配置，配置对象包括：connection、session、cursor、table、index等，在打开或创建新的对象的同时传入配置字符串，或使用api在运行时使用配置项。</p><ol><li><p>对connection使用配置，在wiredtiger_open接口中传入配置字符串，或使用reconfigure重新配置，详细配置内容见<a href="http://source.wiredtiger.com/3.2.1/group__wt.html#gacbe8d118f978f5bfc8ccb4c77c9e8813">link</a>，一个常见的配置如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// configuration example</span></span><br><span class="line">wiredtiger_open(</span><br><span class="line">      db_home_path, <span class="literal">NULL</span>, <span class="string">&quot;create,cache_size=5GB,log=(enabled,recover=on),statistics=(all)&quot;</span>, &amp;conn);</span><br></pre></td></tr></table></figure><p>下面简要介绍一些常用的：</p><table><thead><tr><th align="center">配置</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">cache_size=1GB</td><td align="center">最大堆内存缓存，用于存放wiredtiger树节点等内容，范围[1M, 10TB]，默认100M</td></tr><tr><td align="center">checkpoint=(log_size=0, wait=0)</td><td align="center">检查点周期配置</td></tr><tr><td align="center">create</td><td align="center">若数据库不存在，则创建该数据库，默认为false</td></tr><tr><td align="center">eviction=(threads_max=8,threads_min=1)</td><td align="center">页面驱逐线程数量，取决于驱逐任务负载</td></tr><tr><td align="center">eviction_target</td><td align="center">缓存中数据量达到指定比例或数值后将触发页面驱逐</td></tr><tr><td align="center">eviction_trigger=95</td><td align="center">缓存中数据量达到指定比例或数值后将触发应用线程同时参与页面驱逐任务</td></tr><tr><td align="center">extensions</td><td align="center">wiredtiger插件，如libwiredtiger_lz4.so位置，当使用lz4时可能需要指定</td></tr><tr><td align="center">io_capacity=(total=0)</td><td align="center">控制每秒钟能够读写数据量的上限，若超过将休眠，0则不限制</td></tr><tr><td align="center">log = (archive=true, compressor=lz4, enabled=true, file_max=100M, path=./logs, prealloc=true, recover=true, zero_fill=false)</td><td align="center">日志配置，包括自动归档不需要的日志，日志压缩方法，是否启用日志，单个日志文件大小，日志存储路径，是否预分配日志空间，是否在异常关闭等情况下进行数据恢复，想日志写0等内容</td></tr><tr><td align="center">readonly</td><td align="center">只读</td></tr><tr><td align="center">statistics</td><td align="center">维护统计数据，影响性能</td></tr></tbody></table></li><li><p>对session使用配置</p><p>在connection中使用open_session打开并配置session：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn-&gt;open_session(conn, <span class="literal">NULL</span> <span class="comment">/* event handler */</span>, <span class="literal">NULL</span> <span class="comment">/* config str */</span>, &amp;session);</span><br></pre></td></tr></table></figure><p>session包含较少的<a href="http://source.wiredtiger.com/3.2.1/struct_w_t___c_o_n_n_e_c_t_i_o_n.html#adad5965cd4a60f65b5ac01f7ca6d1fc0">配置选项</a></p><table><thead><tr><th align="center">选项</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">cache_cursors</td><td align="center">允许cursor重用，默认允许</td></tr><tr><td align="center">ignore_cache_size</td><td align="center">忽略缓存大小，若缓存已满不会阻塞当前会话的操作，默认禁止</td></tr><tr><td align="center">isolation</td><td align="center">会话隔离级别，</td></tr></tbody></table></li><li><p>对cursor使用配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session-&gt;open_cursor(session, <span class="string">&quot;table:mytable&quot;</span> <span class="comment">/* uri of table or index */</span>, </span><br><span class="line">                     <span class="literal">NULL</span> <span class="comment">/* cursor to dup */</span>,</span><br><span class="line">                     <span class="literal">NULL</span> <span class="comment">/* config string */</span>, &amp;cursor);</span><br></pre></td></tr></table></figure><p>cursor类型：</p><table><thead><tr><th align="center">uri</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">“table:table_name[(projection)]”</td><td align="center">表，可对表中的部分数据进行投影并访问</td></tr><tr><td align="center">“index:table_name:index_name[(projection)]”</td><td align="center">某个表对应的索引，可对表的部分数据进行投影并访问</td></tr><tr><td align="center">“colgroup:table_name:colgroup_name”</td><td align="center">列组游标，可以对列组数据访问</td></tr><tr><td align="center">“join:table_name[(projection)]”</td><td align="center">join游标</td></tr></tbody></table><p><a href="http://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d">配置内容</a></p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">bulk</td><td align="center">批量加载，但只适用于新创建的对象，必须顺序加载数据，默认false</td></tr><tr><td align="center">next_random</td><td align="center">调用cursor-&gt;next返回一个伪随机记录，默认false（不开启情况为key有序）</td></tr><tr><td align="center">overwrite</td><td align="center">可重写已有记录，默认true，此时可用insert覆写，若为false，则无法insert已有数据，只可调用update</td></tr><tr><td align="center">readonly</td><td align="center">设置能查询</td></tr><tr><td align="center">statistics</td><td align="center">指定收集数据库统计信息，</td></tr></tbody></table></li><li><p>对table或index使用配置</p><p>于session上调用create创建table或index，创建对象的过程非事务性，无法保证ACID：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session-&gt;create(session, <span class="string">&quot;table:mytable&quot;</span> <span class="comment">/* name of table or index */</span>,</span><br><span class="line">                <span class="string">&quot;key_format=S,value_format=S&quot;</span> <span class="comment">/* config string */</span>);</span><br></pre></td></tr></table></figure><p>包含很多<a href="http://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb">配置选项</a>，一些常用的如下：</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">block_compressor</td><td align="center">压缩引擎</td></tr><tr><td align="center">colgroups</td><td align="center">列组，保存在一个单独的文件中</td></tr><tr><td align="center">columns</td><td align="center">列的名称列表</td></tr><tr><td align="center">key_format</td><td align="center">key的格式，字母表示</td></tr><tr><td align="center">type</td><td align="center">lsm配置使用LSM</td></tr><tr><td align="center">value_format</td><td align="center">value的格式</td></tr></tbody></table><p>此外还包括对B树内部节点、叶子节点、页大小，哈夫曼编码、前缀压缩、lsm相关的配置。</p></li></ol><h3 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h3><ol><li><p>统计</p><p>wiredtiger在运行过程中包含大量的统计数据，可以通过统计信息对数据库进行分析、调优。收集统计信息会降低性能应用。<a href="http://source.wiredtiger.com/3.2.1/tune_statistics.html">link</a></p></li><li><p>压缩</p><p>不同阶段可以配置不同的压缩算法。配置压缩可能会改变程序的吞吐量，若对于ssd等I/O速度快的系统，不使用压缩会降低cpu负载从而提高性能，而对于I/O速度慢的系统，配置压缩减小I/O体积可能会提高性能。</p><ul><li><p>key-prefix</p><p>每个page中相同的key前缀只保存一次从而减小对空间的需要。将为操作内存中的btree时带来cpu和内存的额外成本。</p><p>通过 <a href="http://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb">WT_SESSION::create</a> 在创建表或索引时开启前缀压缩。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;key_format=S,value_format=S,prefix_compression=true,prefix_compression_min=7&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>directory</p><p>每一页只保存相同值一次，通过 <a href="http://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb">WT_SESSION::create</a> 在创建表或索引时指定字典最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;key_format=S,value_format=S,dictionary=1000&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>Huffman</p><p>减小压缩单个key/value的体积，额外的cpu代价很高，应考虑是否启用。通过 <a href="http://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb">WT_SESSION::create</a> 在创建表或索引时指定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;key_format=S,value_format=S,huffman_key=english,huffman_value=english&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>Block Compression</p><p>通过块压缩，减小写入磁盘的数据体积。cpu的代价较高，需要考虑是否启用。若启用压缩，对于page size的配置将和实际磁盘的page size不再匹配。</p><p><a href="http://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb">WT_SESSION::create</a> 在创建表或索引时指定压缩引擎，包括snappy，lz4，zlib，zstd等，可能需要zdwiredtiger_open时指定压缩引擎插件位置，这取决于编译方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;key_format=S,value_format=S,block_compressor=snappy&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>bulk-load</p><p>载入大量数据到一个新的数据对象时，使用批量载入会有更高的效率。<a href="http://source.wiredtiger.com/3.2.1/tune_bulk_load.html">link</a></p></li><li><p>cache</p><p>理想情况下应为数据库配置足够的cache空间。可以使用wiredtiger_open配置cache_size，或调用<a href="http://source.wiredtiger.com/3.2.1/struct_w_t___c_o_n_n_e_c_t_i_o_n.html#a579141678af06217b22869cbc604c6d4">WT_CONNECTION::reconfigure</a> 重新进行设置。</p><p>可将对象配置为cache持久化数据，以避免数据被驱逐回收。</p></li><li><p>页面驱逐</p><p>当cache中数据占用接近最大的cache_size，进引发页面驱逐操作，可以使用wiredtiger_open配置或调用<a href="http://source.wiredtiger.com/3.2.1/struct_w_t___c_o_n_n_e_c_t_i_o_n.html#a579141678af06217b22869cbc604c6d4">WT_CONNECTION::reconfigure</a> 重新进行设置对该驱逐操作进行配置。</p><ul><li> eviction_target （默认80%），维持cache的总体使用率，当超过将启动驱逐线程执行页面驱逐。</li><li>eviction_trigger（默认95%），若cache使用率达到该值，将启用应用级线程执行驱逐操作，此时将会有较高的延迟。</li><li>eviction_dirty_target（5%），eviction_dirty_trigger（20%），和上述二者类似，但用于dirty-page。</li><li>可通过eviction来配置驱逐线程的数量，若缓存占用过高导致应用进程参与页面驱逐过程将导致很高的延迟。</li></ul></li><li><p>I/O限制</p><p>通过设置每秒读写数据量的上限来限制I/O带宽。当资源是共享的，如云或虚拟环境中会有帮助。当I/O溢出，引发溢出的线程将会休眠</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wiredtiger_open(home, <span class="literal">NULL</span>, <span class="string">&quot;create,io_capacity=(total=40MB)&quot;</span>, &amp;conn);</span><br></pre></td></tr></table></figure></li><li><p>持久化游标</p><p>经常性打开新的游标是一个代价较大的操作，特别对于表和LSM树，对cursor进行缓存重用将可以提高性能。</p></li><li><p>只读模式</p><p>checkpoint的游标以只读模式打开，读取不占用wiredtiger的cache，而直接使用内存。使用只读模式将减小cache占用以及对cache管理工作的负载，以及从操作系统缓存到应用的内存拷贝。</p></li><li><p>关闭连接</p><p>关闭connection代价高，需要释放大量资源以及数据落盘等，若加快速度，可配置leak_memory=true。</p></li><li><p><strong>Linux transparent huge pages</strong></p><p>linux系统中的<strong>transparent huge pages</strong>会影响wiredtiger的性能。一些linux系统开启了此功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// disable it</span><br><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure></li><li><p>其他详细见文档</p></li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li><p>测试总结</p><ul><li>使用sqlite3数据库时，晚高峰期间由于磁盘IO过高，模块基本停止工作，不能取得的数据，替换为wiredtiger后，工作正常。</li><li>系统load在晚高峰期间明显降低。</li><li>未开启压缩和开启压缩相比，cpu占用提高，但所在磁盘盘持续100%占用时间减少。</li></ul></li><li><p>wiredtiger性能测试工具</p><p>wiredtiger提供了wtperf工具用于性能测试。</p></li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><p>联合索引无法按预期排序问题</p><p>在实现disk-index模块中file_info表部分操作时，遇到使用部分多列联合索引时，某一列的整数类型不能按照预期顺序排序。后改用int64_t。原因不明。</p></li><li><p>重启数据库后一段时间极高cpu占用和系统负载问题</p><p>可能是由异常关闭导致扫描日志恢复数据导致。</p></li><li><p>以不同配置打开相同数据库问题</p><p>对于cache_size等配置，不影响重新打开，对于树类型、表结构等，必须相同。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Wiredtiger数据库的简单整理和总结。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="wiredtiger" scheme="https://vhdsih.github.io/tags/wiredtiger/"/>
    
    <category term="database" scheme="https://vhdsih.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="https://vhdsih.github.io/2021/06/03/new-start/"/>
    <id>https://vhdsih.github.io/2021/06/03/new-start/</id>
    <published>2021-06-03T07:36:14.000Z</published>
    <updated>2023-10-25T14:46:29.541Z</updated>
    
    <content type="html"><![CDATA[<p><img src="new.jpg"></p><span id="more"></span><p>摄于雁西湖木栈道。山上风景很好，奈何时间有限，只走了三分之一便匆匆返程，希望有时间独自去溜达溜达，不过路途遥远，大约是无法成行了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;new.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://vhdsih.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="life" scheme="https://vhdsih.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>28 Neural Network</title>
    <link href="https://vhdsih.github.io/2018/11/22/mltech12/"/>
    <id>https://vhdsih.github.io/2018/11/22/mltech12/</id>
    <published>2018-11-22T05:23:55.000Z</published>
    <updated>2023-10-25T14:44:32.216Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习技法》系列课程（十二）</p><span id="more"></span><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>我们已经了解了Perceptron，将多个Perceptron进行线性组合，其数学表示为：</p><p><img src="1.png"></p><p>其包含两层权重:wt和αt。此时它能够实现更复杂的边界划分，比如，它能够实现AND、OR、NOT等边界的划分。</p><p>实际上，如果我们使用更多数量的Perceptron，它的能力会更强，这也是Aggregation的特性之一，同样，模型的复杂度也会变大，会更容易overfitting。如果我们想要使用Perceptron去构造一个圆形边界的分类器，当使用了足够多的Perceptrons，其将会逼近一个平滑的边界。</p><p>然而，局限在于，简单的Perceptron的融合无法实现XOR，因为XOR的数据并不是线性可分的，这就导致我们根本不能使用Linear Aggregation Models。</p><p>那么该怎么做呢？可以使用多层感知机（MLP）——既然单层的Perceptron不能区分，那就继续做特征转换。MLP的能力要比简单地把Perceptron融合（Aggregation）在一起的能力更强大。这从生物学的角度类似与神经网络的信号处理。</p><h2 id="Neural-Network-Hypothesis"><a href="#Neural-Network-Hypothesis" class="headerlink" title="Neural Network Hypothesis"></a>Neural Network Hypothesis</h2><p>我们首先来看神经网络的输出部分。它的最后一层运算只是一个线性的运算，任何一种线性模型都可以运用到这个地方：线性分类、线性回归、逻辑回归等。</p><p>为了简单起见，接下来我们仅仅讨论最后一层使用线性回归（Regression）的神经网络（使用平方误差函数）。</p><p>然后我们看神经网络中间部分。此时它并不能使用任意的激活函数。首先，我们不能使用线性的激活函数，如果我们使用了，我们又何必将模型搞得这么复杂但是最后能力却很差。同样，也很少使用sign函数，因为这个函数的输出是离散的，它的值域为{-1， 1}，所以它是不可导的，从而导致很难最佳化。很多情况，我们使用tanh：</p><p><img src="2.png"> </p><p>它与逻辑回归中的函数θ（sigmoid）很像，tanh(x) = 2θ(2x) - 1，即相当于对sigmoid进行放缩。</p><p>神经网络实际上就是输入向量x，经过多个隐含层，其中每一个隐含层的输出都作为下一个层的输入，最终预测得到结果y。在这个过程中，我们可以将每一个层都看作是在做特征转换，它从数据中学习到这个转换。而转换的关键在于每一层的权重weight。神经网络可以看作是每一层都在做Pattern extraction。</p><h2 id="Neural-Network-Learning"><a href="#Neural-Network-Learning" class="headerlink" title="Neural Network Learning"></a>Neural Network Learning</h2><p>那么该如果学习权重weight呢？我们的目标是学习到合适的权重最小化最终的Ein，如果我们的神经网络只有一个隐含层，实际上它就是一个对Perceptron进行简单的Aggregation，那么我们可以使用Gradient Boosting来决定每一个神经元。如果是MLP呢，就不这么简单了。我们一般采用链导法则来计算梯度，从而使用梯度下降的方法完成这个任务。</p><p>神经网络的Error可以表示如下：</p><p><img src="3.png"> </p><p>对于最后一层的输出，其error关于对应weight的偏导数，以及任意一个神经元的偏导数可以表示为如下：</p><p><img src="4.png"> </p><p>其中sn代表当前神经元的输入。对于任意神经元，其中我们用δj来表示当前神经元的偏导数。很容易知道：</p><p><img src="5.png"> </p><p>那么对于其他任意神经元的δj该怎样表示呢？首先我们看相邻的输入si的关系：</p><p><img src="6.png"> </p><p>由此，我们可以推导相邻层的导数关系如下：</p><p><img src="7.png"> </p><p>这也就说明了当前层相对于误差的导数可以从后一层的传播（误差反向传播）。</p><p>最后，我们总结误差反向传播算法：</p><div aling=center> ![](8.png) <p>值得注意的是，1到3是可以并行执行很多次然后计算一个平均来执行4——这也就是mini-batch。</p><h2 id="Optimization-and-Regularization"><a href="#Optimization-and-Regularization" class="headerlink" title="Optimization and Regularization"></a>Optimization and Regularization</h2><p>在神经网络中最小化Ein可以使用梯度下降方法。然而多层神经网络可能存在很多个极小值，这也就是说，在最优化时获得的解可能只是局部最优解而非全局最优解。通过初始化不同的weight，我们可能会到达不同的local minimum。所以为了能够获得更好的结果，一个建议是尽可能随机选取weight，而且使用较小的初始权重(如果开始的权重很大，由于tanh的存在，梯度可能会很小，每一次只能走很小的步子)。</p><p>此外，我们从VC维度的角度来看神经网络，使用tanh的Neural Network，其vc dimension等于O(VD)，其中V=神经元的数目，D=权重的数目。我们使用多层神经网络，一方面能够拟合”anything“，另一方面，如果神经元数目过多也会造成过拟合。解决过拟合我们就需要weght-decay regularizer。</p><p>但是如果使用L2 regularizer，会把所有的权重变小，但是所有权重都不会为0。我们需要更稀疏的权重来更有效地降低模型复杂度。但是由于L1 regularizer在部分点上不可导，所以也不能使用。</p><p>解决这个问题一般有两个选择：1是在L2的基础上添加缩放；2是早一点结束训练过程，优化过程不要持续那么久。</p><p><img src="9.png"> </p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习技法》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习技法》系列课程（十二）&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>27 Gradient Boosted Decision Tree</title>
    <link href="https://vhdsih.github.io/2018/11/20/mltech11/"/>
    <id>https://vhdsih.github.io/2018/11/20/mltech11/</id>
    <published>2018-11-20T13:59:41.000Z</published>
    <updated>2023-10-25T14:44:32.266Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习技法》系列课程（十一）</p><span id="more"></span><h2 id="Adaptive-Boosted-Decision-Tree"><a href="#Adaptive-Boosted-Decision-Tree" class="headerlink" title="Adaptive Boosted Decision Tree"></a>Adaptive Boosted Decision Tree</h2><p>什么是GBDT（Gradient Boosted Decision Tree）？我们首先考虑随机森林的相关内容，RF利用bootstrap的方法从原始数据中不放回地随机抽取相同容量的数据，利用这些数据分别学习不同的决策树，然后通过Uniform的方法将所有的决策树融合到一起。上面我们为了得到RF使用了Bagging的方法，如果我们使用另一种方法——Adaptive Boosting（AdaBoost），就需要引入数据的权重u（在AdaBoost中已经讲解过了），我们将会用u来表示在新数据中每一种数据的频度，我们用这些u来学习到新的决策树，然后通过计算αt（大根号的自然对数，详见AdaBoost）将这些决策树组合到一起，我们将这种方法称为AdaBoost-DTree。如果采用这种方法，我们就需要改变决策树算法让其接受带有weight的数据。</p><p>对于这种带有weight的决策树算法，它需要最小化带有weight的Ein：</p><p><img src="1.png" alt="weighted algorithm"> </p><p>也就是我们需要求和每个样本点的错误乘以这个样本点出现的次数，这对于决策树来说比较复杂，那么我们能否尝试不改变原来的演算法，转而在数据上做一些处理来实现我们原来的目的呢——这实际上是可以做到的。我们来考虑我们刚刚一直提到的权重这个概念到底是什么，对Bagging来说，权重就是使用Bootstrap方法复制原有的数据，每一个数据到底复制了几份，这个“几份”就是我们所谓的权重；或者权重也可以表述为一个采样（sampling），我们可以根据u的数值在原始数据上进行采样，那么采样结果中每种数据出现的几率应该是和权重u成正比的。</p><p>依据上面的表述，AdaBoost-DTree模型可以无需修改决策树算法，仅通过AdaBoost、决策树以及正比于权重u的数据采样就可以实现。</p><p>此外，AdaBoost中关键的一步是计算当前g的错误率，并依据这个错误率来重新调整数据（re-weighting）。</p><p><img src="2.png" alt="adaboost"></p><p>然而，考虑这种情况：如果用于学习决策树的过程中我们没有加以任何限制，并且使用了全部的数据，那么决策树就会完全成长，最终Ein=0，那么此时αt就会变为0。这就说明我们只要使用这一棵树就能完成任务了（autocarcy），但实际上却并不如此。从这个角度来看，我们可能需要一些能力更”弱“的决策树，所以我们可能需要对决策树进行剪枝操作，或者更简单的方法，只要限制决策树的高度即可，另外，我们也要使用sampling来使用部分数据。</p><p>那么继续上面的问题，什么是最弱的树呢？当然就是对数据只切一刀，这就是我们之前提到的Decision Stump，这也就是说，AdaBoost-Stump是AdaBoost-DTree的一个特例。</p><h2 id="Optimization-View-of-AdaBoost"><a href="#Optimization-View-of-AdaBoost" class="headerlink" title="Optimization View of AdaBoost"></a>Optimization View of AdaBoost</h2><p>我们进一步来探究AdaBoost的奥妙。AdaBoost中的一个关键点是对数据进行re-weighting，其过程如下：</p><p><img src="3.png" alt="ut+1"></p><p>正如上述表达式中所体现的，我们根据在当前这一笔数据上g是正确的还是错误的对权重u乘以或者除以一个量。我们可以对这个表达进一步简化为一个表达式，能够这样转换的原因在于如果yn和gt(xn)同号则为正确的，否则为错误的。方框t我们在AdaBoost中已经引入，其为对一个根号表达式αt取对数，因此可以将它们放入到exp中。</p><p><img src="4.png" alt="unt+1 - exp"></p><p>所以，un(t+1)等于最初的一个un连乘到unt，如上图中表达式所示，值得注意的是橘黄色的部分，它刚好是我们最终需要的G中的分数部分，如果它大于0，则结果为正1类，小于0，则为-1。我们将它称为voting score，其实际上就是在对gt进行投票，看最终gt对整个结果所起到的作用到底有多重要。</p><p><img src="5.png" alt="adaboost with exp"> </p><p>我们继续讨论voting score。AdaBoost实际上是linear blending的一个延伸，对于linear blending，它可以看做是一个特征转换，并使用线性模型将这些转换组合到一起（可能会有条件约束，但是可以省略）。我们可以换一个角度来考虑这个voting score，将αt看做是权重w，gt看做是特征转换 φ，那么，我们可以将w乘以 φ看做是一种距离（SVM中margin有类似形式的表达）。</p><p><img src="6.png" alt="g and svm"></p><p>这也就是说，可以将yn乘以voting score看作是没有正规化的距离（带符号的），那么我们需要让这个margin越大越好，这也就是说需要让exp(-yn(voting score))越小越好，从而un(t+1)也要小。</p><p>实际上，随着AdaBoost的进行，对unt的加和会越来越小，这也说明了它能够保证可以达到large margin的效果。</p><p><img src="7.png" alt="claim"> </p><p>现在我们来研究关于Ada1Boost的Error Function：</p><p><img src="8.png" alt="Error Function"></p><p>我们将01Error和ErrorADA绘制到同一张图片中，可以发现ADA Error是01error的一个上界，我们称其为exponential error measure。</p><p><img src="9.png" alt="ADA and 01"> </p><p>所以，做好ADA Error，就能大概将01 Error做的好。</p><p>然而，AdaBoost真的能够做的好吗，我们该做呢？我们解决这个问题所使用的技巧其实都已经学习过了：使用梯度下降（Gradient Descent）和泰勒展开，求一个最好的方向，在这个方向走一个η大小的步子，最终最优化我们的问题。</p><p><img src="10.png" alt="recall"></p><p>对于我们将要证明的问题，我们需要依样画葫芦——将g当成方向——我们对函数求梯度和向量其实没有什么太大不同，只是在index上有所区别，函数的index是实数，而向量的index是整数。</p><p><img src="11.png" alt="solve"></p><p>每一次，我们需要找到一个好的h，来最小化上述表达式的第二项（此时忽略η）。</p><p>对于一个二分类问题，yn和h(x)只会取值为1或者-1。那么，我们可以将需要最小化的表达式改写、平移：</p><p><img src="12.png" alt="binary classification"> </p><p>那么此时我们优化问题就转化为优化Einu，这也就是AdaBoost中所做的事情，也就表示AdaBoost可以帮我们找到‘梯度下降’的最好的方向（注意，此时是函数方向而非向量方向）。</p><p>我们利用Adab可以找到最佳的方向gt，那么该怎样学习合适的η呢？可以使用固定的较小η，但是这会导致计算复杂，所以我们可能需要一个更大的η，或者干脆找到一个最好的η，沿着某个方向走到最深处（steepest descent for optimization）。</p><p><img src="13.png" alt="η"> </p><p>正如上述推导，对于二分类我们可以考虑两种情况，针对这两种情况，我们可以将ADA ERROR进行整理。然后对η求偏导数，得到最佳的η刚好等于AdaBoost中的αt。这也就说明了AdaBoost就是在寻找梯度下降的最优的方向和步长。我们通过AdaBoost来学习gt和αt的同时，也确定了梯度下降的函数方向以及步长。</p><h2 id="Gradient-Boosting"><a href="#Gradient-Boosting" class="headerlink" title="Gradient Boosting"></a>Gradient Boosting</h2><p>对于二分类的AdaBoost，它的求解过程就是在优化h和η：</p><p><img src="14.png" alt="binary classification - adaboost"> </p><p>我们可以将AdaBoost推广到更一般的情况中，即令其使用回归的error或者其他error（只要其满足平滑的条件，因为需要使用Gradient Descent的方法最优化方向h和步长η），我们称其为GradientBoost：</p><p><img src="15.png" alt="gradientboost"> </p><p>对于用于Regression的GradientBoost，error function使用平方误差函数：</p><p><img src="16.png" alt="regression - gb"> </p><p>上述的表达式看起来了很复杂，我们将对αtgt求和部分取别名为sn，我们需要寻找方向h和步长η。我们首先忽略η，求解h。可以使用泰勒展开：</p><p><img src="17.png"> </p><p>然而我们并不直接优化上述表达式，因为如果不限制h(x)的大小，当然其取值为负无穷时最好，如果对其进行限制，则会求解有条件的最优化问题，这很难解决。我们可以将h当做一个惩罚项，h如果越大，则我们越不喜欢它，如果很小，则看起来还不错：</p><p><img src="18.png"></p><p>我们通过配方将其表达为更适合计算的形式，注意灰色的都是常亮，并不会影响到优化问题。我们称yn -sn为余数（residual），表示当前第n个样本与预测样本的差值，余数表示当前预测的结果与余数的差值。我们如果优化这个问题，只需要让h最接近余数即可，这实际上就是一个回归问题。我们通过在余数上使用回归的方法能够得到最好的方向gt=h。</p><p>在找到h之后，我们还需要决定η。</p><p><img src="19.png"></p><p>GBDT:</p><p><img src="20.png"> </p><h2 id="Summary-of-Aggregation-Models"><a href="#Summary-of-Aggregation-Models" class="headerlink" title="Summary of Aggregation Models"></a>Summary of Aggregation Models</h2><p>最后，我们总结一下关于Blending的内容。Blending，就是在获得多个不同的g后将它们融合到一起使用（Aggregate）。我们通常有三种方法来做Aggregation。</p><ol><li>Uniform，这是一种简单的方法，实际上就是投票来决定。</li><li>Non-uniform，就是用线性的方法将多个g融合到一起。</li><li>Conditional，使用非线性的模型融合g。</li></ol><p>对于Unifrom的方法，它是稳定的，而对于其它两种方法，都存在因为模型过于复杂而导致过拟合的风险，因此需要小心地使用它们。</p><p>对于上述的不同的方法，我们通常有不同的演算法来实现：</p><ol><li>Uniform：使用Bagging，就是通过boostrap来得到不同的g，直接通过投票将g组合到一起</li><li>Non-uniform：使用AdaBoost，使用boostrap，得到数据的权重，通过reweighting的方案学习不同的g，然后使用线性模型来组合他们（在得到g的同时就得到了每个g的权重αt）；GradientBoost，使用residual fitting的方案来学习到不同的g。</li><li>Conditional：使用决策树。</li></ol><p>其中Boosting-like的演算法最受欢迎（AdaBoost and GradientBoost）。当然，除了以上集中方案以外，我们还可以将Bagging、AdaBoost等和决策树组合到一起使用。使用Bagging和决策树就是随机森林，需要注意的是，此时我们使用的决策树是一个完全长成的树（strong）；使用AdaBoost和决策树就是AdaBoost-DTree，此时需要能力弱一些的树；使用GradientBoost就得到了GBDT，同样它也需要弱一些的树。这三种方法都很常用。</p><p>对于Aggregation，它的作用体现在两个方面：</p><ol><li>cure underfitting（防止欠拟合）：当个g很弱，无法完成任务，把多个很弱的g融合到一起，可以得到能力更强的G。</li><li>cure overfitting（防止过拟合）：多个g组合到一起使用，能够得到一个更为均衡的模型，这一点的作用和正则化类似。</li></ol><p>适当的Aggregation（也被称为Ensemble）可以提高模型的性能！</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习技法》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习技法》系列课程（十一）&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>26 Random Forest</title>
    <link href="https://vhdsih.github.io/2018/11/18/mltech10/"/>
    <id>https://vhdsih.github.io/2018/11/18/mltech10/</id>
    <published>2018-11-18T11:40:38.000Z</published>
    <updated>2023-10-25T14:44:32.254Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习技法》系列课程（十）</p><span id="more"></span><h2 id="Random-Forest-Algorithm"><a href="#Random-Forest-Algorithm" class="headerlink" title="Random Forest Algorithm"></a>Random Forest Algorithm</h2><p>我们已经学习了Bagging和Decision Tree。对于Bagging，它使用bootstrap的方法获取不同的g，将他们unifrom组合到一起，使用Bagging可以降低Variance!对于Decision Tree，它通过递归的方法切分数据，实际上也是很多g的组合，然而，它对数据很敏感，Variance很大。</p><p>现在我们考虑将Bagging和Decision Tree融合到一起使用（aggregation of aggregation），这也就是将要学习的随机森林（Random Forest；RF）。</p><p><img src="1.png" alt="RF"> </p><p>对于随机森林，它使用bootstrap方案获得多个容量和原始数据容量相同的数据集合，并使用这些数据集学习多个不同的决策树，然后将它们uniform到一起。随机森林继承了决策树简单、高效的特性，同时，也继承了C&amp;RT的优点，而使用Bagging也能有效避免完全成长的决策树会发生的overfitting的问题。</p><p>另一方面，我们考虑在Bagging中是如何获得不同的数据：它利用的是数据角度的随机。那么，我们可以从特征的角度考虑：对features进行抽取，从原有的大量特征中抽取一部分做决策树。例如在100个特征中随机抽取10个特征进行构建，这实际上就是一个特征转换，从一个高维度特征转换到低维度特征。随机森林的原作者建议在构建决策树时，每一个分支的选择都重新随机选取特征，这样能保证决策树更随机。</p><p>此时，我们的随机森林表示如下（Bagging算法和使用特征子空间的组合）：</p><p><img src="2.png" alt="RF2"> </p><p>我们说从特征中随机抽取，其实可以看做原有特征矩阵乘以一个投影矩阵(对特征进行投影，投影到指定的空间)，该投影矩阵的每一行都是natural basis（一些基向量）。那么能否将原始特征投影到其他方向（非固定的位置，随机的方向），如果这样做，我们得到的模型将会更加复杂，同时其能力也更加强大。那么我们就会利用一个新的投影矩阵，其每一行的元素都是随机的，它将多个特征combination起来，并且这个映射通常向低维度的空间进行映射，所以每一行中非0元素是有限的（和投影空间维度相等）。</p><p>此时，我们的随机森林表示如下（Bagging和随机组合特征的组合）：</p><p><img src="3.png" alt="RF3"> </p><h2 id="Out-Of-Bag-Estimate"><a href="#Out-Of-Bag-Estimate" class="headerlink" title="Out-Of-Bag Estimate"></a>Out-Of-Bag Estimate</h2><p>在开始本话题之前，我们讨论有关Bagging的内容，它使用Boostring来从原始数据中不放回地随机抽取数据来学习到不同的假设g，最后将这些g使用uniform的方案组合到一起。那么每一次都会有一些数据不会被选到，或者说每次选择数据来学习g时，绝大多数都是使用原始数据的一个子集完成的，我们将这些在学习gt过程中没有使用到的数据称为gt的out-of-bag(OOB) examples。</p><p>那么，如果数据容量为N，如果我们使用了N个g，有多少个数据是一次都没有被选择的呢？我们可以使用数学进行推导：</p><p><img src="4.png" alt="oob"> </p><p>也就是说，如果N非常大，将会有接近1/3的数据从来没有被用到过。那么我们可以使用这些从来没有用到过的数据做一些和Validation类似的事情。我们可以用这些数据来验证每一个得到的gt，然而我们关心的是最后融合多个gt的G(x)，所以这一步是没有必要的。那么我们该如何利用这些数据验证G呢？我们可以看一看数据(x, y)是哪些gt的OOB的子集，由此验证这些gt，然后将所有的样本的验证结果取平均即可。</p><p><img src="5.png" alt="eoob"> </p><p>我们将上述Eoob称为Bagging（RF）的自我验证(self-validation)。在以前的工作中，我们在得到假设g后，需要使用Validation Set来进行模型选择，而在随机森林中，由于有OOB的存在，我们使用Eoob就可以在训练过程中就完成了模型选择，而无需重新训练模型了。</p><h2 id="Feature-Selection"><a href="#Feature-Selection" class="headerlink" title="Feature Selection"></a>Feature Selection</h2><p>接下来，我们讨论有关特征选择的问题。</p><p>对于我们手上的数据，其往往是高维度的，利用特征选择，我们可以去除冗余的信息，筛选掉无关的信息。对于特征选择，实际上就是一个在学习一个特征转换，它将原有的高维度数据转换为一个低维度的数据。我们做特征选择，好处是可以简化问题，提高效率，降低overfit。然而，特征选择往往是困难的，需要花费很多时间，同时如果选错了可能会造成更糟糕的后果！在Decision Tree以及AdaBoost中，其算法中就已经内建了特征选择的过程，比如决策树每个节点选择使用那个特征来分割数据。</p><p>如果我们能够针对性地计算每一个特征的重要性，然后就可以top-d个特征作为特征选择的结果。这对于线性模型来说是简单的，比如pla算法中，我们使用的权重向量就能说明这个问题。如果是非线性的模型，它的特征选择往往很困难，对于这种问题，我们可以采用random test：如果某一个特征很重要，那么如果我们使用一些随机的数据来测试这个特征，它往往会表现很糟糕！那么我们该使用什么样的随机数据呢？我们可以使用指定分布的随机数据，比如高斯分布等；或者使用permutation test（将原有的多维度数据各个维度中的数据顺序打乱），这样来比较使用两种数据后的差距。</p><p><img src="6.png" alt="permutation"> </p><p>我们可以使用上述表达式来衡量特征的重要性，然而问题是Dp的性能需要重新训练模型并做validation。我们能否采用一些取巧的方法来避免这种问题呢？对于随机森林来说，可以选择在训练过程中仍然使用数据集D而不使用Dp，而在使用OOB验证过程使用permutation test！</p><p><img src="7.png" alt="permutation-eoob"> </p><p>在随机森林算法中，使用permutation和OOB进行特征选择通常更加高效，同时也能够保证性能！</p><h2 id="Random-Forest-in-Action"><a href="#Random-Forest-in-Action" class="headerlink" title="Random Forest in Action"></a>Random Forest in Action</h2><p>最后，在实践中，随机森利中包含的决策树越多越好，我们总是利用有限来逼近无限。</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习技法》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习技法》系列课程（十）&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>25 Decision Tree</title>
    <link href="https://vhdsih.github.io/2018/11/17/mltech09/"/>
    <id>https://vhdsih.github.io/2018/11/17/mltech09/</id>
    <published>2018-11-17T12:15:36.000Z</published>
    <updated>2023-10-25T14:44:32.211Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习技法》系列课程（九）</p><span id="more"></span><h2 id="Decision-Tree-Hypothesis"><a href="#Decision-Tree-Hypothesis" class="headerlink" title="Decision Tree Hypothesis"></a>Decision Tree Hypothesis</h2><p>我们学习了将多个假设g融合到一起使用的方法：Blending、Bagging以及AdaBoost，使用这些Aggregate的方法，我们可以提高模型的性能（即使每一个g都只能比瞎猜要好一点）。如果我们现在手上已经有了一些假设g，那么我们可以通过uniform、non-uniform、conditional等方式将它们融合在一起（Blending）；如果我们现在手上没有这些g，那么我们需要从数据中学习到一些g，然后将其组合到一起：我们可以使用Bagging的方法来做uniform的组合，使用AdaBoost的方法来做non-uniform的组合。现在我们将学习一种新的方案：决策树（Decision Tree），使用它我们可以学习到一些g，并将其有条件的（conditional）组合到一起！</p><p>我们在数据结构课程中学习了树形结构，对于决策树来说，他的每一个非叶子节点就是一个条件，或者说是基本的假设（g），它们通常是很简单的，而连接这个节点的每一条边都表示条件相应的取值（或者取值范围），而每一个叶子节点则表示最终的结果。</p><p>我们可以从两个角度来看决策树这种学习算法：</p><ol><li>我们可以将整个决策树这个假设G(x)看做是多个从根节点到叶子的路径的组合（多个假设g的组合）。</li><li>可也以递归地看待决策树，每一个决策树都是由根节点（一个基本假设）和多个子决策树构成的。</li></ol><p>对于决策树，其最重要的优点就是他的可解释性，只要构建了一个决策树，我们就能清晰地看到它的决策过程。同时，它也是简单高效的。然而对于决策树来说，它缺少必要的理论支撑，我们很难说明怎样让它做得好或者说为什么它能做得好（或者说对于决策树有很多的解释方案）。同时存在多种决策树的构建方案，但是并不存在一种代表性的算法。</p><h2 id="Decision-Tree-Algorithm"><a href="#Decision-Tree-Algorithm" class="headerlink" title="Decision Tree Algorithm"></a>Decision Tree Algorithm</h2><p>我们可以将决策树表示为如下形式：</p><p><img src="1.png" alt="decision tree"> </p><p>这是一种递归的表示方案，其中C表示根节点的假设取值一共有C个，从而有C个子决策树。</p><p>我们如果要构建这样的一棵决策树，则需要有四个要点：</p><ol><li>决策树有几个分支（每个假设有几个取值）。</li><li>怎样将数据D拆分（当假设取值为某一个值，则对应某一部分数据：Dc = {(x, y)| b(x) = c}）。</li><li>每一个条件的选择。</li><li>决策树构建的终止条件。</li></ol><p>下面我们学习一种构建决策树的方法：Classification and Regression Tree (C&amp;RT)。该算法分支数目C=2，也就是说使用该算法构建的决策树是一棵二叉树；其次，它最后的叶子是一个常数（哪一类）。也因此，如果使用该算法构建的决策树要解决的问题是一个回归问题，其可以使用平方误差；如果解决的是一个分类问题，则可以使用01Error。</p><p>我们提到决策树构建需要解决4个问题，上面我们已经说明C&amp;RT的分支数（C）是2；而在每一个节点对数据进行拆分的方法是decision stump，也就是根据某一个简单的条件，将数据分为两部分。而决定使用哪一个条件来拆分数据的方法是引入一个纯净度（purifying）来衡量条件的好坏，与之相对的则是不纯净度（impurify），我们一般通过最小化不纯净度来决定条件的选择：</p><p><img src="2.png" alt="bi-branching"> </p><p>上面的表达式是不纯净度的表达式，其表示在假设h的条件下两个分支不纯净度的加和，如果b(x)越小，说明在该结点这个假设h越好。</p><p><img src="3.png" alt="ein"> </p><p>如上图所示，我们提到C&amp;RT的每一个叶子都是常数，那么如果解决回归问题，可以使用平方误差，如果是分类问题，可以使用01误差（看大多数相同的数据和其他数据的差）。然而，我们进一步讨论分类问题，会发现这种衡量方法只会考虑数量最多的数据，而其他数据不会被考虑到，因此可以使用Gini指数来作为分类问题的求解方法(它也更适合用于分类问题)：它考虑了所有数据。</p><p>最后我们考虑决策树的终止条件，其包含两个条件：</p><ol><li>如果最终的数据仅仅包含相同的数据，此时无法继续切分，所以可以终止算法。</li><li>如果数据对应的yn是相同的，此时说明不纯度为0，可以终止算法。</li></ol><h2 id="Decision-Tree-Heuristics-in-C-amp-RT"><a href="#Decision-Tree-Heuristics-in-C-amp-RT" class="headerlink" title="Decision Tree Heuristics in C&amp;RT"></a>Decision Tree Heuristics in C&amp;RT</h2><p>C&amp;RT方法很容易处理二分类、回归以及多分类问题。然而，对于一个完全成长的决策树，很可能Ein=0，但是Eout是非常大的。因为随着决策树构建的进行，构建每个节点的数据越来越少，这就导致了overfitting。</p><p>由此，我们需要regularization的方法来降低复杂度。对于决策树，其模型的复杂度体现在叶子节点的数量，所以，我们可以不切那么多的树叶，一个好的决策树，不但它的ein很低，树叶的数量也要少。所以，当我们得到一棵完全成长的决策树以后，可以去掉一些叶子，选择ein稍稍大一点但是复杂度小一点的，这个方法就是剪枝。</p><p>如果考虑所有可能的切法,这看起来不容易做到。实际操作中，我们可以在得到完全长成的树以后，把每一个叶子摘掉，看哪个Ein最小，然后试着摘第二个叶子，第三个叶子…</p><p>此外，我们也会遇到非数值性的特征，使用决策树我们同样可以处理这样的问题，此时对于不同的类别可以采用“左”、“右”来切分而不是0、1。</p><p>我们还可能会遇到特征缺失的场景，我们的一种解决方案是surrogate branch，就是选择近似的特征来替代这些缺失的特征。那么怎样选择近似的特征呢？如果两种特征切分结果是类似的，说明它们相似。可以将其存储，在预测时遇到缺失数据以后，使用它替代缺失的特征。</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习技法》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习技法》系列课程（九）&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>24 Adaptive Boostring</title>
    <link href="https://vhdsih.github.io/2018/11/11/mltech08/"/>
    <id>https://vhdsih.github.io/2018/11/11/mltech08/</id>
    <published>2018-11-11T13:21:31.000Z</published>
    <updated>2023-10-25T14:44:32.210Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习技法》系列课程（八）</p><span id="more"></span><p>在上一章，我们学习了Aggregation方法：如果将多个不同的hypotheses组合在一起使用，我们能够获得更好的性能。我们介绍了实现Aggregation的两种方法，Blending和Bagging。对于Blending，我们可以视各个hypothesis是同等重要的（一个一票），也可以使用线性或者非线性的组合方法。对于Bagging，它通过使用bootstrap方法从原始数据中抽取多个相同容量的数据副本，从而学习到很多不同的hypothesis用于Aggregation。下面我们学习一种新的方案：Adaptive Boostring。</p><h2 id="Motivation-of-Boosting"><a href="#Motivation-of-Boosting" class="headerlink" title="Motivation of Boosting"></a>Motivation of Boosting</h2><p>我们从实际生活的一个场景来引出我们所要讲述的内容：幼儿园的小朋友如何学习从很多的水果中正确区分出苹果。<br>很多小朋友可能会从不同的角度来提出区分的方案，比如形状是圆形的，比如颜色是红色的，比如说过是有柄的等等。可能单单对于其中的几个是不能完成任务的，但是多个组合在一起就能够起到区分的作用。<br>在这个教导小朋友学习识物的过程中，老师起到的一个很大的作用是除了要指出哪些是对的以外，还要指出小朋友在哪里犯错了，让小朋友的注意力集中到那些值得注意的特征上面。<br>在这里，每一个小朋友就像我们学习过程中的每一个假设（g），而老师则可以类比于我们所使用的学习算法，重要的是这个学习算法能够指导学习的关注点可以放在关键的部分（如那些分类错误的点）。</p><h2 id="Diversity-by-Re-weighting"><a href="#Diversity-by-Re-weighting" class="headerlink" title="Diversity by Re-weighting"></a>Diversity by Re-weighting</h2><p>我们首先从Bagging讲起，其核心是bootstrap方法：从样本数量为N的数据中又放回地抽取N个数据，所得到的新的数据就会包含一些重复的数据点。我们可以使用更简单的方法来表示这些数据：我们使用ui表示每一个数据点包含的数目，ui可能是0，也可能是大于0小于N的任意数字，可以把ui看作是数据的权重，而bootstrap方法就是用来产生这些u，从而能够学习不同的g用以Bagging。</p><p>我们将添加了这些参数un的演算法称为Weighted Base Algorithm，如果某个点很重要，就为其添加较大的un权重，其需要最小化的Ein为：</p><p><img src="1.png" alt="ein to minimize"> </p><p>对于这样的Weighted-base问题，我们在之前的学习中就有所接触，我们在SVM以及逻辑回归中也使用了类似的方法。对于SVM，其添加的un，最终会移动到参数α的上界。在SGD的LR算法中un可以决定抽样的比例。</p><p>现在我们回头来看我们的Bagging问题，它如果能够达到很好的效果，其条件之一是每一个g要不同，越不同，效果越好。那么我们该怎样选择u来让g更加多样性呢（另一层意思是怎样优化bootstrap来达到增加g多样性的目的）？</p><p>考虑在两轮中使用un(t)和un(t+1)获得的gt和gt+1。如果我们选出的gt在使用权重un(t+1)时效果越差，那么gt和与gt类似的假设就都不会被选择，这也就说明了gt+1和gt差别就会很大。那么我们从全局上考虑，如果让所有的g整体上表现最好，那么让其发生的更随机，就类似丢硬币：概率为1/2：</p><p><img src="2.png" alt="idea"> </p><p>让在gt下un(t+1)正确的和错误的点一样多！</p><h2 id="Adaptive-Boosting-Algorithm"><a href="#Adaptive-Boosting-Algorithm" class="headerlink" title="Adaptive Boosting Algorithm"></a>Adaptive Boosting Algorithm</h2><p>上一节中，我们讨论了optimal re-weighting，其意义是首先将手上的gt的错误率a计算出来，然后把错误的点做（1-a）比例的放缩，然后把正确的点做a的放缩。现在我们定义一个新的比例因子来代替上面的a：</p><p><img src="3.png" alt="new factor"> </p><p>这样就能把错误放大，正确缩小了，这样就能专注于错误的数据！</p><p>现在我们可以基本写出Adaptive Boosting，其使用un来代替bagging算法中的bootstrap，每一轮通过un获得gt（通过最小化01Error），在下一轮更新un时，通过上述的“方片”因子进行处理。然而，还存在两个问题没有处理：</p><ol><li>un怎样初始化？</li><li>各个g怎样组合到一起？</li></ol><p>对于第一个问题，u1 = 1 / N。对于第二个问题，我们肯定不能采用同等权重的方案，因为在这里有的g做得好，但是同样存在g做的很糟糕，他们的比例基本是随机的。提出该算法的作者则在每次update un时都自动计算每个g的比例系数：αt=ln(“方片”)，其意义表示：如果gt越好，那么αt越大，如果犯错的概率为1/2，则其起不到作用αt=0，如果犯错概率为0，则这一个g就能完美完成任务，则αt为无穷大。这就是我们这一节中要了解的Adaptive Boostring（AdaBoost）Algorithm：</p><p><img src="4.png" alt="adaboost"> </p><p>该算法的具体过程如下：</p><p><diva align=center> <img src="5.png" alt="adaboost - code"> </p><p>对于AdaBoost，我们可以从VC Bound的角度来考虑其复杂度，这里不再具体解释。这里有一个结论：如果其中的g能够比胡乱猜要做得好（错误率小于1/2）就能够保证在T = O（logN）次迭代后让Ein(G)很小，并且Eout可以做到基本小于Ein(G)。</p><p>对于AdaBoost，只要g比随机要做得好，那么它就能很健壮！</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习技法》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习技法》系列课程（八）&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>23 Blending and Bagging</title>
    <link href="https://vhdsih.github.io/2018/10/28/mltech07/"/>
    <id>https://vhdsih.github.io/2018/10/28/mltech07/</id>
    <published>2018-10-28T09:42:46.000Z</published>
    <updated>2023-10-25T14:44:32.257Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习技法》系列课程（七）</p><span id="more"></span><h2 id="Motivation-of-Aggregation"><a href="#Motivation-of-Aggregation" class="headerlink" title="Motivation of Aggregation"></a>Motivation of Aggregation</h2><p>在机器学习中，我们可能需要将一些假设函数和特征组合在一起使用，这就是我们现在要说的Aggregation。那么我们为什么要引入这个方法，其原因就在于融合多个hypothese往往能够获得更好的性能表现。</p><p>那么直观来看，我们该怎样融合？</p><ol><li>我们之前使用Validation的方法来选择最佳的hypothesis，这仅仅利用了一个h(x)。</li><li>平等地使用多个h(x)，就像投票一样，看那个票数多，这就是所谓的uniformly。</li><li>由于不同的假设函数的重要程度不同，可能有的起到了决定作用，另一些则没那么重要，所以可以对不同的h(x)赋予不同的权重（non-uniformly）。</li><li>添加一些条件，如果满足条件，就使用这种假设，并且根据所满足的程度赋予不同的权重（conditionally）。</li></ol><p>对于上面的几种方案，我们很容易将其用数学形式表达出来，其中：</p><ol><li>选择Eval最小的（argmin）：G(x) = gt’(x), t’= argminEval(gt)。</li><li>G(x) = sign(sum(g(x)))。</li><li>G(x) = sign(sum(a * g(x)))</li><li>G(x) = sign(sum(q(x)* g(x)))</li></ol><p>** 注：可以到机器学习技法第七个ppt中查看具体的公式 **</p><p>实际上我们发现，第四个使用一个函数q(x)来确定条件，其他几种方法都是它的子集。</p><p>但是，在这里我们需要注意的是，如果我们联合了多个hypothesis来做分类，那么怎么选择最优的就很重要。我们应该选择优化Eval而不是Ein，否则这将会给计算带来巨大的困难（要考虑所有Hypothesis的dvc）。</p><p>在我们之前一直做的都是从假设空间中选择最优的h(x)，然而，我们现在使用了Aggregation，它将一些不同的hypotheses综合到一起考虑，可能这里的一些假设函数要比最优的假设函数的效果还差，我们还能保证得到的结果比仅仅用一个最佳h(x)要好吗？答案是肯定的，对多个假设合理的组合（尽管他们中的个体是weak的）能够获得更好的性能！我们可以从PLA的分类结果来考虑：PLA有多条分类边界，最好的是距离两种点的距离都很远的（或者说在中间的），这就是我们SVM能得到的结果，如果我们将PLA的所有结果平均一下，可以发现它基本就是最中间的那条。</p><h2 id="Uniform-Blending"><a href="#Uniform-Blending" class="headerlink" title="Uniform Blending"></a>Uniform Blending</h2><p>我们考虑使用Uniform Blending来解决分类问题，这个就像刚刚所说的，是一个投票问题，每个假设g(x)都有同样的权重1，然后将他们线性组合以后取sign来分类：</p><blockquote><p>G(X) = sign(sum(1 * gt(x))) {t from 1 to T}</p></blockquote><p>对于这种解决方案，如果gt都是相同的，实际上和使用一个gt没什么两样。如果gt是不同的，根据投票的原理，少数人服从多数，最终G(x)的结果也会收到gt中占比多的情况所影响。</p><p>当然，这种方法也同样使用于多分类问题，其核心思想是没有任何区别的。</p><p>那么如果我们想将uniform blending方法用到回归问题上呢？简单的将所有假设函数的数值加到一起输出肯定是不行的，我们可以加和取平均来解决这种问题。</p><blockquote><p>G(X) = 1 / T * sum(1 * gt(x)) {t from 1 to T}</p></blockquote><p>和分类问题类似，如果gt是相同的，那和使用一个gt没有区别，如果不同，对多个取平均可能会比单个的表现要好，因为一般来说，总会存在一些gt要小于f，而另一些要大于f，平均后和f比会更加接近。</p><p>如果我们使用了多个假设函数，甚至是很简单的uniform blending，我们最终获得的结果都要比使用单一的hypothesis要好，对于这一点，我们可以从理论上给予证明，证明方法就是看我们单一的g和f的差距和G和f的差距的大小，如果前者比后者要大，则证明了我们的观点，详细的证明方法如下：</p><p><img src="1.png" alt="prove"> </p><p>上图是证明的过程和结论，其结论说明了单个g和f的差值的平方等于G和f的差值的平方加上一个正数，这也就支持了我们的理论。</p><p>最后，我们考虑如果在取平均的表达式中T趋近无穷大，也就是说我们利用了几乎所有的hypothesis时的情况。此时：</p><p><img src="2.png" alt="infinite"> </p><p>此时我们能够降低方差（variance），从而得到更好的性能。</p><h2 id="Linear-and-Any-Blending"><a href="#Linear-and-Any-Blending" class="headerlink" title="Linear and Any Blending"></a>Linear and Any Blending</h2><p>刚刚我们同等对待每一个hypothesis，那么现在我们考虑Linear Blending，它为每一个假设乘以一个权重αt：</p><p><img src="3.png" alt="lb"> </p><p>看起来我们很难求解，但是我们可以对比使用特征转换的线性回归问题，发现他们是很相似的：</p><p><img src="4.png" alt="lb and lrt"> </p><p>所以，我们求解的线性的blending问题，可以当做是一个线性模型附带一些约束条件，并且将这些hypothesis当做是特征转换即可。不过实际操作中，对于αt&gt;=转换函数）。</p><p>同样，在进行选择时，我们仍然使用Eval。如果我们使用Ein进行选择，就是在最好的里面选择最好的，那么最终的计算需要考虑所有的模型复杂度。</p><p>当然，除了使用线性的Blending之外，我们也可以使用非线性的Blending(Any Blending)，我们称其为Stacking，它求解一个个函数g~(x)作为参数。区别在于后者学习能力更强，但是也更容易overfit，这一点需要特别注意。</p><h2 id="Bagging-Bootstrap-Aggregation"><a href="#Bagging-Bootstrap-Aggregation" class="headerlink" title="Bagging (Bootstrap Aggregation)"></a>Bagging (Bootstrap Aggregation)</h2><p>我们使用Blending，是因为将很多和不同的假设Hypothesis组合在一起使用能够带来更好的效果，注意这里的hypothesis必须是不同的，否则将会和使用一个没什么区别。那么这些不同的gt是从哪儿来的呢？</p><ol><li>我们可以使用不同的模型（Hypothesis Set）来获得不同的gt。</li><li>可以使用不同的参数，比如在随机梯度下降过程中，分别使用不同的学习率来学习到不同的gt。</li><li>我们可以使用随机算法，比如在中，我们随机获得的分类线是不同的。</li><li>我们也可以通过使用不同的数据来获得不同的gt。</li></ol><p>我们需要使用不同的gt，下面我们要考虑如何使用相同的数据集来模拟出不同的数据。实现这个目的的方法就是Bootstrapping，其意义就是从容量为N的数据中抽取出容量为N的数据副本，但是这个抽取过程是有放回的抽取，这也就保证了基本上每一份数据都是不同的。我们使用Bootstrapping来做Aggregation这种方法就是Bagging。</p><p>如果演算法对数据的分布很敏感，那么Bagging通常能够获得很好的效果！</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习技法》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习技法》系列课程（七）&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>22 Support Vector Regression</title>
    <link href="https://vhdsih.github.io/2018/10/26/mltech06/"/>
    <id>https://vhdsih.github.io/2018/10/26/mltech06/</id>
    <published>2018-10-26T11:19:58.000Z</published>
    <updated>2023-10-25T14:44:32.216Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习技法》系列课程（六）</p><span id="more"></span><h2 id="Kernel-Ridge-Regression"><a href="#Kernel-Ridge-Regression" class="headerlink" title="Kernel Ridge Regression"></a>Kernel Ridge Regression</h2><p>我们在上一次的课程中已经证明了，任何一个带有L2正则化的线性模型，它的权重向量w都可以表示为原始数据经过特征转换后所在的Z空间的向量的线性组合，这也就意味着，任何一个带有L2正则化的线性模型都可以使用核函数（kernel function）来解决。</p><p>现在我们考虑我们常见的Regression问题，它使用平方误差函数作为loss，我们求解该问题往往直接求解其梯度为0时的方程就能直接获得结果。现在的问题是，我们该怎么做来将Kernel引入到这些回归问题中。</p><p>我们的Kernel ridge regression问题如下：</p><p><img src="1.png" alt="krrp"> </p><p>我们可以直接将表达式中的w用βzn来替代，并改写为矩阵的表达形式：</p><p><img src="2.png" alt="krrp-β"> </p><p>我们发现，现在的未知数只有β，我们的原始回归问题就转换为求解上述表达式最小化时β的取值，我们只需要对β求梯度即可：</p><p><img src="3.png" alt="gradient"> </p><p>我们如果要最小化，那么则上述梯度为0，此时我们能够得到的一种可能的解：</p><p><img src="4.png" alt="r"> </p><p>根据我们所学过的Mercer条件，我们可以知道上述表达式中的逆矩阵是一定存在的(K是半正定的)。此时计算该逆矩阵需要的时间复杂度是O(n ^ 3)，而且此时的矩阵是稠密的。下面是在相同资料中linear ridge regression和kernel ridge regression的表现：</p><p><img src="5.png" alt="lrr and krr"> </p><p>其中左图是linear ridge regression的分类结果，右图是kernel ridge regression的结果。对于前者，它是线性模型，只能拟合直线，而且它的训练的复杂度是O(d ^ 3 + d ^ 2 * N)，在预测时的复杂度只有O(d)，如果我们的数据量很大时（比模型复杂度更高）那么此时该模型的效率就会很高。对于后者，它是一个更灵活的模型，对于可能比前者的拟合效果更好，然而它的训练复杂度是O(N ^ 3)，预测的复杂度是O(N)，也就是说，数据量越多，无论训练还是预测，它都会更慢。因此对于大量的数据来说，该模型可能难以使用。</p><p>因此这两种方法相比，前者更高效，但是后者灵活性更高，学习能力更强！</p><h2 id="Support-Vector-Regression-Primal"><a href="#Support-Vector-Regression-Primal" class="headerlink" title="Support Vector Regression Primal"></a>Support Vector Regression Primal</h2><p>我们上面提到的kernel ridge regression也可以用来做分类，我们将这种方法叫做LSSVM。（least-squares SVM）。</p><p>我们现在比较使用soft-margin gaussian svm和lssvm两种方法用于分类时的区别：</p><p><img src="6.png" alt="svm vs lssvm"> </p><p>这两种方法的分类边界是相似的，所不同的是svm中的支撑向量是有限的，而lssvm中几乎所有的点都是支撑向量（因为我们求解kernel ridge regression问题时，其参数β总是稠密的，所对应的都是支撑向量，而在计算svm时，其参数α是稀疏的，所以支撑向量的数码也是有限的），也正因为如此，计算lssvm将会带来巨大的代价。</p><p>我们现在需要考虑的是能不能寻找一种方法，lssvm中稠密的β变为稀疏的β，从而减少支撑向量的数目，降低计算的复杂度。</p><p>我们现在考虑一种新的方案：Tube Regression：</p><p><img src="7.png" alt="tube regression"> </p><p>在这种方案中，它允许一个中立的缓冲区存在：在这个区间的点，我们认为它是对的，只有不在这缓冲区的点，我们才会考虑它所带来的错误。我们令这个缓冲区的宽度为2e，那么现在的err function就变成了如下形式，我们将其称为e-insensitive error：</p><p><img src="8.png" alt="tube regression"> </p><p>现在我们需要做的就是根据svm的方法，来让l2-regularized tube regression的β参数变得稀疏。在做这件事之前，我们先对比我们现在的tube err和常用的平方误差的区别：</p><p><img src="9.png" alt="tube and squared"> </p><p>我们可以将这两种err画在一张图上作比较：</p><p><img src="10.png" alt="tube and squared"> </p><p>tube的成长更加缓慢，更不容易受到outliers的影响，由此我们可以推断tube err可能更好！</p><p>我们现在要解决的问题变为：</p><p><img src="11.png" alt="q"> </p><p>它没有约束条件，但是难以微分，所以也很难用梯度下降的方法来寻找最优解。此外，尽管我们能够使用核函数来替代w，但是这也并不能保证参数β的稀疏性。我们回顾SVM问题：它的最优化问题是不能微分的，但是它可以使用二次规划（QP）来求解，可以使用对偶和核函数，通过KTT条件，最终保证了参数的稀疏性。现在我们将仿照标准的SVM的方法来解决这个tube regression问题，如下：</p><p><img src="12.png" alt="q"> </p><p>通过变换，变形为QP问题：</p><p><img src="13.png" alt="q"> </p><p>其中参数C表示的是regularization和tube violation之间的权重比，C越大，则tube violation更重要，否则则是正则化更重要。e是中立区间的宽度，是该svr问题中独有的参数。此外svr中的参数有d~ + 1 + 2N，而限制条件有4N个。</p><h2 id="Support-Vector-Regression-Dual"><a href="#Support-Vector-Regression-Dual" class="headerlink" title="Support Vector Regression Dual"></a>Support Vector Regression Dual</h2><h2 id="Summary-of-Kernel-Models"><a href="#Summary-of-Kernel-Models" class="headerlink" title="Summary of Kernel Models"></a>Summary of Kernel Models</h2><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习技法》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习技法》系列课程（六）&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>21 Kernel Logistic Regression</title>
    <link href="https://vhdsih.github.io/2018/10/25/mltech05/"/>
    <id>https://vhdsih.github.io/2018/10/25/mltech05/</id>
    <published>2018-10-25T06:42:35.000Z</published>
    <updated>2023-10-25T14:44:32.200Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习技法》系列课程（五）</p><span id="more"></span><h2 id="Soft-Margin-SVM-as-Regularized-Model"><a href="#Soft-Margin-SVM-as-Regularized-Model" class="headerlink" title="Soft-Margin SVM as Regularized Model"></a>Soft-Margin SVM as Regularized Model</h2><p>我们现在回头看看我们学过的几种SVM，最初接触的是Hard-Margin的原始问题，然而由于其涉及到Z空间的复杂度，所以我们提出了Dual形式的SVM。然而Dual并没有完全摆脱Z空间复杂度对SVM计算所带来的影响，由此我们学习了Kernel SVM，将特征转换和向量内积合为一个步骤。然而，如果严格要求没有错误（Hard Margin），可能得到的效果并不好，我们发现如果允许有几个错误点存在，我们的分类任务可能能够做得更好，由此我们提出了Soft-Margin的原始问题，出于和Hard-Margin相同的原因，我们同样对其使用了对偶和核函数的方法，从而得到了不同的SVM。而在实际任务中Soft-Margin的表现往往更好！</p><p><img src="1.png" alt="wrap up"> </p><p>我们再看一看我们的Soft-Margin SVM。我们在推到它的时候，其中一个重要的步骤是如何记录错误点的错误程度，我们引入一个新的变量ξn来记录错误的程度。如果我们的点是正确的，那么ξn=0。这是由于我们的限制条件所决定的：</p><p><img src="2.png" alt="s.t."> </p><p>也就是说，它所求的是任何数据点距离SVM的分类面的距离是多少，如果分对了，ξn的结果必然为0，分错了，则可以衡量距离远近，其结果必然是一个正数，所以，我们可以将其转换为如下形式：</p><p><img src="3.png" alt="unconstrained"> </p><p>可以发现，现在我们连变量ξn都消去了，使用一个max操作来表示我们的soft margin svm问题。上面的表达式我们可以简化表示为下面的形式：</p><p><img src="4.png" alt="familiar"> </p><p>看到这个形式，我们很熟悉，它就是L2正则化:</p><p><img src="5.png" alt="l2 r"> </p><p>这两个问题最终都有相同的表示，但是我们却没有使用相同的方法，而是利用QP来解决这个svm问题。为什么不直接使用正则化的解决办法来解决这个问题，原因如下：</p><ol><li>如果这样做，我们推导得到的对偶和核函数等方法就不能使用了。</li><li>表达中含有max项目，这是不可导的，所以难以解决。</li></ol><p>那么我们可以看一看正则化和svm之间的比较：</p><p><img src="6.png" alt="svm r"> </p><p>可以看到，无论是Harg-Margin还是Soft-Margin的SVM，它们和正则化问题在形式上是等同的。我们使用正则化，从而使用更短的w来降低overfit，而svm通过使用胖的分类界面来简化假设空间，让能够使用的分类面更少，从而降低overfit。而对于soft-margin问题，其参数C越大等价于正则化参数λ越小。</p><p>以上，我们建立了SVM和正则化之间的关系，我们可以将SVM看做是一种正则化模型。</p><h2 id="SVM-versus-Logistic-Regression"><a href="#SVM-versus-Logistic-Regression" class="headerlink" title="SVM versus Logistic Regression"></a>SVM versus Logistic Regression</h2><p>刚刚我们将soft-margin svm变形为如下形式：</p><p><img src="7.png" alt="svm r"> </p><p>我们令上面表达式中max项为ERRsvm，则我们比较这个ERRsvm和我们之前在二元分类中常用的01ERR。现在我们首先将max项中wTzn + b用s表示，yn用y表示：</p><p><img src="8.png" alt="cmp"> </p><p>我们可以绘制出两种错误的曲线图：</p><p><img src="9.png" alt="cmp curve"> </p><p>其中折线部分容易理解，我们的01ERR是一个bool表达式，如果ys &lt; 0表明预测和实际是相反的，所以err=1，否则err=0。而对于紫色的折线，则是svm的ERRsvm，我们可以发现它是01ERR的一个上界，我们通常将它称为hinge error measure。我们可以使用ERRsvm替代01ERR来解决二分类问题，并且，由于它是一个凸函数，也很容易最佳化！</p><p>现在我们来看一看SVM和Logistic Regression的关系。我们在学习LR时，曾经绘制了它的ERRce和01ERR的对比图，在下图的曲线中，表现为橘黄色曲线（我们通过平移将其和01ERR的转折点对齐）。我们能发现，ERRsvm在大部分基本和ERRsce相似。尤其当ys趋近于负无穷和趋近于正无穷时。</p><p><img src="10.png" alt="lr and svm"> </p><p>如上所述，我们可以说SVM近似于带有L2正则化的Logistic Regression。</p><p>最后，我们对比我们学过的一些用于分类的线性模型：</p><ol><li>PLA。我们使用最小化01ERR来优化模型，它关注于错误点，如果数据是线性可分的，那算法就是可行的，否则我们就需要使用Pocket算法。</li><li>Soft-Margin SVM。我们使用QP（二次规划）来最小化ERRsvm，这是比较容易的并且操作起来有理论保证，我们可以利用现有的二次规划工具。然而如果ys太小（专指小于0），此时，ERRsvm和01ERR相差太远，此时如果使用ERRsvm作为01ERR的上界，那损失可能会很大！</li><li>Regularized logistic regression。可以利用梯度下降或者随机梯度下降来优化该问题，这个方法很容易，并且由于使用了正则化，不容易出现过拟合。然而，它和svm有着相同的缺点，都是在ys太小时不能代表01ERR。</li></ol><p><img src="11.png" alt="linear models"> </p><p>解决一个带有正则化的LR问题，近似于解决SVM。</p><h2 id="SVM-for-Soft-Binary-Classification"><a href="#SVM-for-Soft-Binary-Classification" class="headerlink" title="SVM for Soft Binary Classification"></a>SVM for Soft Binary Classification</h2><p>下面，我们尝试将SVM应用到二元分类任务（Binary Classification）。</p><p>直观上，我们有两种idea：</p><ol><li>直接使用SVM获得b和w，然后直接带入到LR中，得到g(x) = θ(wTx + b)。这样做很直接，一般结果也还可以，但是却没有使用到LR中比较好的特性和方法。</li><li>使用SVM获得b和w，令其作为LR（with Regularization）的初始值，然后使用LR的方法来完成任务。然而这样做比直接使用LR没能好哪去，并且还增加了复杂度。</li></ol><p>因此，我们的方案调整如下：</p><p><img src="12.png" alt="two level learning"> </p><p>我们添加了缩放系数A和平移系数B，其中Wsvm和Bsvm是使用SVM计算得到的，而A和B是使用LR优化求解的。这样能够同时利用LR和SVM的优点！如果我们的Wsvm求解得当，那么A应该大于0，如果Bwvm很好，那么B应该接近0。</p><p>从而，我们的新的逻辑回归问题变为了如下形式：</p><p><img src="13.png" alt="new lr"> </p><p>我们将其称为two-level learning：使用LR在SVM特征转换后的数据上学习！对于解决这样的问题一般分为3个步骤：</p><ol><li>利用SVM获得Bsvm和Wsvm，然后将原始数据通过特征转换转换到Z空间。</li><li>在Z空间的数据上运行LR，获得A和B两个参数的数值。</li><li>返回最终的g(x)。</li></ol><h2 id="Kernel-Logistic-Regression"><a href="#Kernel-Logistic-Regression" class="headerlink" title="Kernel Logistic Regression"></a>Kernel Logistic Regression</h2><p>那如果我们想直接在Z空间完成LR该怎么做呢？我们可以引入核函数（Kernel Function）使用QP来优化求解。然而需要注意的是，LR不是一个QP问题，这是否意味着Kernel function我们无法引入了呢。<br>在回答这个问题之前，我们先回顾一下Kernel Trick为什么能够成立。其中最关键的是我们能让W表示为Zn的线性组合：</p><p><img src="14.png" alt="kernel trick"> </p><p>我们可以看我们学过的SVM，PLA，LR（by SGD）,他们的W都可以表示为Z的线性组合，也因此，我们可能能够使用这些方法，通过核函数来解决Z空间的分类问题。</p><p><img src="15.png" alt="kernel yes"> </p><p>那我们看一看我们使用L2正则化（L2-regularized）的线性模型能否使用kernel function，为了证明这个问题，我们利用反证法，首先我们假设是可以的：</p><p><img src="16.png" alt="assume"> </p><p>为了证明这个问题，我们最重要的思想是将所有的W分解为平行于Zn的部分和垂直于Zn的部分来计算，其具体步骤如下：</p><p>对于上面假设中的表达，后面的项中WT可以分解为垂直Zn和平行Zn的两部分，此时垂直部分乘以Zn结果为0，所以后面的部分等价于平行部分于Zn的内积,也就等于原来的部分。而前面的W平方项目，我们同样拆分并且展开平方项，得到的结果却大于平行项的乘积，能推断出当前的w不是最优解，但是这与假设矛盾，因此得证:</p><p><img src="17.png" alt="prove"> </p><p>这也就说明了任意一个L2正则化的线性模型都能使用kernel function！</p><p>现在我们将Kernel function应用到LR模型上。我们直接利用zn的线性替代w:</p><p><img src="19.png" alt="klr"> </p><p>现在我们所有的w项都被β所替代，我们称其为KLR（kernel Logistic Regression）。我们可以将其理解为β的线性模型，也可以理解为w的线性模型：</p><p><img src="20.png" alt="klr 2"> </p><p>需要注意的是SVM和KLR也有不同之处，前者求解后参数α通常有很多0，而后者的β通常都不是0（前者有限SV起到作用，而后者所有点都起到作用）。</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习技法》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习技法》系列课程（五）&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>20 Soft-Margin Support Vector Machine</title>
    <link href="https://vhdsih.github.io/2018/10/23/mltech04/"/>
    <id>https://vhdsih.github.io/2018/10/23/mltech04/</id>
    <published>2018-10-23T02:54:40.000Z</published>
    <updated>2023-10-25T14:44:32.257Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习技法》系列课程（四）</p><p>本章将引入Soft-Margin SVM以解决overfit问题，提高对错误点的忍受程度！</p><span id="more"></span><h2 id="Motivation-and-Primal-Problem"><a href="#Motivation-and-Primal-Problem" class="headerlink" title="Motivation and Primal Problem"></a>Motivation and Primal Problem</h2><p>上一节中，我们得出SVM仍然会发生overfit，其原因包括两个方面：</p><ol><li>模型的复杂度过高，学习能力太强！</li><li>模型要求必须没有错误点，必须将所有数据正确区分。</li></ol><p>然而，我们看一个例子：</p><p><img src="1.png" alt="example"> </p><p>如果我们一定要求要将所有的点正确分开，那么我们就必须选择一个4次的特征转换（右图）。然而，实际上图一的一次特征转换得到的分类结果更好，尽管里面有很少量的点没有正确区分。</p><p>现在我们回忆我们之前所学的内容：当我们第一次接触PLA算法，遇到不能线性分开的数据是怎样处理的？我们使用的是Pocket，尽管我们不能找到一个将所有点都正确分开的超平面，但是我们可以选择一个犯错最少的。我们可以将这种思想和我们一直使用的hard-margin SVM结合，得到一种能够忍受一些错误点的soft-margin SVM：</p><div aling=center> ![conbination](2.png) <p>我们对上述conbination的表达式稍做变形：</p><div aling=center> ![soft svm](3.png) <p>这是我们所需要的soft margin svm的一种表达形式，其中，对于正确的点，满足约束条件，而对于错误的点，由于右侧有负无穷，所以约束条件仍然成立。为了平衡min中两项的权重，添加了C系数。然而，上述计算式中含有bool计算项，此时就不是一个线性的表达式了，也因此，这个SVM问题不能使用QP来计算。同时，上述表达式尽管可以处理错误点，但是不能区分是一个大错误还是小错误（和正确边界距离大小），因此我们添加一个参数ξn来解决这个问题，并将表达式化简如下：</p><div aling=center> ![soft svm 2](4.png) <p>我们使用ξn来描述犯错的程度，其中ξn &gt;= 0，ξn越大表示犯错越大。而对于参数C，越大表示我们需要的分类界面越瘦，因为此时需要忍受更少的错误，而C越小则得到的分类界面越胖（能够忍受更多的错误）。</p><div aling=center> ![para c](5.png) <p>下面将引入对偶。</p><h2 id="Dual-Problem"><a href="#Dual-Problem" class="headerlink" title="Dual Problem"></a>Dual Problem</h2><p>类似于我们在Dual SVM中讲解的内容，对于我们已经得到的soft-margin svm，它的复杂度仍然依赖于Z空间的复杂度d~，此时我们要去除这个复杂度，因此我们要引入对偶。而引入对偶我们使用了一个重要的工具是拉格朗日乘数法，因为在soft margin svm中我们又新引入了一个参数，且对它有新的约束：大于等于0，由此，我们的拉格朗日乘数就变为了：αn和βn:</p><p><img src="6.png" alt="lagrange"> </p><p>同样类似于我们学过的Dual SVM的推导，我们的问题继续化简：</p><p><img src="7.png" alt="simplify dual svm"> </p><p>根据梯度下降法，最小值点在梯度为0处，我们分别对参数求偏导数，令其结果为0。首先处理ξn:</p><p><img src="8.png" alt="simplify dual svm"> </p><p>此时可将原问题化简为：</p><p><img src="9.png" alt="simplify dual svm"> </p><p>现在这个形式和我们的hard-margin svm类似，我们分别对b和w求偏导数，令其为0：</p><p><img src="10.png" alt="simplify dual svm"> </p><p>最终得到soft margin svm的dual形式：</p><p><img src="11.png" alt="simplify dual svm"> </p><p>现在我们可以使用QP解决该问题！</p><h2 id="Messages-behind-Soft-Margin-SVM"><a href="#Messages-behind-Soft-Margin-SVM" class="headerlink" title="Messages behind Soft-Margin SVM"></a>Messages behind Soft-Margin SVM</h2><p>现在我们可以利用QP解决soft margin svm：</p><p><img src="12.png" alt="qp for soft margin svm"> </p><p>大部分内容和hard-margin问题是相同的，并且它的灵活性更强。但是我们还需要考虑如何求解b这个问题。</p><p><img src="13.png" alt="get b"> </p><p>如上图，我们求解hard-margin svm问题，由互补松弛条件，我们找到一个支撑向量就能求解b。而对于soft-margin svm，同样存在这个条件，区别是它的条件有两个。如果我们找到了一个支撑向量，此时并不能计算出b。我们根据第二个条件，如果令C和αn不相等，则ξn=0，此时我们可以计算b。我们把0 &lt; αn &lt; C的点称为自由支撑向量(free SV)。</p><p>因此我们也可以引入核函数：</p><p><img src="14.png" alt="kernel soft margin svm"> </p><p>那么我们该怎样选择C的大小呢，我们看一看使用高斯核函数的soft-margin svm使用不同的C的效果：</p><p><img src="15.png" alt="gaossian kernel soft margin svm"> </p><p>C越大，分类界面越瘦，对噪音的容忍程度越低 - 发生了overfit！因此我们的svm现在仍然会发生过学习，所以在选择参数的时候必须要仔细！</p><p>最后我们看一看αn的物理意义是什么。我们已知它满足两个条件：</p><p><img src="16.png" alt="complementary slackness"> </p><p>根据这个条件，我们将考虑3种不同情况：</p><ol><li>αn = 0，此时ξn = 0，其表示该点不是SV，点大部分落在正确的一侧。</li><li>0 &lt; αn &lt; C，此时点在分类界面的边界上。</li><li>αn = C，此时ξn表示犯错的程度（偏离margin），这些点可能在margin中负方向，也可能在margin上。</li></ol><p>我们根据αn可以判断数据相对于margin的分布位置。</p><h2 id="Model-Selection"><a href="#Model-Selection" class="headerlink" title="Model Selection"></a>Model Selection</h2><p>我们仍然需要进行模型选择，使用Validation是一种很好的方案。</p><ol><li>Cross Validation<br>我们可以使用Cross Validation来选择模型，然而由于它不是连续的函数，从而难以优化！我们可以选择不同参数的组合来选择模型，选择Evc最小的模型。</li><li>Leave-One-Out CV</li><li>use #SV<br>SV的数量也很重要，然而这个问题也是难以优化的。一般来说SV越多，模型更复杂，也就更容易overfit，选择SV较少的！</li></ol><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习技法》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习技法》系列课程（四）&lt;/p&gt;
&lt;p&gt;本章将引入Soft-Margin SVM以解决overfit问题，提高对错误点的忍受程度！&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>19 Kernel Support Vector Machine</title>
    <link href="https://vhdsih.github.io/2018/10/22/mltech03/"/>
    <id>https://vhdsih.github.io/2018/10/22/mltech03/</id>
    <published>2018-10-22T08:30:54.000Z</published>
    <updated>2023-10-25T14:44:32.253Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习技法》系列课程（三）</p><p>在上一节我们学习了Dual SVM，它简化了非线性SVM的计算，但是实际上它的计算仍然依赖于特征变换后空间Z的复杂度，本章将引入Kernel Function来解决这一问题。</p><span id="more"></span><h2 id="Kernel-Trick"><a href="#Kernel-Trick" class="headerlink" title="Kernel Trick"></a>Kernel Trick</h2><p>我们的目标是令SVM彻底摆脱对Z空间复杂度的依赖，这件事我们实际上已经完成了一部分：</p><p><img src="1.png" alt="half-way done"> </p><p>我们通过引入对偶（Dual）SVM，使我们的最优化问题只包含N个α参数。然而我们在计算Qd矩阵，其每一个元素都需要计算Z空间中两个向量的内积，它的复杂度就会很高，因为其需要进行两个步骤：首先进行特征转换，将X空间中的向量转换到Z空间，其次，计算Z空间向量的内积。</p><p>我们考虑能不能将特征转换和计算乘积放到一起来简化计算，我们首先考虑2维转换后的向量内积，我们任取两个向量x，x‘：</p><p><img src="2.png" alt="2 transform + inner product"> </p><p>我们可以发现，一个特征转换后的向量的内积可能可以转换为原始空间向量的乘积问题，那么现在，由于我们无需进行特征转换就能得到原来需要的结果，其计算复杂度就会大大降低了！</p><p>我们将这种同时实现特征转换和向量内积的函数称为核函数（Kernel Function），上面我们已经求解，向二维空间进行特征变换的核函数是：</p><p><img src="3.png" alt="kernel function 2"> </p><p>我们可以将这个Kernel function带入到我们的Dual SVM中，从而可以求解qnm，b等：</p><p><img src="4.png" alt="gsvm"> </p><p>我们将这种方法称为Kernel trick：使用一个高效的kernel function来避免使用特征变换所带来的Z空间的复杂度！</p><p>当然，Kernel SVM仍然可以使用QP（二次规划）来求解：</p><p><img src="5.png" alt="qp for ksvm"> </p><p>此时的复杂度是O(N * N)，QP有N个参数和N + 1个限制条件，对于上面的3和4，他们的时间复杂度都是O(n)，n代表<br>SV的数目。</p><h2 id="Polynomial-Kernel"><a href="#Polynomial-Kernel" class="headerlink" title="Polynomial Kernel"></a>Polynomial Kernel</h2><p>我们已经引入了一个二次的核函数，然而，核函数并不唯一，我们可以对其进行缩放：</p><p><img src="6.png" alt="poly 2 kernel"> </p><p>尽管上述三种核函数都是二次核函数，能力是相同的，然而其所代表的空间变换不同，内积不同从而会有不同的SVM分类界面！而这几种中K2比较简单，很常用！</p><p><img src="7.png" alt="poly 2 kernel"> </p><p>上图给出了一个二次核函数的一般形式，它使用起来要比我们在上一章的要简单。然而其参数γ对分类结果起到很大的影响，下面我们看一看不同的γ对SVM有什么影响：</p><p><img src="8.png" alt="different 2 kernel f"> </p><p>随着γ的变换，我们的gsvm和sv也同时在变化，然而看起来我们却很难说哪一个gsvm更好。在这里我们需要注意的是，如果我们改变了kernel function，那么我们同时也改变了我们对margin（胖胖的分类界面）的定义！</p><p>当然，我们一直说的都是一个2维度的Kernel function，我们可以将其推广到q维空间变换：</p><p><img src="9.png" alt="q dim kernel f"> </p><p>我们的特征转换已经嵌入到上面各个核函数中的两个参数中了，我们使用这些多项式核函数可以避免Z空间的复杂度对计算的影响！我们将这些使用了多项式核函数的SVM称为多项式核函数。</p><p>现在我们看我们之前使用的线性SVM，实际上可以将其看做是Kernel SVM的一种特殊的情况：Linear Kernel。</p><p><img src="10.png" alt="linear kernel f"> </p><p>现在面对这么多核函数，那么该选择哪一个更好呢？依然还是线性优先（奥卡姆剃刀定律）！</p><h2 id="Gaussian-Kernel"><a href="#Gaussian-Kernel" class="headerlink" title="Gaussian Kernel"></a>Gaussian Kernel</h2><p>上面我们讨论的都是有限空间变换下的核函数，那么如果面对的是无限空间的变换呢？当然，我们仍然有办法。当然，直观上我们难以推断，所以我们使用逆推法来寻找一个包含无限维特征变换的核函数，为了简单起见，我们现在令我们的数据x是一个长度为1的向量：</p><p><img src="11.png" alt="when you face infinite dim"> </p><p>上面利用了泰勒展开式对exp(X)进行泰勒展开，从而推断出高斯函数中包含了一个无限维度的变换，所以，我们可以使用高斯核函数来解决无限维特征变换问题：</p><p><img src="12.png" alt="gaussian kernel"> </p><p>此时我们使用高斯核函数求解SVM的分类界面：</p><p><img src="13.png" alt="gsvm for gaussian"> </p><p>我们可以发现，实际上gsvm是由n个高斯函数线性组合而成，n是支撑向量SV的数码，同时，这些高斯函数的中心都是相对应的SV。我们也将高斯核函数称为Radial Basis Function<br>(RBF)。</p><p>需要注意的是高斯函数中参数的选择，我们选择不同的γ，我们的SVM结果最后差别很大：</p><p><img src="14.png" alt="gaussian para"> </p><p>大的γ可能会导致overfit，所以我们在选择参数上还是要小心！</p><p>现在，我们通过引入核函数，将特征转换和向量内积问题组合到了一起，此时我们能够大大提高计算效率，同时我们也能够节约存储空间；通过使用高斯核函数，对于无限维特征转换问题，我们也基本能够解决！</p><h2 id="Comparison-of-Kernels"><a href="#Comparison-of-Kernels" class="headerlink" title="Comparison of Kernels"></a>Comparison of Kernels</h2><p>现在我们比较不同的核函数：</p><p>线性核函数是最简单、快速、直观并容易解释的，但是前提条件是数据必须是线性可分的，否则我们不能使用它。</p><p>多项式核函数，相对于线性核函数，它有着更少的限制，它是由多项式组成的，通过改变多项式的幂次我们可以更加灵活的对其控制，然而它在计算上会有很大的难度，并且参数太多导致选择更困难。因此对于对于多项式核函数，可能选择较小的Q更好。</p><p><img src="15.png" alt="cons for poly k"> </p><p>高斯核函数，能力更强，能够得到复杂多样的边界，参数只有一个更容易选择，然而它在计算上比线性的要慢，并且由于不会计算w，所以难以解释，并且存在overfit的问题，但是它仍然是最受欢迎的核函数之一！</p><p>我们学习了上面三种核函数，当然还存在其他核函数！我们看看核函数实际的意义是什么：我们对X空间的特征进行特征变换，在Z空间计算二者的内积，在某种意义上，我们的核函数代表了两个向量的相似程度。但是任何计算相似度的方法都能够作为核函数吗，答案是否定的，作为核函数的充要条件是Mercer’s condition:</p><p><img src="16.png" alt="mercer"> </p><p>即：矩阵必须是对称的，其次K是半正定的！</p><p>如果我们想定义新的核函数，当然是可行的，但是却很难做到！</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习技法》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习技法》系列课程（三）&lt;/p&gt;
&lt;p&gt;在上一节我们学习了Dual SVM，它简化了非线性SVM的计算，但是实际上它的计算仍然依赖于特征变换后空间Z的复杂度，本章将引入Kernel Function来解决这一问题。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>18 Dual Support Vector Machine</title>
    <link href="https://vhdsih.github.io/2018/10/21/mltech02/"/>
    <id>https://vhdsih.github.io/2018/10/21/mltech02/</id>
    <published>2018-10-21T05:00:44.000Z</published>
    <updated>2023-10-25T14:44:32.216Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习技法》系列课程（二）</p><p>本章学习有关于对偶SVM的相关内容。</p><span id="more"></span><h2 id="Motivation-of-Dual-SVM"><a href="#Motivation-of-Dual-SVM" class="headerlink" title="Motivation of Dual SVM"></a>Motivation of Dual SVM</h2><p>我们为什么要引入对偶形式的SVM？<br>我们在讲解线性SVM相关的内容的最后，对于处理非线性数据的SVM提出了这样的方法：通过特征变换，将非线性的数据变换到线性的Z空间，我们在Z空间中使用线性SVM。</p><p>然而，如果我们使用这样的方案，意味着我们的二次规划在处理问题时需要处理的条件是N变量就会有d’ + 1，这是Z空间的VC维度，如果d’太大了或者近乎无限，我们还能解决问题吗？</p><p>也因此，我们希望能够找到一种新的解决方法，将原有的SVM变换为一个等同的SVM，令这个SVM不再依赖于Z空间的d’，这就引出了我们本章所要讲述的内容：对偶SVM(Dual SVM)。</p><p>当然，这个变换中包含了复杂的数学内容，我们在这里只会介绍一些必要内容。</p><p>首先，我们做出这个变换所使用的关键工具是拉格朗日乘数法（Lagrange Multipliers）。对于这个方法我们并不陌生，除了在本科阶段的高等数学课堂上我们见过它的身影之外，在“机器学习基石”系列内容中，我们在介绍正则化（Regularization）时也使用了这个方法：我们在wTw &lt;= C这个条件的限制下，最小化Ein(w)，我们将其使用拉格朗日乘数法将其等价为最小化Eaug：</p><p><img src="1.png" alt="regularization"> </p><p>同样，我们也用同样的方法对对偶SVM进行处理，我们将N个条件转化为N个项的和，每一项的系数是α（SVM相关的文献通常是α，这与正则化不同，后者使用λ）。下图是原始的SVM问题：</p><p><img src="2.png" alt="origin"> </p><p>我们使用拉格朗日乘数法：</p><p><img src="3.png" alt="lagrange"> </p><p>我们的对偶SVM所要处理的问题就是：</p><p><img src="4.png" alt="dual svm"> </p><p>当然，我们需要证明这个新的方案和原始的是相同的，我们考虑两个情况：</p><ol><li>对于任意不满足约束条件的w和b（也就是yn(wTzn + b) &lt; 1），此时，我们如果最大化拉格朗日部分，其中(1 - yn(wTzn + b)) &gt; 0，αn &gt; 0，所以此时最大化，则此时趋近于无穷大。因为Dual SVM还有min操作，从而这种情况就会被过滤掉。</li><li>对于任意满足约束条件的w和b，此时(yn(wTzn + b)) &lt; 0，如果取max，则α = 0，此时最终的结果就是min(1/2 * wTw)，这和原始问题是相同的。</li></ol><p>从而，我们确定Dual SVM和原始的SVM是等价的！</p><h2 id="Lagrange-Dual-SVM"><a href="#Lagrange-Dual-SVM" class="headerlink" title="Lagrange Dual SVM"></a>Lagrange Dual SVM</h2><p>首先，我们考虑下面的不等式是成立的：</p><p><img src="5.png" alt="for fixed a"> </p><p>其次我们考虑另外一个不等式：</p><p><img src="6.png" alt="best"> </p><p>注意到此时在不等式右侧我们已经将max和min对调，我们将上述不等式右侧作为Dual SVM的下界，我们接下来针对其进行求解。在此之前我们先了解弱对偶和强对偶的概念:</p><p>对于上述表达式中，如果是&gt;=，就是一个弱对偶问题。如果是=则是一个强对偶，如果这个等号成立，需要满足三个条件：</p><ol><li>左侧函数是凸的（convex primal）</li><li>函数是有解的（feasible primal， 特征变换后线性可分）</li><li>条件是线性的（linear constrains）</li></ol><p>因为二次规划问题满足上面三个条件，所以我们的Dual SVM的&gt;=就可以变为=，即存在(b, w, a)令表达式两边同时达到最优！</p><p>现在我们优化我们的对偶问题：</p><p><img src="7.png" alt="solving"> </p><p>根据对lagrange求最小值，我们可以使用梯度下降法，而最下值梯度为0，所以化简主要有这几步：</p><ol><li>对b求偏导数为0。</li><li>对w求偏导数为0。</li></ol><p>通过代换我们可以化简为：</p><p><img src="8.png" alt="no title"> </p><p>此时SVM的最优化仅仅和α有关！这些最优化的条件称为KKT（Karush-Kuhn-Tucker）。我们将使用<br>KKT通过最优的α来求解b和w。</p><h2 id="Solving-Dual-SVM"><a href="#Solving-Dual-SVM" class="headerlink" title="Solving Dual SVM"></a>Solving Dual SVM</h2><p>首先我们将最大化问题转换为最小化问题：</p><p><img src="10.png" alt="min"> </p><p>我们仍然利用QP(二次规划)来解决Dual SVM问题。</p><p><img src="9.png" alt="qp for dual svm"> </p><p>需要注意的是如果N很大，此时可能求解Qn需要很大的内存（此时是稠密矩阵，dense），因此需要一些特别的解决方案，比如不存储整个矩阵，或者利用一些特殊的条件来加速求解。</p><p>我们利用KKT条件来求解b和w：</p><p><img src="11.png" alt="kkt for w and b"> </p><p>上面说明，如果我们获得了最优的α，那么我们也能容易获得最优的w。而对于b的计算，我们只能获得一个范围。然而，我们注意上图中最下面的等式，此时如果αn &gt; 0 ⇒ b = yn − wTzn，此时这些点就是支撑向量，因为它们在胖胖线的边界上。</p><h2 id="Messages-Behind-Dual-SVM"><a href="#Messages-Behind-Dual-SVM" class="headerlink" title="Messages Behind Dual SVM"></a>Messages Behind Dual SVM</h2><p>我们回顾在上一讲中对于支撑向量的描述，我们说把位于边界线上的点称为支撑向量的候选者，而其他的点是不需要的。而如果αn &gt; 0，此时的点一定落在边界上，所以它们一定是支撑向量（不是候选者了）。也就是说Support Vector是αn &gt; 0时的点，它是Support Vector Candidates的一个子集。而SVM在学习这个最胖的分类界面时，只需要识别出这些支撑向量即可（使用Dual SVM）。这和PLA很类似，它是从错误的点学习分类界面，而Dual SVM从SV中学习。</p><p>下面是两种SVM的一个总结：</p><p><img src="12.png" alt="summary"> </p><p>二者最终都是要找到一个最胖的超平面。</p><p>我们在本节中使用Dual SVM的方法，避免了Z空间的复杂度对计算的影响。然而，实际上这种影响我们并没有完全消除，它实际上在我们计算qmn过程中就隐藏在计算的过程中了，那么该怎么彻底消除它所带来的影响呢，这是接下来的课程要研究的内容(kernal function)！</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习技法》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习技法》系列课程（二）&lt;/p&gt;
&lt;p&gt;本章学习有关于对偶SVM的相关内容。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>17 Linear Support Vector Machine</title>
    <link href="https://vhdsih.github.io/2018/10/19/mltech01/"/>
    <id>https://vhdsih.github.io/2018/10/19/mltech01/</id>
    <published>2018-10-19T11:38:48.000Z</published>
    <updated>2023-10-25T14:44:32.266Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习技法》系列课程（一）</p><p>从本节开始学习SVM！</p><span id="more"></span><h2 id="Large-Margin-Separation-Hyperplane"><a href="#Large-Margin-Separation-Hyperplane" class="headerlink" title="Large-Margin Separation Hyperplane"></a>Large-Margin Separation Hyperplane</h2><p>我们首先回顾已经学过的PLA和Pocket算法，它们都是找到一条直线（或超平面）将数据点按照类别分开。但是经过PLA或者Pocket得到的目标可能有很多，比如：</p><p><img src="1.png" alt="many possible"> </p><p>就像上图那样，每一条直线都是有可能得到的，并且都是分类正确而且满足VC Bound。然而，如果让我们来直观地做出选择，第三图得到的分类直线才是最好的，因为这条直线距离两个种类的距离很平均，可能对于新的数据会具备更好的泛化能力。</p><p>为什么说最右边的直线表现最好呢，我们可以有两个角度来解释：<br>首先我们可以假定在获得每个数据是时都可能存在偏差，也就是我们得到的数据可能在真实的数据的附近，如图：</p><p><img src="2.png" alt="noice"> </p><p>那么图三能够容忍更多的噪音的发生，那么它的鲁棒性也就更好。相反，对于前两张图，很容易出现overfitting问题。</p><p>其次，我们从分类线（超平面）来考虑这个问题。如果我们的最终结果的鲁棒性越好，那么也就说明我们得到的线（超平面）越胖：</p><p><img src="3.png" alt="fat line"> </p><p>所谓的越胖，也就是最近的数据点距离直线的距离越大。</p><p>因此，我们如果想要选出最好的直线（超平面），就需要在满足分类需要的条件下，让所有点距离其的距离(margin(w))最大化：</p><p><img src="4.png" alt="result"> </p><h2 id="Standard-Large-Margin-Problem"><a href="#Standard-Large-Margin-Problem" class="headerlink" title="Standard Large-Margin Problem"></a>Standard Large-Margin Problem</h2><p>既然条件之一是距离最大化，那么我们该怎样求解距离问题呢？</p><p>首先，我们将变量使用矩阵表示，不同于我们之前的习惯，我们需要将w0放在外面作为b，同时也忽略了x0：</p><p><img src="5.png" alt="how to get distance"> </p><p>此时，现在我们的假设空间变为：</p><p><img src="6.png" alt="hypothesis"> </p><p>此时我们的分类线（超平面）满足wTx + b = 0。我们需要任意数据点x到该平面的距离，下面是我们的求解方法：</p><p>![how to calculate the distance]](7.png) </p><p>首先，我们任取分类面上两点x’和x’’，带入平面方程我们有：</p><ol><li>wTx’ = -b。</li><li>wTx’’ = -b。</li></ol><p>二者化简有：wT(x’’ - x’) = 0。说明此时wT垂直于分类面。所以，如果我们需要获得平面外一点到平面的距离，我们需要做一个投影运算，即将向量(x - x’)投影到垂直于平面的方向，也就是w的方向。</p><p>distance = project(x - x’) to DIRw</p><p>化简得到：</p><div align> ![distance](8.png) <p>需要注意的是我们现在使用的超平面是一个分类界面，那么它就会附带更多的一些属性。其中之一是如果用每个点xn对应的类别yn乘以(wTxn + b)，那么结果是大于0的：</p><div align> ![rule](9.png) <p>那么此时我们可以将距离表达式中的绝对值符号去掉了：</p><div align> ![distance format](10.png) <p>现在我们的目标变成了如下的形式：</p><p><img src="11.png" alt="goal 1"> </p><p>然而，这个表达依旧很复杂，难以求解，我们继续化简。我们对一个分类面的表达式进行化简，我们知道，对于一个等式来说，方程两边乘以相同的数仍然是成立的，那么，我们可以放缩：</p><p><img src="12.png" alt="scaling"> </p><p>也就是让距离最近的点满足其结果为1。此时我们所需要的margin(b, w)就变味了1 / ||w||</p><p>那么我们现在的目标：</p><p><img src="13.png" alt="goal 2"> </p><p>然而求解依旧复杂，我们继续考虑放缩，我们可以考虑将条件进一步放宽一些，然而我们仍能够证明依然存在最近的点满足等于1。此时，我们将上一个目标变形（将最大化问题变为最小化，即变为倒数，同时乘以1/2为了方便后续的计算，同时变为平方，用来去掉距离的根号），得到了最终的目标：</p><p><img src="14.png" alt="goal final"> </p><h2 id="Support-Vector-Machine"><a href="#Support-Vector-Machine" class="headerlink" title="Support Vector Machine"></a>Support Vector Machine</h2><p>上一节中我们得到的表达式我们称之为标准问题。当我们使用其求解一个分类问题时，我们得到的最终的超平面，此时就是SVM。<br>那么什么是支持向量机（SVM）？</p><p><img src="15.png" alt="svm"> </p><p>如上图所示，我们在寻找最胖的分类界面时，需要被方框圈住的点，而没有被圈住的点我们并不需要。我们把这些被圈住的点称为支撑向量（候选者）。而支持向量机（SVM）就是通过这些支撑向量候选者，学习到最胖的超平面。</p><p>尽管解决SVM问题并不容易，我们不能利用Gradient Descent等方法，但是比较幸运的是在数学上有类似问题的解决方法：二次规划（quadratic programming）。</p><p>然而我们需要对其做一些变换，使其满足Quadratic Programming的标准形式，后者的标准形式如下：</p><p><img src="16.png" alt="qp"> </p><p>我们需要知道u, Q, p等，通过变换，有：</p><p><img src="17.png" alt="value convert"> </p><p>因此，如果我们需要解决线性SVM问题，需要以下三步：</p><p><img src="18.png" alt="solution"> </p><p>如果是非线性的，需要做空间变换，将点变换到z空间。</p><h2 id="Reasons-Behind-Large-Margin-Hyperplane"><a href="#Reasons-Behind-Large-Margin-Hyperplane" class="headerlink" title="Reasons Behind Large-Margin Hyperplane"></a>Reasons Behind Large-Margin Hyperplane</h2><p>为什么要选择最胖(Large Margin)的分类界面呢？我们从正则化和VC两个方面来看这个问题。</p><p>首先我们对比SVM和Regularization：</p><p><img src="19.png" alt="compare svm and reg"> </p><p>我们可以看到二者很类似，正则化是最小化Ein而其限制条件是wTw &lt; C；而SVM是最小化wTw，它的限制条件其实也就是Ein=0。二者实际的作用类似，效果相近，所以SVM也可以说是一种weight-decay regularization!</p><p>另一方面，我们从VC维度来看这个问题。如果我们选择最胖的线，那么它能够shatter的点也就越少，从而VC维度也就会比原来的PLA更低，从而就可能有更好的泛化效果。</p><p>我们考虑演算法的VC维度（之前的VC Dimension是假设空间的Dvc，其和数据无关，而演算法的Dvc和数据有关）：</p><p><img src="20.png" alt="ball"> </p><p>在圆上有三个点。如果我们线的胖度为0时，实际就是PLA算法，此时dvc=3<br>如果胖度大于 √3 / 2那么不能找到一条线来shatter3个点。</p><p>使用Large Margin的分类面可以降低模型的复杂度，因为dvc更小，具备更好的泛化能力，同时，边界也比较简单，因为我们可能有更好的Ein。</p><p>此时如果对于非线性问题，我们的SVM结合特征转换，可能能够得到更好的结果！</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习技法》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习技法》系列课程（一）&lt;/p&gt;
&lt;p&gt;从本节开始学习SVM！&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>16 Three Learning Principles</title>
    <link href="https://vhdsih.github.io/2018/10/18/mlfound16/"/>
    <id>https://vhdsih.github.io/2018/10/18/mlfound16/</id>
    <published>2018-10-18T12:43:29.000Z</published>
    <updated>2023-10-25T14:44:32.257Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（十六）</p><p>基石最后一课，技法见！</p><span id="more"></span><!-- toc --><ul><li><a href="#occam-s-razor">Occam’s Razor</a></li><li><a href="#sampling-bias">Sampling Bias</a></li><li><a href="#data-snooping">Data Snooping</a></li><li><a href="#power-of-three">Power of Three</a></li></ul><!-- tocstop --><h2 id="Occam’s-Razor"><a href="#Occam’s-Razor" class="headerlink" title="Occam’s Razor"></a>Occam’s Razor</h2><blockquote><p>entia non sunt multiplicanda praeter necessitatem (entities must not be multiplied beyond necessity) — William of Occam (1287-1347)</p></blockquote><blockquote><p>如无必要，勿增实体！</p></blockquote><p>奥卡姆剃刀定律告诉我们能够fit数据的最简单的模型是最好的。那么什么是简单？其有两方面的解释：</p><ol><li>Hypothesis h是简单的，也就是它有较少的参数。</li><li>Hypothesis Set H是简单的，其包含的hypothese较少，模型的复杂度更低。</li></ol><p>简单的更好，我们可以从数学上进行证明（比如VC理论）。同时，我们也可一这样思考：一个更简单的H，它的成长函数更小，也就从而从概率上来讲就很难完美地fit我们的数据。反过来说，如果我们真的找到了能够fit数据的h，那么往往这个h就很有意义。</p><h2 id="Sampling-Bias"><a href="#Sampling-Bias" class="headerlink" title="Sampling Bias"></a>Sampling Bias</h2><p>解决Learning问题过程中要注意数据抽样的分布。如果我们的数据在抽样存在偏差，那么我们学习到的结果也就会存在偏差，从而导致学习的效果很差！</p><p>因为真实的数据的分布是P1(x|y)，但是我们学习（或者在模型选择过程）是在P2(x|y)上完成的，P1 != P2，那么我们的VC保证也就失败了，导致Ein和Eout相差很大，学习失败！</p><p>同时，我们也要关心真实的数据应用场景，我们未必一定采用随机采样才是最好的方法，要根据实际的测试数据的分布来决定！</p><h2 id="Data-Snooping"><a href="#Data-Snooping" class="headerlink" title="Data Snooping"></a>Data Snooping</h2><p>我们在Learning过程中不能”偷看数据”，如果我们这样做了，就不能保证VC是安全的。一方面，我们训练模型和选择模型过程不能使用测试集，否则虽然结果看起来很好，世界上测试结果根本没有意义。另一方面，如果针对相同的问题，前人做出了结果，但是比做的更好，在这个过程中实际上我们在一定程度上也偷看了数据，因为我们”站在了巨人的肩膀上”了！<br>实际上这个问题很难避免，这里有一些建议：</p><ol><li>完全不用测试数据。</li><li>使用验证集，但是也要小心使用。</li><li>avoid making modeling decision by data，尽量使用我们的知识和常识来选择模型。</li><li>保持怀疑。就是说时刻保持对别人的论文或者研究成果保持警惕与怀疑，要通过自己的研究与测试来进行模型选择，这样才能得到比较正确的结论。</li></ol><h2 id="Power-of-Three"><a href="#Power-of-Three" class="headerlink" title="Power of Three"></a>Power of Three</h2><p>本课程结束，这里是一些总结：</p><p>本课程介绍了3个相关领域：</p><ol><li>数据挖掘。</li><li>AI。</li><li>统计学。</li></ol><p>介绍了3种理论方法：</p><ol><li>Hoeffing：通常用于验证和测试假说。</li><li>Multi-Bin Hoeffding：用来验证多个Hypotheses。</li><li>VC理论：用于training，为Ein约等于Eout给了理论保证。</li></ol><p>介绍了3中模型：</p><ol><li>PLA和Pocket。</li><li>线性回归。</li><li>逻辑回归。</li></ol><p><img src="1.png" alt="models"> </p><p>介绍了三种工具：</p><ol><li>特征转换：使用高维空间使Ein更小，但是会导致vc维度变大，模型复杂度增大。</li><li>正则化（Regularization），用来降低模型的复杂度，使其实际的vc维度要更低，不过会导致Ein增大。</li><li>Validation。</li></ol><p>还有今天将的3个技巧和准则：</p><ol><li>奥卡姆剃刀。</li><li>抽样偏差。</li><li>Data Snooping。</li></ol><p>接下来，还有更多的内容要去学习，加油！</p><p><img src="2.png" alt="future"> </p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（十六）&lt;/p&gt;
&lt;p&gt;基石最后一课，技法见！&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>15 Validation</title>
    <link href="https://vhdsih.github.io/2018/10/17/mlfound15/"/>
    <id>https://vhdsih.github.io/2018/10/17/mlfound15/</id>
    <published>2018-10-17T11:19:57.000Z</published>
    <updated>2023-10-25T14:44:32.254Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（十五）</p><p>本章的主要内容是应对Overfitting的另一种方法：Validation！</p><span id="more"></span><h2 id="Model-Selection-Problem"><a href="#Model-Selection-Problem" class="headerlink" title="Model Selection Problem"></a>Model Selection Problem</h2><p>我们已经遇过了很多模型选择问题：包括使用什么学习算法（PLA，LR，…），迭代的次数，学习率的选择，特征转换模型的选择，是否添加正则化以及添加什么样的正则化和正则化的系数选择等。我们所作出的所有的选择，最终都是为了得到一个好的假设g。</p><p>那么我们该怎样选择一个模型呢？我们的期望是选择Eout(g)很低的g，然而我们却不知道Eout(g)。<br>那么我们能不能肉眼来看呢？肯定是不能的，一方面人难以想象高维空间，另一方面，人会在选择过程中增加模型复杂度的偏差程度，这在第十二章中我们有过详细的讨论。<br>如果我们根据Ein选择呢？答案也是否定的，更复杂的模型肯定比简单的模型在拟合已有数据这件事上做的更好，Ein也就更低。然而更复杂的模型的泛化能力会更差，这就导致了Ein更小的模型Eout很有可能更大。<br>我们可以用测试集来选择模型，选择Etest好的模型能够得到好的效果，我们可以根据finite-bin Hoeffding来确保这件事是正确的：</p><p><img src="1.png" alt="Etest"> </p><p>也就是说如果我们使用训练数据来选择模型，相当于老师用以前来做过的题作为考试题，不能体现学生的学习效果。我们用新的数据来测试系统，就不存在这样的问题。</p><p>然而我们一般不能得到测试数据，所以这件事又是难以实现的。</p><h2 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h2><p>既然如此，我们可以从已有的数据中随机抽取一部分作为选择模型的数据，我们将它称为Validation Set（不能参与训练），而剩下的作为训练集。当然，抽取的Dval必须仍然满足原有数据的分布（iid，也就是说需要随机选择）:</p><p><img src="2.png" alt="validation"> </p><p>此时，通过训练集训练得到的gm的Eout和Eval满足：</p><p><img src="3.png" alt="eval and eout"> </p><p>根据我们之前的学习可知，当数据量N越大时，Eout越小，那么我们可以知道在整体数据获得的g的Eout、训练集和验证集的Eout的关系：</p><p><img src="4.png" alt="relation"> </p><p>选择在Eval表现最好的模型我们能得到Eout表现比较好的模型。</p><p>那么验证集的占比应该是多少呢？通常设置为N / 5，过大过小都不好。</p><h2 id="Leave-One-Out-Cross-Validation"><a href="#Leave-One-Out-Cross-Validation" class="headerlink" title="Leave-One-Out Cross Validation"></a>Leave-One-Out Cross Validation</h2><p>留一交叉验证法，每次取一个作为验证，其余作为训练，直到所有N个数据均验证后，对误差求平均。<br>对计算要求高，稳定性不好。</p><h2 id="V-Fold-Cross-Validation"><a href="#V-Fold-Cross-Validation" class="headerlink" title="V-Fold Cross Validation"></a>V-Fold Cross Validation</h2><p>K折交叉验证。<br>将N个训练数据分为K份，和留一交叉验证方法相同，降低计算复杂性，提高稳定性。留一交叉验证可以看做是它的一个特例！</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（十五）&lt;/p&gt;
&lt;p&gt;本章的主要内容是应对Overfitting的另一种方法：Validation！&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>14 Regularization</title>
    <link href="https://vhdsih.github.io/2018/10/16/mlfound14/"/>
    <id>https://vhdsih.github.io/2018/10/16/mlfound14/</id>
    <published>2018-10-16T08:16:39.000Z</published>
    <updated>2023-10-25T14:44:32.216Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（十四）</p><p>本章学习应对Overfitting问题的一种方法：正则化（Regularization）。</p><span id="more"></span><h2 id="Regularized-Hypothesis-Set"><a href="#Regularized-Hypothesis-Set" class="headerlink" title="Regularized Hypothesis Set"></a>Regularized Hypothesis Set</h2><p>当我们在Leraning中，如果使用了能力更强的模型，或者数据中包含一些噪音（stochastic or deterministic noise），或者训练数据的数量太少的时候，Overfitting就会发生，如图，其中就是试图使用一个高次的模型去fit一个2次的目标函数，尽管我们的数据点都在预测的模型曲线上，然而它与目标函数的距离还是很大：</p><p><img src="1.png" alt="overfit"> </p><p>我们要解决overfitting问题，就是要把上面的红色曲线修正为下图这样：</p><p><img src="2.png" alt="regularized fit"> </p><p>我们的一个想法是将我们所使用的高次的假设空间一步步移动到低次的假设空间，例如从10次的假设空间H10‘step back to’H2。那么该怎样做呢？</p><p>我们已经知道，低次的假设空间是高次的一个子集。那么如果想要将高次的变为低次的，只需要将假设函数中对应的高次的系数变为0即可：</p><p><img src="3.png" alt="constraint"> </p><p>看到这里也许你会有一些疑问，为什么不直接使用低次的假设空间H2，反而绕来绕去，让H10中大于等于3次幂的项的系数等于0呢？其实这只是为了方便后面的论证而已！</p><p>我们继续来看这个问题，前面我们说让高次（大于等于3次幂）的项的系数变为0，我们能够从H10回到H2，现在我们假设我们有这样一个假设空间，我们只需要保证其中系数不等于0的幂次的数目小于等于3。或者说，之前我们对0次，1次，2次项的系数不做要求，让其他项的系数统统为0，现在我们不为零的项可能是1，可能是5，也可能是10，只要总数小于3就行了。</p><p><img src="4.png" alt="h2&#39;"> </p><p>此时我们可以确定的是，我们之前用的假设空间H2一定是现在这个假设空间H2’的一个子集，并且相对于H10来说，它发生Overfitting的风险要更小！</p><p>然而，H2’这个假设空间看起来效果很好，但是解决它却是NP Hard的问题，这仍然很糟糕，那么我们继续思考，能不能将其中的限制再放宽（softer）一些呢？</p><p>现在，我们令一个新的假设空间为H(C)，它仍然是基于H10，但是与之前所有的假设不同的是，我们不强制让某些项的系数为0，反而来计算所有项的平方和，令其小于等于C：</p><p><img src="5.png" alt="H(C)"> </p><p>此时，H(C)与H2’是有一定重合的，当并不完全相同。当我们对C取不同的数值时，我们能够保证这样一件事：</p><p><img src="6.png" alt="status"> </p><p>也就是当我们的C取很小的数值时，我们就相当于对H10添加了很大的限制，如果很大，甚至到无穷，那么就说明我们对H10添加了很小的限制，甚至没有限制！</p><p>我们将这个H(C)称为regularized hypothesis，此时如果我们能够找到一个很好的权重向量解决这个问题，我们将这个权重向量称为Wreg</p><h2 id="Weight-Decay-Regularization"><a href="#Weight-Decay-Regularization" class="headerlink" title="Weight Decay Regularization"></a>Weight Decay Regularization</h2><p>我们首先将Regularized Regression用矩阵表示：</p><p><img src="7.png" alt="Matrix Form"> </p><p>其Ein(w)表示如图，其约束条件是各个weihgt的平方和小于C，实际上，如果我们将所有的weight看成是一个w向量，那么就可以看作是wTw小于C！</p><p>从几何角度来看，我们理解为wTw是高维空间的一个球体内部所包含的区域，其半径为C的平方根。我们解决这个问题，可以使用拉格朗日乘数法(Lagrange Multiplier)，也就是，我们在wTw &lt;= C的条件下，最小化Ein(w)：</p><p><img src="8.png" alt="target"> </p><p>现在我们考虑这个优化过程，我们使用下面的图来说明这个问题（注意，蓝色线和红色线其实表示的是球体，这里为了可视化而简化了）：</p><p><img src="9.png" alt="example"> </p><p>首先，我们使用梯度下降的方法来寻找Ein(w)最小的时候w的值。就像上图那样，如果我们不加任何约束条件，我们找到的最终的结果是Wlin（在蓝色圆中心的黑点）。然而，我们现在能够搜索的w是受限的，我们只能在红色的球壳包围的区域寻找这个w，在红色球壳上的任何一个w，都满足wTw = C。那么我们从球壳内部任意点开始进行梯度下降，如果我们到了球壳的边缘，就不能继续沿着球体的法线方向走了，否则将不满足约束条件。我们只有沿着此时负梯度方向沿着垂直于球体法线的方向走。如果最后负梯度方向和法线方向平行，则说明此时找到了目标的规则化权重Wreg。</p><p>概况来说，求解这个问题，寻找到和负梯度方向平行的Wreg才是最终的结果，我们可以用数学方法来表达：</p><p><img src="10.png" alt="solution for wreg"> </p><p>其中参数λ &gt; 0，添加的常数2是为了后面的计算简便（公式表明了wreg和负梯度方向相同）。</p><p>那么现在我们想办法来解这个方程，从而求得Wreg。<br>如果λ&gt;0是成立的，那么实际上这只是一个线性方程，未知数只有一个Wreg：</p><p><img src="11.png" alt="solution"> </p><p>从另一个角度来考虑，如果λ&gt;0，我们解这个方程，我们只需要对其积分即可，也就是说，我们只需要求解下面这个表达式最小化即可：</p><p><img src="12.png" alt="aug"> </p><p>这两个表达可以通过积分求导变换而来！所以现在通过最小化Eaug(w)(λ &gt;= 0, 注意是可以等于0的，等于0相当于没有添加正则化项)来求得Wreg，这要比去最小化带着常数C的Ein要有效！</p><p>然而，λ的值又该怎么办呢？我们先代入不同的数值来看一看在本章最开始的例子的表现如何：</p><p><img src="13.png" alt="different value"> </p><p>可以看到，随着λ的增大，我们的模型从Overfitting逐渐变为Underfitting。我们的w的维度更短，相当于使用了更小的C(对于H(C)而言)。</p><p>然而我们忽略了一个问题，对于我们一直所说的polynomial transform，如果我们的x很小，在-1到1之间，那么如果x的次数变高之后，得到的数值就会非常小，那么我们就需要更大的w。所以为了解决这个问题，我们需要选择一些正交的项（Legendre Polynomials）作为基底：</p><p><img src="14.png" alt="legendre"> </p><h2 id="Regularization-and-VC-Theory"><a href="#Regularization-and-VC-Theory" class="headerlink" title="Regularization and VC Theory"></a>Regularization and VC Theory</h2><p>现在我们来看看Regularization和我们之前学习过的VC Bound有什么关系。</p><p><img src="15.png" alt="VC"> </p><p>我们的原始问题是要最小化带有常数C的Ein，然而我们偷懒只求解了Eaug，其是λ&gt;=0的情况。对于我们的原始问题，实际上它对应了VC的一个Guarantee：就是Eout要小于等于Ein和Ω(H(C))的和。</p><p>我们求解Eaug，实际上就在间接地把VC Bound做好！但是实际上我们在求解时并没有真地限制在H(C)上，我们还是考虑了所有的w（从某种角度来说），只是最后我们使用了w的一小部分来看看VC的Guarantee是什么。</p><p>Augmented Error和VC Bound存在一些异同。</p><p><img src="16.png" alt="vcandaug"> </p><p>对于regularizer wTw来说，其代表了一个hypothesis有多复杂，而Ω(H)则表示了一整个Hypothesis Set的复杂度。VC和Augment Error做的事情不太一样，但是他们都在计算某件事情的复杂性。<br>如果单一的Hypothesis的复杂度和整个Hypothesis Set的复杂度差不多，或者说前者能够表示后者，那么也就说明Eaug可以使VC Bound中Eout和Ein很接近。</p><p>在以前，我们将Ein做好来保证Eout的效果，现在我们通过做好Eaug来做好Eout，而且，它比Ein要更擅长这件事。</p><p>另一个角度是这样：</p><p><img src="17.png" alt="effective vc d"> </p><p>我们看Eaug，要知道模型的复杂度到底是多少，那么因为所有的w都是可以选的，所以理论上dvc(H) = d + 1（z空间的自由度）。但是我们只需要在H(C)里选，所以代价只有dvc(H(C))这么大。</p><p>对于原有的假设空间H，它的VC Dimension很大，但是通过正则化，我们能够将其复杂度限制在effective VC dimension这么多，而且有可能它会比原来小。</p><h2 id="General-Regularizers"><a href="#General-Regularizers" class="headerlink" title="General Regularizers"></a>General Regularizers</h2><p>我们希望将Regularizer一般化，一个好的regularizers应该有这样的特性：</p><ol><li>和目标函数有关。</li><li>能够选出更平滑更简单的。</li><li>容易获得最优化结果。</li></ol><p>我们不用担心regularizers会带来坏的结果，因为λ可以等于0，此时和没加正则化的效果是相同的，也因为有这个保证，我们的模型不会更差。<br>在这里有两个regularizer：</p><ol><li>sparsity(L1) regularizer，是所有的权重绝对值的和，是稀疏的，可能有很多0，但是获得最优解可能比较困难。如果我们需要稀疏的解决方法，L1是有用的。</li><li>weight-decay(L2) regularizer，是所有权重的平方和，容易优化。</li></ol><p>最后看一看noise对regularization的λ的选择以及Eout的关系：<br><img src="18.png" alt="optimal"> </p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（十四）&lt;/p&gt;
&lt;p&gt;本章学习应对Overfitting问题的一种方法：正则化（Regularization）。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>13 Hazard of Overfitting</title>
    <link href="https://vhdsih.github.io/2018/10/15/mlfound13/"/>
    <id>https://vhdsih.github.io/2018/10/15/mlfound13/</id>
    <published>2018-10-15T00:59:10.000Z</published>
    <updated>2023-10-25T14:44:32.266Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（十三）</p><p>今天我们学习什么是过拟合，它有什么危险以及该怎样处理过拟合！</p><span id="more"></span><h2 id="What-is-Overfitting"><a href="#What-is-Overfitting" class="headerlink" title="What is Overfitting"></a>What is Overfitting</h2><p>我们首先从一个例子出发。想象我们在二维平面上有5个数据点，我们需要根据这些数据来学习一个Regression问题。其中，每个点的y都是根据targert f产生的（可能会添加一些噪音），也就是说我们想要学习的线是蓝色的线：</p><p><img src="1.png" alt="bad generalization"> </p><p>我们使用的方法是学习Z空间中的一条直线，并试图让这些数据点落在直线上。然而我们最终可能学习到的是一条4次曲线，它恰好能让所有的点都落在z空间的直线上，此时Ein为0。然而，明显的是Eout必然很大，这就说明我们学习到的模型泛化能力很差（bad generalization）！</p><p><img src="2.png" alt="overfitting"> </p><p>就像上图那样，如果我们学习的模型的维度很高，远远大于dvc，那么此时学到的就是bad generalization！从dvc=d*vc开始，向右边移动，此时Ein越来越小但是Eout越来越大，此时就是过拟合(Overfitting)，向左边移动，可以称为underfitting！</p><p>我们将Ein很小但是Eout很大称为有较差的泛化能力（bad generalization）。对于Ein逐渐变低，Eout逐渐变高的这个过程，称为Overfitting！</p><p>对于Overfitting，我们做一个形象的比喻：将其比喻开车出了车祸，出现了这个问题的原因：</p><ol><li>车开的太快，油门踩的太重：使用了自由度更大的模型，dvc太大，Ein可以更小，但是模型复杂度更高，难以做到Ein和Eout接近。</li><li>路不是很平：数据中包含噪音。</li><li>油不够了：数据太少。</li></ol><h2 id="The-Role-of-Noise-and-Data-Size"><a href="#The-Role-of-Noise-and-Data-Size" class="headerlink" title="The Role of Noise and Data Size"></a>The Role of Noise and Data Size</h2><p>现在我们举一个例子：例子一是使用一个10次target function生产的一些数据，然后添加一些Noise，例子二是一个50次的target function生产的一些数据，不加噪音：</p><p><img src="3.png" alt="case study"> </p><p>我们看一看从二次的假设空间到10次的假设空间进行学习会发生什么？</p><p><img src="4.png" alt="result"> </p><p>很明显，两个例子的Learning在从g2到g10的过程都发生了overfitting！</p><p>我们从Learning结果中发现，尽管我们知道第一个例子的目标函数是10次多项式，然而我们的结果却是10次的Learning Model做的很糟糕，相反2次的却做的比较好（Eout更好）！</p><p>我们重新看一看学习2次和10次的Learning Curves，看看我们能发现什么：</p><p><img src="5.png" alt="curves revisited"> </p><p>我们发现只有在数据量非常大的时候，10次的Learning Model才能获得好的Eout，相反对于2次多项式模型，获得较好的Eout所需要的数据量并不那么过分！</p><p>我们比较这两张图，可以看到Ein一定是高次的更低，但是如果我们没有足够多的数据，一般不能选择高次的Learning Model！</p><p>那么对于没有Noise呢，看起来好像还是g2做的更好！但是此时真的没有Noise吗？实际上当我们学习的东西很复杂的时候，这个复杂度也会造成Noise。就像用50次的target function生成的数据，我们使用更低次的Learning Model去fit，那么这二者复杂度之间的差异将会带来Noise！</p><h2 id="Deterministic-Noise"><a href="#Deterministic-Noise" class="headerlink" title="Deterministic Noise"></a>Deterministic Noise</h2><p>我们可以通过实验来探讨我们使用的模型复杂度、数据的噪音和数据的数量和Overfit Level有什么关系，现在我们直接来看实验结果：</p><p><img src="6.png" alt="result"> </p><p>对于第一张图，我们模型的复杂度固定为20次，横轴是数据量N，纵轴是添加的噪音的级别。图中红色越深表示Overfitting越严重，蓝色越深表示模型表现越好。我们可以看出，随着噪音级别增大，所需要的数据量N也越多，这有这样才能避免Overffiting。<br>对于图二，研究的是数据量和模型复杂度的关系，同样，越复杂的模型需要更多的数据！</p><p>从上面的实验结果，我们可以总结Overfit会发生的情况：</p><ol><li>数据减少。</li><li>随机噪音增多。</li><li>deterministic noise增多。</li><li>模型复杂度增大</li></ol><p><img src="7.png" alt="determinstic noise"> </p><p>deterministic noise，也就是我们Learning到的最好的h和目标函数f之间的差异。就如上图所示，我们的target function是蓝色的线，但是我们使用2次模型来fit这个f，此时我们获得红色的线，二者之间灰色的区域就是存在的noise。其表现和随机噪音实际上没有什么区别，二者的区别在于deterministic noise依赖于我们所选择的假设空间，对于每个x，它都是固定的！</p><p>这也说明，如果我们要学习一个简单的任务，我们就不能使用一个更复杂的模型！</p><h2 id="Dealing-with-Overfitting"><a href="#Dealing-with-Overfitting" class="headerlink" title="Dealing with Overfitting"></a>Dealing with Overfitting</h2><p>那我们该怎样处理Overfitting呢？一般有这样集中方法：</p><ol><li>从简单的Model开始，逐渐增加模型的复杂度。</li><li>尝试去掉噪音（数据清洗等），这种方法可能有用，但是很多时候作用是有限的。</li><li>使用更多的数据，然而可能获取新的数据很难，我们可以通过对原始的数据进行微调来增加新的数据，如对于图片数据，可以将其旋转等，然而在这个过程我们必须要让新加入的数据是有道理的，否则会导致数据分布偏离原有的分布，那么会导致我们学到的东西和目标偏差过大！</li><li>使用正则化（及时踩刹车）。</li><li>Validation（经常看看现在的状况）。</li></ol><p>对于4和5是下面两章的重点。</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（十三）&lt;/p&gt;
&lt;p&gt;今天我们学习什么是过拟合，它有什么危险以及该怎样处理过拟合！&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>12 Nonlinear Transformation</title>
    <link href="https://vhdsih.github.io/2018/10/14/mlfound12/"/>
    <id>https://vhdsih.github.io/2018/10/14/mlfound12/</id>
    <published>2018-10-14T11:18:13.000Z</published>
    <updated>2023-10-25T14:44:32.257Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（十二）</p><p>我们学习过线性分类模型，现在我们将学习非线性模型！</p><span id="more"></span><h2 id="Quadratic-Hypotheses"><a href="#Quadratic-Hypotheses" class="headerlink" title="Quadratic Hypotheses"></a>Quadratic Hypotheses</h2><p>到目前为止，我们所学习的都是线性分类模型，对于这些模型，我们通常可以找到一条线（或超平面）将我们的数据分为两个部分，我们只需要对每个数据点算一下分数就能实现这一点。</p><p>但是这样的模型是受限的！在理论上，我们使用的线性模型，VC维度是比较小的，但是实际上我们会遇到一些数据，这些数据对于线性模型是不能做到区分的，那么此时我们不论选择假设空间中的哪一条线，其Ein都会很大！</p><p><img src="1.png" alt="limited data"> </p><p>此时我们该怎样突破我们的线性模型所带来的限制呢？举个例子，对于上面的分布数据点，一种直观的想法是：我们使用一个圆圈来对数据进行区分：</p><p><img src="2.png" alt="circular"> </p><p>此时数据点集D虽然不是线性可分的，但是我们仍然可以使用一个圆来区分这些数据。那么我么只要看一看点是否在圆的内部即可，假设这个圆形的半径是sqrt(0.6)，此时我们的h(x):</p><p><img src="3.png" alt="hsep(x)"> </p><p>就像上面所说的，我们的一些数据尽管不能使用线性模型来分开，然而我们可以使用圆形来分开，同样我们也能用同样的方法来实现圆形的线性回归以及圆形的Logistic Regression。然而，如果只是这样简单地将其推广，还是很麻烦，我们需要一个一个地去重新推导，现在我们从另一个角度来看这个问题：</p><p><img src="4.png" alt="h(x)"> </p><p>我们将h(x),整理为如上的形式，如果我们将每一个平方项都用zi表示，系数用wi表示，将圆形半径作为z0，并将其乘以1作为z0。此时，是不是有似曾相识的感觉？</p><p>没错，这就是线性模型的一般结构，或者说，我们的数据看起来是不能线性分开的，但是如果我们将每一个数据点都转换到z空间，那么这些数据就变成线性可分的了：</p><p><img src="5.png" alt="transformation"> </p><p>然而，我们现在的转换还是受限的，虽然随着参数的不同，我们在z空间上的线性模型可以表示为当前空间中的不同曲线模型（圆形分类模型、椭圆分类模型、双曲线分类模型），然而，你能不能做到一个圆心不在原点的圆形分类模型吗？答案显然是不能的，因为我们的h(x)中没有包含一次项，也就不能对其进行平移变换。如果我们需要一个包含所有曲线的二次Hypothesis该怎么办？简单的想法就是将所有的项都添进去，包括常数项、一次项、二次项（包含两个未知数的乘积）。</p><p><img src="6.png" alt="big hx"> </p><p>其中Φ2为：</p><p><img src="7.png" alt="info"> </p><h2 id="Nonlinear-Transform"><a href="#Nonlinear-Transform" class="headerlink" title="Nonlinear Transform"></a>Nonlinear Transform</h2><p>现在通过空间的变换，我们将我们有的不能线性分开的数据转换到能够线性分开的z空间上。我们希望在z空间上也有一个Good Perceptron能够将数据分开。然而我们现在只知道在x空间上怎样对{(x, y), …}这样的数据分类并获得一个Good Perceptron。那么我们现在要做的是对z空间上的数据{(zn=Φ2(x), y), …}寻找一个Good Perceptron。</p><p>我们可以这样考虑：</p><ol><li>将原始数据转换到z空间。</li><li>在z空间上得到一个Good Perceptron，此时可以使用任何一种线性分类算法。</li><li>将z空间上的Perceptron转换回x空间。</li></ol><p><img src="8.png" alt="the nonlinear transform steps"> </p><p>使用上面的方法，我们就能够很轻松地实现在二次空间上的PLA、Regression等算法了。</p><p>实际上特征转换的思想我们并不陌生，在第三章我们介绍各种特征（具体特征、原始特征、抽象特征等）时，我们就接触了这种思想：对于手写数字，我们知道的是每一个数字的各个位置的像素灰度数值，我们可能可以将这些raw feature转换为平面密度和对称性等来实现对数字的分类和识别！</p><h2 id="Price-of-Nonlinear-Transform"><a href="#Price-of-Nonlinear-Transform" class="headerlink" title="Price of Nonlinear Transform"></a>Price of Nonlinear Transform</h2><p>现在我们将上述方法推广到n维（上面介绍的是利用二次曲线来分开平面上的点，现在我们使用n次曲线同样实现这件事），如果我们需要Q次的变换：</p><p><img src="9.png" alt="q-th transformation"> </p><p>如果我们的hypothesis能够包含所有的q次曲线，那么需要将所有可能的项都包含进来，此时，我们使用排列组合的知识，能够知道此时这个h(x)的维度的复杂度是O(Q**d)。此时我们可以知道，不论我们是使用PLA还是其他的模型，我们都需要大量的时间来更新参数，同时，也需要更大的空间来存储这些参数。如果Q越大，那么计算和存储这些参数所需要的代价也就越大！</p><p><img src="10.png" alt="complexity"> </p><p>同时，也代表此时的VC dimension也是至少d̃ +1这么大，随着q的增加也越来越大。但是我们可以证明此时的Dvc最多是d̃ +1，因为在z空间上任何d̃ +2个点都不能被shatter，那么在x空间上同样如此。</p><p>那么Q变大，VC Dimension也变大有什么坏处呢？通常q次数越高，我们很容易让Ein变得很小，但是却很难让Eout和Ein相等。如果q的次数很小，我们能够做到Ein和Eout相等，但是却很难让Ein变得很小：</p><p><img src="11.png" alt="generalization"> </p><p>我们该怎样选择一个合适的q呢，很明显，q既不是越大越好也不是越小越好！那么能不能使用人眼来选择呢？<br>首先，对于高纬度空间，人类是很难对其进行想象的。其次，就算是一个比较低的纬度的空间，我们这样做往往会也会带来一些风险：我们人脑会首先对这些模型进行优化，然而我们在计算时却忽略了我们自己优化所带来的代价，这些代价可能很大，从而会对q的选择带来影响。</p><h2 id="Structrued-Hypothesis-Sets"><a href="#Structrued-Hypothesis-Sets" class="headerlink" title="Structrued Hypothesis Sets"></a>Structrued Hypothesis Sets</h2><p>现在我们重新看一看我们的转换过程。<br><img src="12.png" alt="transform revisited"> </p><p>我们列举了从0次到Q次的转换，通过观察这些转换方程，我们可以推断出，所有低次的变换都是高次变换的特例，我们可以用一张图来表示：</p><p><img src="13.png" alt="include"> </p><p>我们把这种关系称为假设空间H的结构。对于这些假设空间之间的关系，我们可以使用一张图来概况：</p><p><img src="14.png" alt="shs"> </p><p>即随着维度q的增大，VC Dimension逐渐增大，而其Ein能获得的最小值则越来越小。实际上此时随着维度的增大，其Ein、Eout和模型的复杂度之间存在这样的关系：</p><p><img src="15.png" alt="complexity and others"> </p><p>对于这张图我们已经不陌生了，这也就说明，更高维度的模型其复杂度也越高，虽然我们在高维模型可以获得好的Ein，但是我们真正关心的从来都不是Ein，而是Eout。此时模型的复杂度很高，我们却很难获得好的Eout！</p><p>由此，我们的学习一般不能从一个很高的维度开始，否则我们可能根本无法优化。一般我们都会从线性模型开始学习，它是简单高效安全的，实际上，很多时候线性模型就能取得很好的效果！</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（十二）&lt;/p&gt;
&lt;p&gt;我们学习过线性分类模型，现在我们将学习非线性模型！&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>11 Linear Models for Classification</title>
    <link href="https://vhdsih.github.io/2018/10/13/mlfound11/"/>
    <id>https://vhdsih.github.io/2018/10/13/mlfound11/</id>
    <published>2018-10-13T10:06:14.000Z</published>
    <updated>2023-10-25T14:44:32.257Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（十一）</p><p> 本章将从我们学过的Binary Classification出发，来看一看我们学过的Model怎样完成如Multiclass Classification等更复杂的任务。</p><span id="more"></span><h2 id="Linear-Models-for-Binary-Classification"><a href="#Linear-Models-for-Binary-Classification" class="headerlink" title="Linear Models for Binary Classification"></a>Linear Models for Binary Classification</h2><p>我们已经学习了3个Linear Model，他们的共同点是都计算了一个分数：向量wT和向量x的乘积。</p><p>对于Linear Classification问题，计算的分数需要经过一个sign函数，从而得到{-1， +1}内的结果，它的Error Function是0/1的。我们之前也学习过，在这个问题中我们要找一个最佳的分类结果是很难的，它是一个NP Hard的问题。<br>对于Linear Regression问题，算出的分数没有经过任何处理，直接输出作为我们的结果，它的Error Function是一个平方误差函数，对于这一种问题我们有非常简单完美的解决方案来寻找一个很好的解。</p><p>对于Logistic Regression问题，我们计算的分数通过了一个sigmoid函数，也就是一个S形曲线，从而得到一个0和1之间的结果，也就是需要的概率数值。我们使用cross-entropy error作为误差函数，并且通过梯度下降（Gradient Descent）的方法找到最优解。</p><p>那既然Linear Classification问题解决起来是一个NP问题，我们能不能使用Linear Regression或者Logistic Regression来解决线性分类问题呢？</p><p>也就是说，不论对我们的Linear Regression还是Logistic Regression来说，我们都将其输出限制为{-1， +1}。当然对于Logistic来说，它本来就是用来分类的，这是一件容易办到的事。而{-1，+1}只是两个特别的实数，那么直观看起来Linear Regression也是可以做到的。</p><p>在我们想办法解决这件事之前，我们首先将这三者的Error Function先整合统一起来：<br><img src="1.png" alt="error"> </p><p>下面我们就来看看这些Error Function和ys的关系是怎样的。我们先看看ys的物理意义是什么：y代表正确性， s代表分数。我们希望其值越大越好，越大表示越好，y是正数表示是正确的，否则表示是不正确的。我们想办法把Error Function画在平面上，我们令横轴是ys纵轴是error：</p><p><img src="2.png" alt="error image"> </p><p>对于线性分类算法，其表现为蓝色的线，而线性回归则表现为红色的线。我们可以看到在ys小的时候（小于2），其表现很好，但是在比较大的时候，比如ys=3时，它会认为err很大，但实际上在分类任务上是一个较好的情况。对于逻辑回归问题，我们一般将其进行一个换底的操作将其error曲线进行缩放，即把ln换成log2，从而能够得到如图那样的结果：一个恰好在0/1error上方的error。</p><p>实际上也就是说通过缩放的Logistic Error和Linear Regression Error是0/1Error的一个上界：</p><p><img src="3.png" alt="upper bound"> </p><p>从而，如果我们能把logistic中的error求的很好，对于0/1问题我们也能做的不错！当然我们用平方误差也符合，只不过linear regression的error是一个更宽松的上界。</p><p>现在做一个总结：</p><ol><li>使用PLA进行线性分类是一件有效的事，但是前提是数据必须线性可分，否则我们就需要使用Pocket算法。</li><li>使用linear regression也能实现分类，而且是最容易得出结果的，但是由于它的error的上界比0/1error的上界高很多，所以它的精确度没那么高。</li><li>对于logistic regression，它是比较容易求解的，不过它的error同样是0/1error的一个上界，只不过比linear regression要好一些。</li></ol><p>所以linear regression有时候可以作为PLA、Pocket、Logistic Regression的出事向量求解的方法。此外Logistic Regression一般要比Pocket表现的要好。</p><h2 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h2><p>我们学习过两种通过一次次迭代来进行优化的方案：一种是PLA方法，每次都通过更新来寻找一个更好的向量w；另一种是在Logistic Regression中使用的梯度下降的方法。<br>然而，我们知道在数据是现行可分的情况下PLA算法的迭代过程是非常快的，由于每次使用一个错误的点，每一次迭代的时间复杂度是O(1)的，但是逻辑回归则需要检查所有的数据才能进行一轮迭代，即为O(n)的时间复杂度。那么该怎样提高逻辑回归中Gradient Descent的效率呢？</p><p><img src="4.png" alt="gd"> </p><p>我们一个方法就是去掉求和，随机选取一个点来进行Gradient Descent，即Stochastic Gradient Descent(SGD)。</p><p><img src="5.png" alt="sgd"> </p><p>我们把真是的梯度换为随机的梯度，那么在足够多的迭代次数之后，平均的随机梯度和平均的真是梯度是大致相等的。SGD很简单而且计算量少，在大数据和在线学习上有很大的用处，缺点是不太稳定。</p><p>实际在PLA上我们就用了类似的方法：每次选一个错误点来更新w。我们的SGD Logistic Regression更像是一个‘soft’ PLA。</p><p>但是我们使用SGD还需要考虑两个问题：</p><ol><li>算法何时能够停止？<br>Gradient Descent在求得梯度为0时可以停止，但是SGD很难得到梯度为0的位置。一般都认为如果运行的时间足够长就可以停止了。</li><li>学习率η取什么数值？<br>这个问题后续还有讨论，但是如果没有什么想法，0.1可能是合适的。</li></ol><h2 id="Multiclass-via-Logistic-Regression"><a href="#Multiclass-via-Logistic-Regression" class="headerlink" title="Multiclass via Logistic Regression"></a>Multiclass via Logistic Regression</h2><p>接下来我们着重关注多分类（Multiclass）问题。<br>假设我们现在有一些数据，它们属于不同的类别（类别不止2两个），此时该如何分类呢？<br>我们一直学习的都是二分类问题，现在我们把我们学习过的方法延伸到多分类上。</p><p>我们可以一次只分一个类别：只将一个类别当成是正类，其他都当成负类。这样重复多次，就能实现多分类问题，其中每个子问题都是一个二分类问题。</p><p>但是此时就会有一个问题，如果在不同的分类中都说某一部分是属于其类别的，即分类结果会产生某些属于多个类别的该怎么办呢？</p><p>我们可以“softly”产生每一个类别，看每个数据属于每一个类别的概率是多少，最后根据概率来决定类别。我们可以使用Logistic regression来实现。</p><p>我们将这种方法成为One-Versus-All（OVA），这是有效的方法，但是如果某种类别数码较小但是总数很大的时候，往往会造成不均衡，此时可能就会导致Logistic regression都选择占比较大的类别，当然这里没有强调各种概率的加和得1这个问题，如果通过了处理可能能够得到更好的结果。</p><h2 id="Multiclass-via-Binary-Classification"><a href="#Multiclass-via-Binary-Classification" class="headerlink" title="Multiclass via Binary Classification"></a>Multiclass via Binary Classification</h2><p>在上面我们提到了如果数据是不均衡的，那么 OVA将会导致坏的结果。所以，我们想在尝试one versus one，即一对一的来求解：<br>现在我们尝试只对其中的两个类别分类，忽略其他类别，比如，我们现在需要最圈圈、叉叉、正方形、星星来进行分类。我们先对圈圈和叉叉分类，求得一根直线，直线的一侧是叉叉，另一侧是圈圈。同理通过6次分类，我们就能得到所有的分类结果。根据上述的分类结果综合起来，就能判定属于各类别的区域了。这类似于循环赛，通过多次比赛来决定最优的预测。<br>这种方法称为one versus one（OVO）。这种方法效率很高，资料数量需要少，可以和binary classification搭配使用。但是坏处是需要花费更多的时间和空间。</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（十一）&lt;/p&gt;
&lt;p&gt; 本章将从我们学过的Binary Classification出发，来看一看我们学过的Model怎样完成如Multiclass Classification等更复杂的任务。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>10 Logistic Regression</title>
    <link href="https://vhdsih.github.io/2018/10/12/mlfound10/"/>
    <id>https://vhdsih.github.io/2018/10/12/mlfound10/</id>
    <published>2018-10-12T10:37:20.000Z</published>
    <updated>2023-10-25T14:44:32.225Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（十）</p><span id="more"></span><h2 id="Logistic-Regression-Problem"><a href="#Logistic-Regression-Problem" class="headerlink" title="Logistic Regression Problem"></a>Logistic Regression Problem</h2><p>我们学习过了Binary Classification和Linear Regression问题。对于二分类问题，只能对类别进行区分。例如：如果我们现在有一些病人的数据，我们想要学习病人患心脏病的情况，Binary Classification只能学习到是否会患病。如果我们不仅仅需要Learning到病人会不会患心脏病，还需要知道他患病的概率是多少，此时Binary Classification就不能胜任了。对于这种任务我们通常称之为‘Soft’ Binary Classification，其一般形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x) = P(+1|x) ; </span><br></pre></td></tr></table></figure><p>其输出是一个属于0到1区间内的小数，表示发生+1的概率。</p><p>我们想要做到Learning，那么理想的数据（没有噪音）应该是对于每一个输入x，都对应其发生的概率p。然而，实际在我们的数据（含有噪音）上，对每一个输入x，我们只知道它是正类还是负类，我们的数据和Binary Classification是相同的，因此我们需要一个不同的目标函数，我们仍然将输入各个维度的特征乘以权重，当其值很小的时候，输出接近0，相反则接近1:</p><p><img src="1.png" alt="logistic function"> </p><p>我们称其为logistic function θ(s)，其中s为sum（wi * xi) (from 0 to d)，xi为每个输入特征，wi为对应的权重，而第0维度是threshold。使用向量表示：</p><p><img src="2.png" alt="logistic hypothesis"> </p><p>而为了实现这样的效果，θ(s)实际上如下：</p><p><img src="3.png" alt="thete"> </p><p>这个函数也被称为sigmoid方程。我们将以上的结果整理，得到了Logistic Regression的h(x):</p><p><img src="4.png" alt="r"> </p><h2 id="Logistic-Regression-Error"><a href="#Logistic-Regression-Error" class="headerlink" title="Logistic Regression Error"></a>Logistic Regression Error</h2><p>现在我们比较我们已经学习过的三种Learning方法：</p><p><img src="5.png" alt="difference"> </p><p>三种输入都是d+1维的向量。Linear Classification使用了sign函数，将输出空间限制在{-1， +1}，也因此使用了0 1误差；而Regression问题则直接将和权重计算后的结果输出，其使用了平方误差；而Logitstic Regression使用了sigmoid函数，来获得事件发生的概率，那么该怎样定义它的Error Function呢？</p><p>我们首先看我们的目标函数f，其等于P(+1|x)， 其意义就是任意数据x发生+1的概率是多少。我们反过来看P(y|x)，如果y = +1时，那么它就等于f(x)，相反，如果y=-1，其值为1-f(x) （注意：因为概率值为0到1之间的数）。<br>现在我们考虑我们有一堆数据，其既有+1情况的数据，也有-1情况的数据，如果我们用f去生成这些数据，以及用我们的假设h生成这些数据：</p><p><img src="6.png" alt="f and h"> </p><p>如果我们得到的h和f相差不大，那么生成的差不多的数据的概率也是差不多的，当然这里有个前提是这个数据量很大。我们想在的任务实际上就是找到这个和f相差不多的函数g，那么g：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = argmax(likelihood(h))</span><br></pre></td></tr></table></figure><p>我们知道，在logistic中，h(x) = θ(wTx)，同时1-h(x) = h(-x)（可以根据sigmoid曲线看出）。所以将其代入到likelihood(h)中，我们知道：</p><p><img src="7.png" alt="likelihood"> </p><p>既然是正比关系，我们可以对右边表达式取ln，同时，取最大值情况相当于加负号后取最小值，由此，我们能够整理出Logistic Regression的Error Function：</p><p><img src="8.png" alt="cross entropy error"> </p><h2 id="Gradient-of-Logistic-Regression-Error"><a href="#Gradient-of-Logistic-Regression-Error" class="headerlink" title="Gradient of Logistic Regression Error"></a>Gradient of Logistic Regression Error</h2><p>既然要Learning，我们就需要最小化Ein(w)。我们知道Linear Regression问题的平方误差是一个平滑连续的凸函数，所以我们能够使用在梯度为0处是最小值这个技巧来求最优解。当然实际上logistic的Error同样是一个平滑的凸函数，我们可以求得令∇E in (w) = 0处的w即可。</p><p><img src="9.png" alt="graph"> </p><p>可以使用链导法对其求导（过程略），最终结果如下：</p><p><img src="10.png" alt="gradient"> </p><p>然而，我们发现求解梯度为0并不是一件简单的事情，那该怎么办呢？此时我们回顾我们的PLA是如何找到最佳的分类直线的：</p><ol><li>找到一个错误点。</li><li>使用错误点纠正w，令wt+1 = wt + yn*xn。</li><li>重复1、2直到停止，此时找到最优w。</li></ol><p>我们着重看第二步：</p><p><img src="11.png" alt="update"> </p><p>实际上就是每一次都在接近最优的解。我们也可以类比这个思想，当我们在最小化logsitic error时，我们每一次选择一个方向向量v和一个η(步长)，来向更小的方向迈出一步即可。</p><p><img src="12.png" alt="update2"> </p><h2 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h2><p>对于上面所提出的方法，实际上包含一种贪心的思想，此外，当我们使用的步长数值η比较小时，我们可以将Ein用泰勒展开:</p><p><img src="14.png" alt="p"> </p><p>从而我们的一种解决方法如下：</p><p><img src="13.png" alt="solution"> </p><p>对于v的选择，实际就是Ein梯度的反方向：</p><p><img src="15.png" alt="v"> </p><p>我们把这种方法称为梯度下降（Gradient Descent）：每一次选一个较小的步长，向梯度下降的方向移动，直到移动到最低点为止。</p><p>其中η被称为学习率，它决定了学习的速度。在学习中需要选择适当的学习率，过小则会导致学习速度过慢，过大则会产生震荡现象，不稳定！一个好的方法是使用变化的learning rate，在梯度较大处使用较大的lr，然后随着学习的进行逐渐减小：</p><p><img src="16.png" alt="lr"> </p><p>现在我们对于一个logistic regression，总结如下：</p><ol><li>初始化w0。</li><li>计算Ein(wt)的梯度。</li><li>使用梯度下降的方法update wt。</li><li>直到梯度减小为0时停止，此时wt+1对应的g就是我们所需要的。</li></ol><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（十）&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>09 Linear Regression</title>
    <link href="https://vhdsih.github.io/2018/10/11/mlfound9/"/>
    <id>https://vhdsih.github.io/2018/10/11/mlfound9/</id>
    <published>2018-10-11T14:06:54.000Z</published>
    <updated>2023-10-25T14:44:32.210Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（九）</p><p>我们一直在讨论分类问题，并利用分类问题推导了VC Bound以及Learning的可行性问题。Learning任务中也存在很多输出空间是连续的情形，实际上VC Bound同样使用在这些问题上，这一节讨论线性回归问题。</p><span id="more"></span><h2 id="Linear-Regression-Problem"><a href="#Linear-Regression-Problem" class="headerlink" title="Linear Regression Problem"></a>Linear Regression Problem</h2><p>在我们讨论信用卡发放问题时，我们一直以来的输出都是是或者否的输出空间，如果我们在解决这个问题时，要求输出是一个人的信用程度，我们将根据这个信用程度来决定是否发放信用卡的时候，我们将要解决的问题就是回归问题。<br>那么我们的Hypothesis Set应该是什么样的，才能输出连续的内容呢？我们可以考虑为每一个维度的输入属性乘以权重，最终我们找到一个合适的权重向量来实现对信用的预测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 设输入x为</span><br><span class="line">x = (x1, x2, x3, ..., xd)</span><br><span class="line"># 权重向量w为</span><br><span class="line">wT = (w1, w2, w3, ..., wd)</span><br><span class="line"># 那么</span><br><span class="line">y about= sum(wi * xi) (i from 0 to d)</span><br><span class="line"># 转换为向量运算：</span><br><span class="line">h(x) = wT * x</span><br></pre></td></tr></table></figure><p>上面的h(x)和Perceptron是很类似的，区别是后者有sign函数，将每个数值取为了正负1。<br>那么Linear Regression在空间中是什么样子的呢？在二维空间中，它是一条直线，而在三维（或高维）空间中，则是一个超平面。我们的Learning任务，实际就是在寻找这条（个）直线（超平面）。</p><p><img src="1.png" alt="see"> </p><p>在回归问题中，一般使用平方误差（Squared error）作为Error的衡量方法，即数据在Learning后输出的结果和实际结果差值的平方。这个方法可以同<br>时用在Ein和Eout上。Learning的过程就是最小化这个Squared Error的过程。</p><p><img src="2.png" alt="error"> </p><h2 id="Linear-Regression-Algorithm"><a href="#Linear-Regression-Algorithm" class="headerlink" title="Linear Regression Algorithm"></a>Linear Regression Algorithm</h2><p>在求解Regression问题时，实际是最小化Ein(w)。Ein是w的函数，它包含x和y两个向量参数，首先我们将其转化为矩阵表示：</p><p><img src="3.png" alt="matrix"> </p><p>Ein(w)实际上是连续的凸函数，也就意味着其有最小值，由高等数学可知，在最小值点，Ein(w)的梯度为0，我们找到了这一点的w：wlin，我们也就解决了问题。</p><p><img src="4.png" alt="show"> </p><p>我们现在求解Ein(w)的Gradient：∇Ein(w) ，将平方项展开，并将一些系数用简单的A、b、c表示：</p><p><img src="5.png" alt="∇Ein"> </p><p>求Ein的梯度，也就是求w的导数。如果w是一个变量，那么容易求解：</p><p><img src="6.png" alt="w is var"> </p><p>当w是一个vector时，实际上在求解之后和w是变量的时候具有相同的形式：</p><p><img src="7.png" alt="w is vector"> </p><p>我们现在的任务就变成了求Ein梯度为0时的w了：</p><p><img src="8.png" alt="task"> </p><p>如果X是可逆的就很容易，通过在等式两边乘以逆矩阵，我们就能够得到唯一的解(大部分情况都是可逆的，因为数据N远大于矩阵维度d+1，否则我们可以使用伪逆矩阵pseudo-inverse，很多软件都实现了这个方法，使用pseudo-inverse求解）。如果X不可逆，那么就会有很多解：</p><p><img src="9.png" alt="invertible or singular"> </p><p>我们用X+表示pseudo-inverse，那么最终通过计算这个伪逆矩阵，就能得到需要的权重向量：</p><p><img src="10.png" alt="invertible or singular"> </p><p>只要我们使用好的求解pseudo-inverse矩阵的方法，求解最优w的过程就很简单！</p><h2 id="Generalization-Issue"><a href="#Generalization-Issue" class="headerlink" title="Generalization Issue"></a>Generalization Issue</h2><p>上面的Linear Regression算法看起来很简单，可能有些人会产生疑问：这算是机器学习吗？因为他没有看到随着使用数据一步一步优化的过程。<br>实际上如果我们仔细推导了求解pseudo-iverse矩阵的过程，我们仍然能够看到这个逐步优化的过程，只不过现在它们都被封装好了，我们感觉很简单就计算出来了。所以我们仍然可以说这是一个Learning的问题：我们能够获得一个很小的Ein，由于问题有一个有限的VC维度，我们能够保证Eout和Ein大致相等。</p><p>事实上，我们可以利用一种比VC Dimension更简单的方法来证明这个问题：通过比较Ein的平均和Eout的平均。当然，这里只会提到其中重要的几个步骤（或思想）：</p><p>我们将求得的Wlin代入，来化简Ein：<br><img src="12.png" alt="average"> </p><p>我们将XX+称为帽子矩阵（hat matrix H），那么化简以后，Ein取决于帽子矩阵和y。<br>我们从几何学的角度来看这个问题：</p><p><img src="13.png" alt="hat matrix"> </p><p>现在我们假设我们待解决的问题是一个N维空间的问题：其中，ŷ都是我们求得的结果，而y是实际的结果。而令Ein最小化就是让y和ŷ最小。当前我们还不知道最好的w在哪，因为ŷ=Xw，那么我们将所有的w和X计算乘积以后会展开成一个超平面（上面粉色部分），我们让Ein最小只需要让ŷ是y在这个超平面的投影即可，当然我们还需要考虑ŷ的长度，但是很容易知道只要y-ŷ垂直与这个超平面的即可。那么帽子矩阵H就是把任何向量y都头应到这个超平面上，而I - H就是求y - ŷ。</p><p>如果我们计算（I-H）的迹 trace(I - H)，可以得到结果是N - (d + 1)，其物理意义是y-ŷ的自由度。</p><p>如果现在不是理想状态，而是包含Noise：</p><div aling=center> ![noise H](14.png) <p>此时：</p><div aling=center> ![ein](15.png) <p>我们就能得到Ein平均的情况，同理我们也能计算Eout的平均，只不过很复杂。</p><div aling=center> ![ein and eout](16.png) <p>我们此时可以画出Ein和Eout的平均的曲线：</p><div aling=center> ![curve](17.png) <p>所以，平均来说Eout和Ein的差是2 * (d + 1) / N。当N够大Learning是能够进行的。</p><h2 id="Linear-Regression-for-Binary-Classification"><a href="#Linear-Regression-for-Binary-Classification" class="headerlink" title="Linear Regression for Binary Classification"></a>Linear Regression for Binary Classification</h2><p>我们已经学习过线性分类问题，其表示形式和回归问题类似，区别在于其使用了sign函数，对于分类问题，我们的目标是找到一条最优的直线（分类超平面），然而解决这个问题往往是NP问题。<br>现在我们学习了线性回归分析，通过前面的求解，我们知道这是一种高效的方法。既然分类问题的输入空间是{-1, +1}，那么能不能使用回归方法来解决分类问题呢？<br>直观上看是可以的，对于-1的类别，我们的回归方法的输出可能是一个负数，或者说当输出是负数的时候我们将其看作是负类；相反，在输出正的时候可以看作正类。为了深入解释这个问题，我们现在观察两种问题的Error的不同。<br>对于分类问题，我们往往使用pointwise的方案，而回归问题一般是平方误差，这也就导致了前者在数学上的表现是一段段梯形的表示（不会平滑连续），而后者则是平滑的凸函数。</p><p><img src="11.png" alt="relation of errors"> </p><p>也就是说，分类的error总是小于或者等于回归的error！由此，我们可以使用Regression求得的最优权重向量wlin初始化PLA或者Pocket算法，然后再由PLA或Pocket进一步找到最优的解，这样就能很大程度上提高效率。</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（九）&lt;/p&gt;
&lt;p&gt;我们一直在讨论分类问题，并利用分类问题推导了VC Bound以及Learning的可行性问题。Learning任务中也存在很多输出空间是连续的情形，实际上VC Bound同样使用在这些问题上，这一节讨论线性回归问题。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>08 Noise and Error</title>
    <link href="https://vhdsih.github.io/2018/10/11/mlfound8/"/>
    <id>https://vhdsih.github.io/2018/10/11/mlfound8/</id>
    <published>2018-10-11T09:03:32.000Z</published>
    <updated>2023-10-25T14:44:32.211Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（八）</p><p>我们在之推到验证VC Bound时，做了一些假设，其中就包括数据中是不包含噪音的（Noise）。如果我们的数据中包含错误和噪音（真实的情况下往往是这样的），那么会发生什么？</p><span id="more"></span><h2 id="Noise-and-Probabilistic-Target"><a href="#Noise-and-Probabilistic-Target" class="headerlink" title="Noise and Probabilistic Target"></a>Noise and Probabilistic Target</h2><p>实际上我们在学习PLA算法时就讨论过Noise，当时我们说如果数据是线性不可分的话，我们的PLA算法就不能停止，我们可以把这些导致不能线性可分的点看作是Noise，因此我们使用Pocket算法来解决这种问题。<br>Noise同时存在于x与y：仍然是银行信用卡发放问题，有可能是用户提交信息写错了，也有可能是专家标注过程标注错了，甚至可能两个专家对同一个用户的数据给出了不同的态度。当然，在其它具体的场景中Noise和Error产生的原因会有其特定的因素。<br>那么我们之前讨论过的VC Bound在Noise的条件下还能作用很好吗？<br>在回答这个问题之前，我们回忆在推导VC Bound的过程中最关键的是什么：实际上在我们证明时，都是从瓶子中抓出一把球来估计橘黄色球的数目，如果有Noise，那么橘色的弹珠就是犯错误的地方（把每个弹珠看作是x，颜色就是假说的预测和f的实际结果是否相同）。</p><p><img src="1.png" alt="marbles"> </p><p>如果现在瓶子中有一个球的颜色是不停在变动的，不过瓶子中球颜色在整体上还是符合某一种分布，我们在估计的时候可以记录抓出时所有球的瞬时颜色，实际上仍然能够做到对橘黄色弹珠的估计，只不过现在不是一个确定的估计，而是一个概率估计。<br>对于VC Bound，我们仍然能够使用会变色的弹珠这种情况再推导一次，如果满足x的分布是P(x)且独立同分布(i.i.d.)，y按P(y|x)独立同分布，那么能够保证：即使有噪音，VC Bound还是能够表现的很好，之前的证明仍然是成立的。<br>我们将p(x|y)称为目标分布，可以看作是理想的和一些噪音的组合。同样对于没有噪音的，我们可以将它看作是特殊的p(y|x)的分布。<br>现在我们的Learning流程可以如下表示：</p><p><img src="2.png" alt="map"> </p><p>VC Bound仍然可行，同时，我们的Pocket算法也能得到解释：我们尽量让Ein越小越好，在有噪音的前提下仍能够让Ein与Eout大致相等，也就可以学习到东西。</p><h2 id="Error-Measure"><a href="#Error-Measure" class="headerlink" title="Error Measure"></a>Error Measure</h2><p>我们现在看看我们衡量Error的方法：我们之前一直在看g和f是否相同或者接近。我们使用Eout(g, f)来衡量错误，我们考虑的是:</p><ol><li>没有见过的数据。</li><li>这些数据是可以一个个验证的。</li><li>我们的任务都是分类问题。</li></ol><p>很多时候我们衡量错误的时候都能够一个点一个点来计算，我们把这种称为pointwise error。我们衡量错误有很多方式，有两种重要的方法，其一是用于分类的01错误（上面的）；另一个就是squared error，一般用在回归问题，来看和目标距离的远近。<br>ideal mini-target是由p(y|x)和err同时决定的，pointwise error通常取最大的P(y|x)，而平方误差通常取的是期望值。现在我们引入了error measure，我们就能衡量g的好坏了，现在的Learning Map如下：</p><p><img src="3.png" alt="map3"> </p><h2 id="Algorithmic-Error-Measure"><a href="#Algorithmic-Error-Measure" class="headerlink" title="Algorithmic Error Measure"></a>Algorithmic Error Measure</h2><p>对于不同的任务，错误衡量的具体参数会有不同。而这种不同来自于两种不同的错误会带来不同的后果。错误可以分为false accept和false reject。前者是本来是错误的却将其判定为正确，而后者则是将正确的判定为错误。<br>对于不同的实际系统对这两种错误的承受能力不同，比如安全部门的机密档案门禁系统，可能不能承受false accept的错误，因此可以将其权重调的大一些。相反，某些热舞对于false reject的承受能力差，则需要将犯这种错误的惩罚增大。<br>在计算错误的时候，能够获得正确的err是最好的，但是实际上我们很难得到真实的error，这是我们往往需要一个友好的方法去接近这个error。</p><h2 id="Weighted-Classification"><a href="#Weighted-Classification" class="headerlink" title="Weighted Classification"></a>Weighted Classification</h2><p>我们需要对不同的error添加不同的惩罚，此时可以选用virtual copying方法：将坏的点复制weight遍（模糊）！</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（八）&lt;/p&gt;
&lt;p&gt;我们在之推到验证VC Bound时，做了一些假设，其中就包括数据中是不包含噪音的（Noise）。如果我们的数据中包含错误和噪音（真实的情况下往往是这样的），那么会发生什么？&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>07 The VC Dimension</title>
    <link href="https://vhdsih.github.io/2018/10/10/mlfound7/"/>
    <id>https://vhdsih.github.io/2018/10/10/mlfound7/</id>
    <published>2018-10-10T13:06:44.000Z</published>
    <updated>2023-10-25T14:44:32.216Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（七）</p><p>我们已经讨论过了，拥有Break Point k的增长函数mh(N)的上界最大是N的k-1次幂，在第6节的最后，我们提出来VC Bound， 利用该公式，我们可以有这样的推论，如果我们当前的Learning问题满足：</p><ol><li>成长函数有Break Point k。</li><li>数据量N足够大</li><li>能够从假设空间中选择一个g，满足Ein非常小（接近0）。</li></ol><p>那么我们就能够说明我们的Learning任务是可行的。当然，这个可行还带有运气的成分（还是会有一定的机率遇到BAD情况，只不过概率很低）。</p><span id="more"></span><h2 id="Definition-of-VC-Dimension"><a href="#Definition-of-VC-Dimension" class="headerlink" title="Definition of VC Dimension"></a>Definition of VC Dimension</h2><p>现在，我们为最大的非Break Point取一个正式的名字：VC Dimension，将其记为dvc。此时，如果N小于dvc，那么对于有N个输入的假设空间，一定能够shatter这些数据。任意k大于dvc，k都是H的Break Point。那么此时，我们就可以对成长函数的上界有一个新的表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mh(N) &lt;= N * dvc; (N &gt;= 2 &amp;&amp; dvc &gt;= 2)</span><br></pre></td></tr></table></figure><p>dvc取其它数值的，可以有其它的表示方式。</p><p>那么此时，对于之前常常提到的几种情况，其dvc的值分别如下：</p><ol><li>positive rays： dvc = 1。</li><li>positive intervals：dvc = 2。</li><li>convex sets：dvc = infinite。</li><li>2D Perceptrons：dvc = 3。</li></ol><p>对于一个好的假设空间来说，它有有限的VC Dimension。此时，如果我们知道我们的Learning任务有一个有限的dvc，那么不管我们的学习算法是什么，不管我们的输入数据的分布是什么，不管我们要学习的目标函数是什么，我们都能保证我们的学习能够进行，因为我们dvc is finite保证了g能够使Ein和Eout大致相等。</p><h2 id="VC-Dimension-of-Perceptrons"><a href="#VC-Dimension-of-Perceptrons" class="headerlink" title="VC Dimension of Perceptrons"></a>VC Dimension of Perceptrons</h2><p>我们再回顾一下在二维Perceptron任务上到底发生了什么，我们只有输入线性的输入数据，PLA才能够停止，而我们跑了很多次以后，得到的最终结果是一条线，能够将所有的点正确的分为两类，实际上就是让Ein=0。而另一方面，我们在某一个符合某一个分布，并利用target function生成的数据上进行Learning时，由于2D数据，其dvc=3，也就保证了在N足够大的时候，Ein和Eout是能够大致相等的。以上这两点保证了PLA的可行性。</p><p>当然，这只是在2维空间里，那么在更高维度的空间呢？</p><p>我们尝试推论d维空间里dvc的大小是多少：1维空间dcv=2，2维空间中dvc=3，那么d为空间呢，是否是d+1呢？</p><p>我们要证明这件事，实际上只要分两步就可以：</p><ol><li>证明dvc &gt;= d+1。</li><li>证明dvc &lt;= d+1。</li></ol><p>我们首先证明1:</p><p>如果dvc大于d+1，那么对于d+1个点，必然都能够shatter。我们可以取d+1个点：</p><p><img src="1.png" alt="x"> </p><p>如果对于任何一个y = [y1， y2，…，yd+1]T，都能找到一个w，令sign(xw) = y即可。因为x是可逆矩阵，因此很简单，直接两边乘以X的逆矩阵就可以。从而我们知道d+1个点都能够被shatter，从而得证。</p><p>我们再证明2:</p><p>证明2用到了线性代数中一个向量的线性表示的知识。我们取d+2个点，看第d+2个点能否被其它的点线性表示。由此证明出2。</p><h2 id="Physical-Intuition-of-VC-Dimension"><a href="#Physical-Intuition-of-VC-Dimension" class="headerlink" title="Physical Intuition of VC Dimension"></a>Physical Intuition of VC Dimension</h2><p>那么VC Dimension的物理意义是什么呢？VC Dimension表示了假设空间的自由度，或者形象地说，就是假设空间有多少个有效的旋钮（参数）我们能够调节（当然，只是一个不准确的描述，可能并不如此）。比如，对于Positive Rays模型，我们的dvc=1，我们只能调节分界点在哪，对于Positive Intervals问题，我们则有两个参数，可以调节左边在哪，右边在哪。</p><p>现在，我们就可以用dvc的大小来回答是否能够让Ein和Eout近似相等和我们能够让Ein足够小这两个问题了：</p><ol><li>如果dvc很小，Ein和Eout一定能够近似相等，但是由于Learning的自由度太小，我们却不一定能够学习到能够让Ein足够小的假设。</li><li>同理，如果dvc很大，Ein和Eout则可能相差很远，但是由于Learning的自由度很大，所以能够找到Ein足够小的假设。</li></ol><p>由此，我们说使用适当的dvc（适当的模型）是十分重要的。</p><h2 id="Interpreting-VC-Dimension"><a href="#Interpreting-VC-Dimension" class="headerlink" title="Interpreting VC Dimension"></a>Interpreting VC Dimension</h2><p>现在，我们想更深入了解VC Dimension的意义。我们首先对VC Bound重新描述。</p><p><img src="2.png" alt="duita"> </p><p>VC Bound实际上说明了坏事请发生的概率很小，我们使用δ表示坏事情发生的概率，那么1 - δ就是好事情发生的概率。那么好事情发生的概率就会很大很大。我们对其做一个简单的代换：</p><p><img src="3.png" alt="good"> </p><p>我们最终得到了e，其表示Ein和Eout的差值的绝对值大小，由此，我们能够推出Ein和Eout差值的上界，更准确地说，我们有很大的机会将Ein和Eout的差值限制在这个范围内。我们一般更加重视上界的作用。这个公式表明，我们的模型有多么强，那么在generate这个模型的时候，就要付出多大的代价（Penalty for Model Complexity）。通常表示为：Ω(N,H,δ)。</p><p><img src="4.png" alt="4.png"> </p><p>我们可以画出这样一张图：</p><p><img src="5.png" alt="5.png"> </p><p>横轴是dvc，纵轴是Error。随着VC维度的升高，模型的Ein越来越小，Eout先小后大，而模型的复杂度则越来越大。而最好的模型则在中间。我们未来会利用这张图来想办法设计更好的机器学习演算法。</p><p>所以，不是更复杂的、能力更强的模型性能更好，我们不要追求复杂的Model，我们需要正确使用Ml！</p><p>VC Dimension还有另外一层意思：就是资料的复杂度。资料越大，往往error能够限定到更小的范围。在理论上符合要求的数据量需要达到100000*dvc，但是实际上只要10倍的dvc的数据就能达到良好的效果。条件如此宽松的原因如下：</p><ol><li>我们使用Hoeffding不等式来估计Eout，我们可以在任意分布的数据以及任意目标函数上使用这个不等式，Hoeffding不等式的包容性很高，导致最终结果的包容性高。</li><li>我们使用成长函数来替换M，而并没有用真正的假设空间的大小，这允许我们使用任何资料。</li><li>我们使用了多项式做上限的上限的上限，而并不是成长函数。</li><li>我们仍然使用了union bound，即使我们将重叠的部分计算的很好，仍然还存在糟糕的情况。</li></ol><p>VC Bound很宽松，但是做的已经很好了。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在这一章中我们介绍了VC Dimension，也就是最大的非Break Point。在Perceptrons上其数值是d+1。物理意义上，dvc告诉我们model有多大的自由度，我们可以使用它来看模型的复杂度以及需要使用多少数据来学习。</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（七）&lt;/p&gt;
&lt;p&gt;我们已经讨论过了，拥有Break Point k的增长函数mh(N)的上界最大是N的k-1次幂，在第6节的最后，我们提出来VC Bound， 利用该公式，我们可以有这样的推论，如果我们当前的Learning问题满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;成长函数有Break Point k。&lt;/li&gt;
&lt;li&gt;数据量N足够大&lt;/li&gt;
&lt;li&gt;能够从假设空间中选择一个g，满足Ein非常小（接近0）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么我们就能够说明我们的Learning任务是可行的。当然，这个可行还带有运气的成分（还是会有一定的机率遇到BAD情况，只不过概率很低）。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>06 Theory of Generalization</title>
    <link href="https://vhdsih.github.io/2018/10/10/mlfound6/"/>
    <id>https://vhdsih.github.io/2018/10/10/mlfound6/</id>
    <published>2018-10-10T11:03:21.000Z</published>
    <updated>2023-10-25T14:44:32.210Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（六）</p><p>举一反三！</p><span id="more"></span><h2 id="Restriction-of-Break-Point"><a href="#Restriction-of-Break-Point" class="headerlink" title="Restriction of Break Point"></a>Restriction of Break Point</h2><p>在上一章里，我们曾经假设Break Point和增长函数有一定的数学关系，除此之外，我们也讨论过了四种情况下的Break Point：</p><p><img src="1.png" alt="four break points"> </p><p>对于上图中的前三种情况是比较容易理解的，在2D perceptrons情况下，我们不知道其增长函数是什么，我们只知道其一个上限是2 ** N，但是由于我们知道有如图4个点的分布是不能被shatter的，故此，我们知道它的Break Point是4。并且，很容易可以推论出，当某个成长函数的Growth Function的Break Point是k的时候，k+1，k+2， …都是它的Break point。</p><p>现在我们假设一种情况：我们有一个增长函数，它的Break Point k为2。那么我们能够从这推论出什么？</p><ol><li><p>当点的数目N为1的时候，点是可以被完全shatter的，因此增长函数mh(N) = 2。</p></li><li><p>N = 2，根据定义，增长函数的最大值是要小于4的（因为Break Point存在，对于大于等于k的点是不能被shatter的，最大的可能只能是3）。</p></li><li><p>如果N = 3呢，我们可以通过穷举得到增长函数的数值为4。就像下图中那样，在四种情形以后，添加任意一种情形，都存在2个点能够被shatter，违反了定义：</p><p><img src="2.png" alt="4 dichotomies"> </p></li></ol><p>从上面一个简单的假设来看，当k=2时，N=2时，增长函数mh(N)和k相差不大，当N=4是，看起来好像相差越来越大了。我们推测，Break Poin很大程度上限制了mh(N)，当然N是大于k的。</p><p>那么，如果我们对一个增长函数，给出了它的Break Point k，我们能够求出在k的约束下的mh(N)的上界是多项式的呢？</p><h2 id="Bounding-Function-Basic-Cases"><a href="#Bounding-Function-Basic-Cases" class="headerlink" title="Bounding Function: Basic Cases"></a>Bounding Function: Basic Cases</h2><p>现在，我们使用Bounding Founction B(N, k)来描述Break Point为k的mh(N)的上界。实际上就是看有多少个二分类，其满足任何长度为k的子集都是不能被shatter的。</p><p>现在我们有了一个新的目标：</p><p><img src="3.png" alt="new goal"> </p><p>现在计算N和k较小的时候B的数值：</p><p><img src="4.png" alt="B"></p><p>上图是最终的计算结果，但是其计算过程中主要分为了以下4个过程：</p><ol><li>当k=1时，对于任意数目的点，只能有一种情况，如果多出了一种，那么就不满足Break Point的定义了。</li><li>当k &gt; N时，所有的点都能够被shatter，那么就是2 ** N。</li><li>对于k和N相等的情况下，只要在所有的情况下删除一种就能满足定义，因此是2 ** N - 1。</li><li>对于其他的下三角的部分（也是最重要的部分），我们可以经过一个巧妙的归纳证明，归纳出其与上一行的两个元素存在关系。</li></ol><h2 id="Bounding-Function-Inductive-Cases"><a href="#Bounding-Function-Inductive-Cases" class="headerlink" title="Bounding Function: Inductive Cases"></a>Bounding Function: Inductive Cases</h2><p>在上一节中，我们对第4种情况的归纳没有详细的描述，在这一节中给出其具体的归纳过程。</p><p>我们的归纳从B(4, 3)开始。我们首先推测B(4, 3)能不能用几个B(3, ?)的数值来代替？看起来没有头绪，实际上我们可以使用计算机编写一个程序来穷举B(4, 3)这个情况：</p><p><img src="5.png" alt="how many cases"> </p><p>可以得到图片上的几种情况，对于这些凌乱的分布我们尝试重新整理，将除去最后一个的相同的放到一起：</p><p><img src="6.png" alt="arrange"> </p><p>前8个是成双成对的，只有后3个是孤零零的。那么我们可能有这样的推测：</p><p><img src="7.png" alt="what"> </p><p>那我们看一看α + β是什么样子的：</p><p><img src="8.png" alt="α + β"> </p><p>因为α + β是B(4, 3)的一个子集，那么α + β也是不能被3shatter的。从而：</p><p><img src="9.png" alt="conclusion"> </p><p>对于上一个图中的α ，它和x4组合后，我们说它不能被3shatter，那么α就不能被2shatter，因此</p><p><img src="10.png" alt="conclusion"> </p><p>最终，我们将其组合到一起：</p><p><img src="11.png" alt="conclusion"> </p><p>我们能够作出推论：</p><p><img src="12.png" alt="conclusion"> </p><p>并经过归纳证明这一结果，换一种表达方式：</p><p><img src="13.png" alt="conclusion"> </p><p>其上限是poly(N)。我们只要有一个有限的Break Point，我们就能用多项式的上界限制增长函数</p><h2 id="A-Pictorial-Proof"><a href="#A-Pictorial-Proof" class="headerlink" title="A Pictorial Proof"></a>A Pictorial Proof</h2><p>我们这一段时间的工作，一直是试图将霍夫丁不等式中的M替换为mh(N)，然后再看看能否替换成多项式。实际上，这并不是简单的替换就行的，我们的替换实际上会是这个样子的：</p><p><img src="14.png" alt="conclusion"> </p><p>这是一个比较复杂的证明过程，我们可以对添加这些参数做一个简单的证明：</p><p>步骤1:</p><p>我们将Eout替换为Ein’</p><p><img src="15.png" alt="conclusion"> </p><p>因为Ein是有限的，Eout是无限的，我们想将这个罪魁祸首替换掉该怎么办呢？</p><p><img src="16.png" alt="conclusion"> </p><p>我们可以将验证集D’上的Ein’替换Eout，如果一个假设h，其Ein和Eout的差值很大，那么有很大的可能性Ein和Ein‘的差值也是很大的。当然，为了严格添加了两个1/2（不懂啥意思）。</p><p>步骤2:</p><p>我们上一部替换Eout，实际上是为了将空间简化为有限多种。我们使用Ein‘替换Eout之后，现在的增长函数实际上收到已有数据集D和验证集D’的影响。根据Break Point的思想，我们只需简化我们的假设空间为H(x 1 , . . . , x N , x 0 1 , . . . , x 0 N )|就可以了。</p><p><img src="17.png" alt="conclusion"> </p><p>如图，hoeffing不等式是说坏事情发生的事很少，而当我们简单的使用union bound就会变成图二那样，现在，我们就是将坏事情都聚在了一起，那么现在我们就可以使用union bound计算了。因此我们使用mh(2N)。</p><p>步骤3：</p><p><img src="18.png" alt="conclusion"> </p><p>我们现在做的事情有点像从有2N个球的瓶子中抽取N，用N来计算Ein，剩下的用来计算Ein‘，就像抓出N个出来，来比较其和所有的。那么，在之前差1/2，后者就差1/4。（部理解*——#）</p><p><img src="19.png" alt="conclusion"> </p><p>最终我们通过引入增长函数的到了一个全新的不等式Vapnik-Chervonenkis (VC) bound:</p><p><img src="20.png" alt="conclusion"> </p><p>现在，我们就能证明2D Perceptron是能够Learning的（因为Break Point是4， 增长函数的上界是N ** 3）。</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（六）&lt;/p&gt;
&lt;p&gt;举一反三！&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>05 Training Versus Testing</title>
    <link href="https://vhdsih.github.io/2018/10/09/mlfound5/"/>
    <id>https://vhdsih.github.io/2018/10/09/mlfound5/</id>
    <published>2018-10-09T04:35:08.000Z</published>
    <updated>2023-10-25T14:44:32.257Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（五）</p><p>在第四章中，我们一开始提出来一个问题：Learning好像是不可行的，经过了证明，我们确定了在Hypotheses Set是有限的时候，Learning是可以做到的。然而，在实际的学习任务中，假设空间中往往存在无限多个假设h，那么在这个时候会发生什么呢，Learning能够进行这个结论在这种情况下还能成立吗？</p><span id="more"></span><h2 id="Recap-and-Preview"><a href="#Recap-and-Preview" class="headerlink" title="Recap and Preview"></a>Recap and Preview</h2><p>现在我们先对整体做一个回顾：如果我们假设Hypothesis Set H中假设h的数量是M，那么如果在我们拥有的数据量N是足够多的时候，根据霍夫丁不等式，我们知道任意一个在H中的一个h，它的Ein(h)和Eout(h)是大概相等的，或者说是相差不多的。如果我们找到了一个h，Ein(h)和0很接近，那么也就可以保证Eout(h)也和0接近，由此我们知道Learning是一件可能完成的事情。<br>在这个过程中，有两个核心的问题：</p><ol><li>需要保证Ein(h)和Eout(h)非常接近。</li><li>我们能够找到一个h，使Ein(h)和0非常接近。</li></ol><p>当然，当M是有限的时候，1是能够保证的，但是对于2却不一定能够做到（h数量比较少，不一定能找到一个使Ein(h)逼近0的h）。那么我们就需要一个有很多的（或者说数量是无限的）h的Hypotheses Set。那么一定能够找到一个h，令Ein(h)和0逼近。然而与此同时，坏事情发生的概率却增大了（坏事情定义见四，简单来说就是Ein(h)和Eout(h)相差很大的事件)。当M是一个无限大的数的时候，那么现在的状况可以说是糟糕透了，我们好像根本不能说明Learning能够进行。</p><p>现在我们考虑该怎样接近这件事，首先我们还是要看一看Ein和Eout的霍夫丁不等式：</p><p><img src="1.png" alt="hoeffding"> </p><p>我们接下来要做的是尝试寻找一个多项式mh替换M，如果我们能够将这个无限大的M限制在有限的mh以内，由此Learning便为了可能实现的事情了。</p><p><img src="2.png" alt="mh"> </p><h2 id="Effective-Number-of-Lines"><a href="#Effective-Number-of-Lines" class="headerlink" title="Effective Number of Lines"></a>Effective Number of Lines</h2><p>我们首先考虑M这个数是怎么来的。<br>我们在使用演算法自由自在地选择h的时候，可能会遇到一些BAD DATA，这些BAD DATA会恶化我们的选择。我们在计算这些BAD DATA发生的概率时使用了union bound方法，即将每一个BAD都or了起来，也就是最终的BAD概率是由每一次BAD概率的加和得到的。这也就意味着我们有一个前提假设是“所有的BAD事件都是没有重叠的”。然而当我们考虑M是无限的时候，union bound是否会失败呢？</p><p><img src="3.png" alt="overlap"> </p><p>事实上，就像上图那样，有很多的BAD事件是有重叠的部分的，尤其是那些Eout相近的假设h，此时我们使用union bound来计算BAD的概率，显然是将这些重叠的部分不止一次地重复计算了，由此也导致M变大了。如果我们要计算实际上的M，就要知道这些重叠的部分有多大。</p><p>现在我们设定我们的Hypotheses Set H是二维平面内的直线，那么我们可以知道在H中存在无限条直线。如果我们从我们已有的数据的角度去看这些直线，那会有多少条呢？我们可以设定数据点在直线上方时我们可以将数据标记为o，数据点在下方可以将其标记为x。<br>如果我们只有一个数据点，那么H中只有2条直线，因为从数据点的角度来看，只有一条直线能让它变为o状态，另一条将其变为x状态。如果我们有两个数据点呢？通过枚举，我们可以知道会有4条直线。如果有3个点呢，最多就会有8条直线，然而，可能会出现三个点共线但是同种颜色不相临的情况，这时就不存在一条直线可以将数据点进行标记，也就是所3个点的时候最多是8条。同理，4个数据点的时候由于存在不能区分的情况，只存在14条直线。<br>实际上，我们可以轻易地推论出，数据量N和有效直线数量的关系是：effective(N) &lt;= 2 ** N。现在如果我们能推论出：</p><ol><li>effective(N)可以替代M。</li><li>effective(N)远远小于2 ** N。</li></ol><p>我们就可以说Learning is possible！</p><h2 id="Effective-Number-of-Hypotheses"><a href="#Effective-Number-of-Hypotheses" class="headerlink" title="Effective Number of Hypotheses"></a>Effective Number of Hypotheses</h2><p>现在我们使用Dichotomies(二分类)的概念来继续我们的推论。我们设现有的Hypotheses Set H中是一些直线，H中的每一条直线都能够将点标记为‘o’或者‘x’。Dichotomies的Hypotheses Set是经过上述每一条直线标记后的每一点的状态序列(ooxxx…, etc, depend N)。上面我们经过了讨论，可以知道虽然H是无限的，但是我们的Dichotomies H的上限是2 ** N。<br>我们现在使用Dichotomies H的大小来衡量（或者说替代）M。不过现在它的大小现在还是依赖于我们已经选择好的数据集x1, x2, x3, …。这在以后的证明过程中可能会带来一些麻烦，所以我们从数据集合整体中任意选择N个数据点，取Dichotomy H的大小的最大值作为M的替代着mh(N):</p><p><img src="4.png" alt="mhn"> </p><p>我们将其称为Growth Function（成长函数）。它一定是有限的，上限是2 ** N。我们现在看如何计算成长函数：</p><ol><li>一维的点<br>一种情况如下图所示：<br><img src="5.png" alt="one dim"><br>mh(N) = N + 1，此时当N很大的时候mh(N) &lt;&lt; 2 ** N；<br>另一种情况：<br><img src="6.png" alt="one dim another"><br>此时可以计算：mh(N) = 1 / 2 * N ** 2 + 1 / 2 * N + 1 &lt;&lt; 2 ** N(when N large)。</li><li>凸形集合（convex sets）<br>如果是凸形的封闭曲线的集合对点进行二分类标记，设在曲线内部的点是o，外部的点是x，此时的成长函数是多少呢？<br><img src="7.png" alt="convex sets"><br>假设我们有一系列的点x1，x2，…，xn。我们使用Convex曲线将其分为两部分：<br><img src="8.png" alt="convex split"><br>我们可以计算得到mh(N) = 2 ** N。</li></ol><h2 id="Break-Point"><a href="#Break-Point" class="headerlink" title="Break Point"></a>Break Point</h2><p>上文中我们举出了几个简单的例子观察成长函数：</p><p><img src="9.png" alt="sum"> </p><p>如果现在我们使用成长函数mh(N)替换M：</p><p><img src="2.png" alt="sum"> </p><p>那么，当mh(N)是多项式的时候，那么是可以替换的，此时&lt;=符号是成立的，但是如果mh(N)是指数形式的，就不能肯定了。我们的问题是对于平面的假设或者一般的Perceptrons，mh(N)是多项式的吗？</p><p>我们知道对于2D perceptrons，其grouth function的上界是2 ** N，也就是从某一个点开始，有一些情况是无法分类的，我们把这种点称为Break Point。从Break Point我们可以看到一些希望。</p><p><img src="10.png" alt="breakpoint"> </p><p>通过对Break Point进行观察，我们可以提出一种假说：成长函数的成长速度和Break Point是有关系的，都是和N的（break point - 1）次幂方有关的。如果我们真的能够证明这件事，我们只要找到了Break Point，我们就能证明Learning的可行性！</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（五）&lt;/p&gt;
&lt;p&gt;在第四章中，我们一开始提出来一个问题：Learning好像是不可行的，经过了证明，我们确定了在Hypotheses Set是有限的时候，Learning是可以做到的。然而，在实际的学习任务中，假设空间中往往存在无限多个假设h，那么在这个时候会发生什么呢，Learning能够进行这个结论在这种情况下还能成立吗？&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>04 Feasibility of Learning</title>
    <link href="https://vhdsih.github.io/2018/10/08/mlfound4/"/>
    <id>https://vhdsih.github.io/2018/10/08/mlfound4/</id>
    <published>2018-10-08T11:47:22.000Z</published>
    <updated>2023-10-25T14:44:32.199Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（四）</p><span id="more"></span><h2 id="Learning-is-Impossible"><a href="#Learning-is-Impossible" class="headerlink" title="Learning is Impossible?"></a>Learning is Impossible?</h2><p>虽然我们已经学习了PLA，并使用PLA尝试回答是否问题，但是有一个惊悚的问题我们可能并没有发现：如果对学习没有添加任何限定，Learning可能是做不到的。我们总是在根据有限的数据来选择g，然而对于选择出的g，我们真的能够说g和f最相似吗。这显然是不能的。<br>机器学习中有“No Free Launch”定理，其指出我们没有理由得出对我们已有经验物体之外的推理。<br>那么我们需要添加怎样的假设能够让Learning在理论上可以进行呢？</p><h2 id="Probability-to-the-Rescue"><a href="#Probability-to-the-Rescue" class="headerlink" title="Probability to the Rescue"></a>Probability to the Rescue</h2><p>我们可以从其它场景入手，推论出一些未知的关系：</p><p><img src="1.png" alt="green_red_bin"> </p><p>我们可以想象有这样一个瓶子：</p><ol><li>瓶子中有很多橘黄色和绿色的弹珠。</li><li>我们现在并不知道两种颜色弹珠的数量所占的比例。</li></ol><p>我们能不能通过从瓶子中随便抓一把，从而推断出瓶子中橘黄色弹珠所占的比例呢？（假设弹珠很多，难以计数）。为了表示简单，我们假设：</p><ol><li>橘黄色的弹珠所占的比例为u，u是未知的。</li><li>绿色的弹珠所占的比例为1 - u。</li><li>我们从瓶中抓出一把中橘黄色弹珠所占的比例为v。</li><li>抓出的绿色弹珠比例为1 - v。</li></ol><p>现在问题就转换为了u和v是否相等的问题了。然而，二者可能不相等，因为可能抓出的都是绿色，而瓶子中都是橘黄色的；当然，也可能u和v是很接近的。那么一般来讲，v是否能够表示u呢？为了解决这个问题，我们需要使用到霍夫丁不等式（Hoeffding’s Inequality):</p><p><img src="2.png" alt="hoeffding"> </p><p>该不等式说明了这样一个问题：对于一个很大的N，v和u相差很小（绝对值小于e)。那么根据这个不等式，我们也可以说，当从瓶子中抓取的弹珠很多的时候，v和u相等是大概率可能正确的（PAC：probably approximately correct）。</p><h2 id="Connection-to-Learning"><a href="#Connection-to-Learning" class="headerlink" title="Connection to Learning"></a>Connection to Learning</h2><p>在上面，我们针对有橘黄和绿色弹珠的小球的比例估计问题，使用hoeffding不等式说明了在N足够大的情况下，是能够说明u和v相等是PAC。然而这听起来和我们所要探索的Learning问题没有什么关系。实际上我们可以将Learning问题类比为瓶子弹珠颜色概率问题：<br>我们现在仅仅考虑一个确定的hypoothesis h(x)，我们所要证明的是h(x)和目标函数f(x)是否相同。我们现在假设有这样的一个瓶子，其满足以下要求：</p><ol><li>瓶子中每个球都是一个数据x。</li><li>对瓶子中任意一个球x，如果h(x) == f(x)，那么这个球就是橘黄色的。</li><li>对瓶子中任意一个球x，如果h(x) != f(x)，那么这个球就是绿色的。</li></ol><p><img src="3.png" alt="h-o-g"> </p><p>我们所需要验证的是，当瓶子中的数据数目N很大时，瓶子中的橘黄色球的比例和不在瓶子中的橘黄色球（瓶子中只是我们用来学习的数据，瓶子外还有很多未知的数据）的比例相等这个事件是否PAC。<br>为了方便后续的表示，我们定义两个变量：Ein(h)和Eout(h)，分别用来表示已有数据内的错误概率和未知数据的错误率。</p><p><img src="4.png" alt="eineout"> </p><p>那么类比上一部分的小球实验，对于一个确定的假说h，在“big data”的条件下，根据霍夫丁不等式，我们可以推论出Ein(h)和Eout(h)是很接近的。</p><p><img src="5.png" alt="hoeffdingeineout"> </p><p>那么，如果我们选择一个Ein(h)很小的假说h，我们就可以说 “g = h”是PAC。也就是说，在Learning中，在我们已有的数据上g和f是接近的，那么在未知的数据上，g和f很接近是PAC的。</p><h2 id="Connection-to-Real-Learning"><a href="#Connection-to-Real-Learning" class="headerlink" title="Connection to Real Learning"></a>Connection to Real Learning</h2><p>不过在实际学习任务中，h并不是确定的，我们有很多很多的h等待我们去选择。</p><p><img src="6.png" alt="multiple h"> </p><p>在这种情况下，如果我们验证的所有假说h中有一个hM竟然能够达到最佳的效果（全是绿色的球），但是实际上瓶子中还是有大量的橘黄色的球, 或者说Ein(h)和Eout(h)相差很远。这时候我们根本不能认定这个假说hM是最好的。这件事在概率上是很有可能发生的，而且还是有很大概率会发生的。举个例子，我们的瓶子中不再放球了，而是放硬币：<br><img src="7.png" alt="coin"><br>那么如果每次抛5次，一共抛150次，我们可以计算出出现5次一样的面的概率竟然是99%。<br>霍夫丁不等式只是保证了绝大部分是对的，但是仍然会存在坏的现象，只是几率很小而已。而我们的选择则进一步恶化了这种几率。<br>对于出现上述情况的数据，我们将其称为BAD DATA，也就是说，只要存在一次BAD，那么这些数据就是BAD。我们只有在没有BAD的数据中Learning才能得到正确的结果。<br>我们从hoeffding不等式可知，这些BAD的数据出现的概率是很小的，</p><p><img src="8.png" alt="bad not many"> </p><p>在我们的演算法自由自在选择数据时候，总共的BAD数据出现的概率：</p><p><img src="9.png" alt="all bad"> </p><p>可以得出，其也是很小很小的，因此在有限的h中，不管M、N是多少，选择h都是安全的。也就是在有限的h中，数据足够多，我们就能学习！也就是在这种情况下，机器学习是成立的。</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（四）&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>03 Types of Learning</title>
    <link href="https://vhdsih.github.io/2018/10/08/mlfound3/"/>
    <id>https://vhdsih.github.io/2018/10/08/mlfound3/</id>
    <published>2018-10-08T08:39:37.000Z</published>
    <updated>2023-10-25T14:44:32.211Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（三）</p><p>我们可以使用PLA学习二分类问题。在机器学习中，除了PLA之外，还有其它的学习方法，这些方法有着广泛的应用，本章将对这些方法做一个简要的介绍。</p><span id="more"></span><h2 id="Learning-with-Different-Output-Space-y"><a href="#Learning-with-Different-Output-Space-y" class="headerlink" title="Learning with Different Output Space y"></a>Learning with Different Output Space y</h2><p>根据问题的输出空间的不同，我们可以将机器学习算法分为分类问题（classification）、回归问题(regression)、结构问题（structured）。</p><h3 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h3><p>对于输出是离散值的学习问题，我们将其称为分类（Classification）。典型的二分类问题（Binary Classification），如本课程中常常提到的信用卡发放问题、垃圾邮件分类、答题系统判断对错等。在此基础上，还会有多分类问题（Multiclass Classification），比如硬币分类问题：给出一个硬币，判断是1角钱、5角钱还是1元钱；另一个典型的例子是手写数字的识别。<br>在处理分类问题上，最核心最重要的是二分类问题。</p><h3 id="Regression"><a href="#Regression" class="headerlink" title="Regression"></a>Regression</h3><p>当输出空间是连续的数值时，我们称其为回归问题（Regression）。</p><h3 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h3><p>在自然语言处理问题上，有一个经典的问题是词性标注问题，如果我们将句子的每一个词语输入到学习算法中，它的输出是属于这个词语的类别，这样的问题可以看为是多分类问题。然而，我们知道每个词语的词性并不是固定不变的，它与句子的结构是有关系的，也就是说，句子中隐藏着一些结构信息会影响到最终的输出。我们可以将这样的学习称为结构学习。这样的问题很复杂，但是也有很多的应用。如生物信息问题、语法树等。</p><p>在上述的几个类别中，二分类和回归是最基本最核心的工具。</p><h2 id="Learning-with-Different-Data-Labels-yn"><a href="#Learning-with-Different-Data-Labels-yn" class="headerlink" title="Learning with Different Data Labels yn"></a>Learning with Different Data Labels yn</h2><p>根据学习问题中我们所使用的数据的标签，我们还可以将学习问题分为以下几个类别：</p><h3 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h3><p>即监督学习，可是机器学习中最基础、最常见的学习类型。所谓监督学习，就是对每一个输入x都有其对应的标签y。</p><h3 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h3><p>如果我们的数据只有Input x，但是没有对应的y，我们同样也能学习到一些知识，这种学习就是unsupervised learning。典型的问题如聚类问题等。</p><h3 id="Semi-supervised-Learning"><a href="#Semi-supervised-Learning" class="headerlink" title="Semi-supervised Learning"></a>Semi-supervised Learning</h3><p>在实际工程问题中，可能因为数据量过大，我们的数据只有一部分有标签，而其他的是没有标签的。对于使用这样的数据进行学习的问题，我们称之为半监督学习。</p><h3 id="Reinforcement-Learning"><a href="#Reinforcement-Learning" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h3><p>也称为增强学习。举个例子，比如我们需要训练一只狗做一些简单的动作，我们让其蹲下，它可能做出错误的动作，也可能做出正确的动作。虽然我们难以为它做出示范什么是正确的，但是在狗做出正确的动作的时候，我们可以给它一些奖励，如给它一块饼干，相反，可以给它一些惩罚。这样狗就可以知道自己做的对不对，从而一步一步学会正确的知识。<br>增强学习，就是每一次都给一个反馈，一步一步让系统越来越强。</p><h2 id="Learning-with-Different-Protocol-f-gt-xn-yn"><a href="#Learning-with-Different-Protocol-f-gt-xn-yn" class="headerlink" title="Learning with Different Protocol f -&gt; (xn, yn)"></a>Learning with Different Protocol f -&gt; (xn, yn)</h2><h3 id="Batch-Learning"><a href="#Batch-Learning" class="headerlink" title="Batch Learning"></a>Batch Learning</h3><p>对于一个学习问题，每一次都输入一批数据让系统学习并得到g，叫做批量学习。可以类比填鸭式教育，每一次交给你一堆知识，最后问问你会不会。</p><h3 id="Online-Learning"><a href="#Online-Learning" class="headerlink" title="Online Learning"></a>Online Learning</h3><p>也称为在线学习，每次到来一条数据，都进行学习并得到一个g。</p><h3 id="Active-Learning"><a href="#Active-Learning" class="headerlink" title="Active Learning"></a>Active Learning</h3><p>上述的两种学习方法都是被动学习。能不能让机器自己主动学习呢？如让机器自己提出问题，让后人类给出答案。如果能够有技巧地提出问题，那么机器将能够很快学习到知识。对于label很贵的问题，我们可以使用这种方法。</p><h2 id="Learning-with-Different-Input-Space"><a href="#Learning-with-Different-Input-Space" class="headerlink" title="Learning with Different Input Space"></a>Learning with Different Input Space</h2><p>机器学习的输入是被学习对象的特征，使用更好的训练数据的特征能够提高模型的性能。特征工程就是将原始数据转换为模型的训练数据的过程。</p><h3 id="Concrete-Features"><a href="#Concrete-Features" class="headerlink" title="Concrete Features"></a>Concrete Features</h3><p>每个特征都有其物理意义，比如硬币的尺寸，重量等。这种特征在机器学习中是比较容易的特征。</p><h3 id="Raw-Features"><a href="#Raw-Features" class="headerlink" title="Raw Features"></a>Raw Features</h3><p>一些通常需要通过人类或者机器将其转换为具体特征的特征。比如手写数字图片，输入实际上是每个位置的像素点的灰度数值。我们要做的是怎样根据将这些原始的特征转换。比如1和5，我们可以使用对称性，像素的稠密程度作为具体的特征。</p><h3 id="Abstract-Features"><a href="#Abstract-Features" class="headerlink" title="Abstract Features"></a>Abstract Features</h3><p>更加复杂和困难的特征是抽象特征，其往往没有明确的意义，往往需要进行转换、抽取、重建等。</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（三）&lt;/p&gt;
&lt;p&gt;我们可以使用PLA学习二分类问题。在机器学习中，除了PLA之外，还有其它的学习方法，这些方法有着广泛的应用，本章将对这些方法做一个简要的介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>02 Learning to Answer Yes or No</title>
    <link href="https://vhdsih.github.io/2018/10/07/mlfound2/"/>
    <id>https://vhdsih.github.io/2018/10/07/mlfound2/</id>
    <published>2018-10-07T12:21:00.000Z</published>
    <updated>2023-10-25T14:44:32.253Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（二）<br>我们已经知道，机器学习模型由两部分组成：演算法和Hypothesis Set。如果我们想要让计算机学习去回答答案为是、否这样的问题时（就像第一章中的信用卡发放的问题那样），我们需要怎样的演算法，我们又应该使用什么样的hypothesis set呢？</p><span id="more"></span><h2 id="Perceptron-Hypothesis-Set"><a href="#Perceptron-Hypothesis-Set" class="headerlink" title="Perceptron Hypothesis Set"></a>Perceptron Hypothesis Set</h2><p>有一种简单的Hypothesis Set可以做这件事，这种Hypothesis Set是the Perceptron。<br>我们仍然以银行是否发放信用卡为例子，我们令每一位顾客的信息为x，其中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (x1, x2, x3, x4, ..., xd)</span><br></pre></td></tr></table></figure><p>即针对该任务，需要考虑d个用户的特征。我们需要学习一个权重向量（决定这d个特征那个更重要）w：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = (w1, w2, w3, ..., wd)</span><br></pre></td></tr></table></figure><p>我们设定一个阈值threshold，当所有特征和权重乘积的和大于threshold时，可认为是被接受的，否则则是被拒绝的。用数字来表示可以认为前者为1，后者为-1。用数学表示该公式为h(x):<br><img src="1.png" alt="hx"><br>当然我们还可以将上面的公式进一步化简，即将threshold当成一个属性，其权重为1，然后我们将它用向量来表示，具体过程如下：<br><img src="2.png" alt="hx-format"><br>这样做以后计算过程就变成了两个向量的内积了</p><p>上面描述了Perceptron function是什么，那么它们长什么样子呢？在R2（二维空间）中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h(x) = sign(w0 + w1 * x1 + w2 * x2)</span><br></pre></td></tr></table></figure><p>其实就是一条直线，可以将平面上的点分为两部分。而在更高维度的空间上，其表现为一组超平面，可以将空间内的点分为两个部分。最终我们需要另接受的点在直线（超平面）的一端，被拒绝的点在另一端。</p><h2 id="Perceptron-Learning-Algorithm"><a href="#Perceptron-Learning-Algorithm" class="headerlink" title="Perceptron Learning Algorithm"></a>Perceptron Learning Algorithm</h2><p>Perceptron Hypothesis Set中包含了无数条（infinite）直线（或超平面），我们需要从中选出一条最适合的’g’。我们不知道f，唯一知道的是数据是由f产生的，理想中的g必须让我们看过的资料的结果和f产生的一模一样。但是g太多了，计算起来太困难了。<br>我们的一个解决方法是从任意一个g0开始（其权重为w0），每次调整使其越来越好，最终找到一条没有更多错误的g。<br>例如：我们由w0开始，使用数据集中犯错的点来纠正它。当我们的向量是wt时，我们发现一个错误点是(xn, yn)，sign(wt * xn) != yn; 此时我们的纠正方式如下：<br><img src="3.png" alt="wt"><br>上述方法的本质是让每一次w的更新都能使得直线向正确的方向移动。最终找不到更多错误的时候就找到最终的g了。</p><h2 id="Guarantee-of-PLA"><a href="#Guarantee-of-PLA" class="headerlink" title="Guarantee of PLA"></a>Guarantee of PLA</h2><p>然而，我们面临的一个问题是PLA真的能顺利进行吗？PLA如果最终能够停止（找到了最好的g），那么前提条件是数据集必须线性可分（Linear Separability），我们假设我们所给的数据集是线性可分的，那么此时我们能否证明PLA一定可以停止吗？<br>可以这样思考，当存在一个完美的wf，使得yn = sign(wft * xn) (wft是wf的转置),此时得到的g就是最好的。此时必定满足：<br><img src="4.png" alt="wf"><br>此外，从数学的角度说，两个单位向量内积越大，则说明两个向量越接近。那么有下面的计算：<br><img src="5.png" alt="wfwt+1"><br>可以说明，每一次更新wf和wt的乘积都是越来越大的（注意：因为没有考虑wf和wt的长度，所以此时不能说明wf和wt是在靠近）。因此我们考虑PLA算法的一个重要的性质：仅仅针对错误点更新，因此，必定有：<br><img src="6.png" alt="signynerror"><br>我们再看wt+1是什么样子的：<br><img src="7.png" alt="growthslowly"><br>可以说明wt增大缓慢，成长值只会受到xn项影响。xn ** 2最多长max||xn|| ** 2。我们计算将wf和wt正规化后内积：<br><img src="8.png" alt="signynerror"><br>随着次数的增大，越来越大，即使wt和wf越来越靠近。因此对于线性可分的数据PLA最终是可以停止的。</p><h2 id="Non-Separable-Data"><a href="#Non-Separable-Data" class="headerlink" title="Non-Separable Data"></a>Non-Separable Data</h2><p>我们已经证明了，在数据是线性可分的前提下PLA算法是可以停止的，PLA算法好处是简单快速，几十行代码就可以搞定，对任意维度的数据都是有效的。但是你有没有发现矛盾的地方？<br>前面，PLA执行的前提是假设数据线性可分，那到底可不可分，我们需要做了实验才知道，可是做了实验又多久会停止？没停止可能是没有找到最好的g，也可能是数据根本不可分。那么怎样在一个含有噪音的数据集上寻找到一条犯错最少的线（定义为最好的线）呢？目前没有最好的方法，这是一个np难的问题。<br>我们可以使用Pocket Algorithm，它是PLA的一个变形，根本上是一种贪心的思想，每一次都keep best weights in pocket。直到看过了足够多的线，就认为它是最好的。</p><p>但是Pocket Algorithm要比PLA慢。</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（二）&lt;br&gt;我们已经知道，机器学习模型由两部分组成：演算法和Hypothesis Set。如果我们想要让计算机学习去回答答案为是、否这样的问题时（就像第一章中的信用卡发放的问题那样），我们需要怎样的演算法，我们又应该使用什么样的hypothesis set呢？&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>01 The Learning Problem</title>
    <link href="https://vhdsih.github.io/2018/10/07/mlfound1/"/>
    <id>https://vhdsih.github.io/2018/10/07/mlfound1/</id>
    <published>2018-10-07T08:21:24.000Z</published>
    <updated>2023-10-25T14:44:32.257Z</updated>
    
    <content type="html"><![CDATA[<p>《机器学习基石》系列课程（一）</p><p>感谢台湾大学林轩田老师！</p><p>该系列文章通过我在学习林轩田老师的“机器学习基石”课程的笔记整理而来，用以巩固所学。内容共分为16章，将陆续发布！</p><p>本章是学习机器学习的第一章，将对机器学习做一个简要的介绍，包括什么是机器学习，什么时候可以用机器学习，机器学习的应用领域以及机器学习与一些学科的异同等。</p><span id="more"></span><h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><p>我们常说“学习”，当其主体是人类的时候，学习是你我通过观察，将经验转化为技巧的过程。而对于计算机来说，它的学习则是模仿人类的行为，所不同的是其是从数据出发，通过计算，进而能够达到目标任务的性能表现的提高。当计算机在这个过程中提高了性能，我们就可以说它学到了技巧。<br>传统的学习任务往往制定很多规则，而使用机器学习的方法可能要比制定几百条规则所得到的任务完成效果要好很多。<br>机器学习的一个更加具体的定义：从资料出发，计算出一个假说g，并使g最接近我们需要的函数f。</p><h2 id="什么时候可能用到机器学习"><a href="#什么时候可能用到机器学习" class="headerlink" title="什么时候可能用到机器学习"></a>什么时候可能用到机器学习</h2><ol><li>对于一些人类很难编写的任务可能会用到机器学习，比如火星探测器，其往往难以在发射之前就能做出完美的预案，需要学习来处理一些新情况。</li><li>对于难以写出规则的任务，如视觉和语音的识别，仅仅依靠规则很难完成这样的任务。</li><li>对于一些需要快速决策的任务，人类很难胜任，例如股票市场中，有时需要短时间做出决策，但面对大量的数据量人类往往束手无策。</li></ol><h2 id="机器学习的关键"><a href="#机器学习的关键" class="headerlink" title="机器学习的关键"></a>机器学习的关键</h2><ol><li>需要有知识可以被学到（或者说包含隐藏的模式），对于不能学习到新知识的任务应用机器学习是没有意义的。</li><li>任务不能或者很难定义规则。</li><li>需要有足够的数据来支撑。</li></ol><h2 id="机器学习的应用领域"><a href="#机器学习的应用领域" class="headerlink" title="机器学习的应用领域"></a>机器学习的应用领域</h2><p>ml is everywhere! 在衣食住行娱乐教育等各个领域都能看到它的应用。</p><h2 id="机器学习的具体过程"><a href="#机器学习的具体过程" class="headerlink" title="机器学习的具体过程"></a>机器学习的具体过程</h2><p>当前有这样一个任务：银行需要根据信用卡申请人的个人信息来决定是否通过他的申请，考虑因素可能包括申请人的负债情况、消费能力等等。当我们面对这样的一个问题时，机器学习的处理方式一般如下所示：</p><p>输入和输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x: input # 申请人信息</span><br><span class="line">y: output # 是否发卡</span><br></pre></td></tr></table></figure><p>有这样一个隐含的模式需要学习，或者称之为目标函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f: x -&gt; y # target function </span><br></pre></td></tr></table></figure><p>我们已经有的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D = &#123;(x1, y1), (x2, y2), ..., (xn, yn)&#125;</span><br></pre></td></tr></table></figure><p>最终学习一个hypothesis g（我们不知道f， 需要从数据中学习到g），当g和f越相似越好（当然，求得一个和f相同的g是最好的，但是再实际任务上很难做到）。</p><h2 id="机器学习模型"><a href="#机器学习模型" class="headerlink" title="机器学习模型"></a>机器学习模型</h2><p>机器学习模型由两部分组成：演算法 + hypothesis set。</p><p>其中hypothesis set H 包含很多假设，其中也有好的假设也有坏的假设。<br>而演算法则用于在H中选择最好的g。</p><h2 id="机器学习与其他学科"><a href="#机器学习与其他学科" class="headerlink" title="机器学习与其他学科"></a>机器学习与其他学科</h2><h3 id="数据挖掘-（Data-Mining）"><a href="#数据挖掘-（Data-Mining）" class="headerlink" title="数据挖掘 （Data Mining）"></a>数据挖掘 （Data Mining）</h3><p>机器学习的目的是通过计算学习到一个最接近f的假说f，而数据挖掘则是使用大量数据寻找有趣的性质。<br>二者的区别是其目的。它们可以相互利用以提高性能。这两个领域是密不可分的。</p><h3 id="人工智能-（Artificial-Intelligence）"><a href="#人工智能-（Artificial-Intelligence）" class="headerlink" title="人工智能 （Artificial Intelligence）"></a>人工智能 （Artificial Intelligence）</h3><p>AI：compute something that shows intelligent behavior.<br>机器学习是AI的一种实现方式。</p><h3 id="统计学-（Statistics）"><a href="#统计学-（Statistics）" class="headerlink" title="统计学 （Statistics）"></a>统计学 （Statistics）</h3><p>统计学使用数据预测未知的概率。是ML的一种方法，很多机器学习方法来源于统计学。</p><blockquote><p>文章内容和图片均来自“国立台湾大学林轩田老师”的《机器学习基石》课程！</p></blockquote><p>— END —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《机器学习基石》系列课程（一）&lt;/p&gt;
&lt;p&gt;感谢台湾大学林轩田老师！&lt;/p&gt;
&lt;p&gt;该系列文章通过我在学习林轩田老师的“机器学习基石”课程的笔记整理而来，用以巩固所学。内容共分为16章，将陆续发布！&lt;/p&gt;
&lt;p&gt;本章是学习机器学习的第一章，将对机器学习做一个简要的介绍，包括什么是机器学习，什么时候可以用机器学习，机器学习的应用领域以及机器学习与一些学科的异同等。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="林轩田" scheme="https://vhdsih.github.io/tags/%E6%9E%97%E8%BD%A9%E7%94%B0/"/>
    
    <category term="machine learning" scheme="https://vhdsih.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>在windows上编译opencv</title>
    <link href="https://vhdsih.github.io/2018/05/03/install-opencv-on-windows/"/>
    <id>https://vhdsih.github.io/2018/05/03/install-opencv-on-windows/</id>
    <published>2018-05-03T01:22:03.000Z</published>
    <updated>2023-10-25T14:45:43.819Z</updated>
    
    <content type="html"><![CDATA[<p>一直习惯了使用manjaro的aur搭建编程环境，对于opencv的搭建过程基本就是几条命令就可以完成。这几天使用windows搭建opencv开发环境，竟然用了一天半才编译成功。虽然opencv 的编译过程基本差别不大，但是编译过程中会存在一些小的问题致使编译失败。下面有几个需要注意的事情。</p><span id="more"></span><p>我的基本环境是windows10，version-1803，python-3.65，opencv-3.41，opencv-contrib-3.41，Mingw-w64（not visual studio），cmake-3.11.1。</p><p>网上已有的教程基本大同小异，如下面的编译过程：</p><blockquote><p><a href="https://www.cnblogs.com/xinxue/p/5766756.html">https://www.cnblogs.com/xinxue/p/5766756.html</a></p></blockquote><p>下面是几点需要注意的地方：</p><ol><li>注意opencv和opencv-contrib的版本需要一致。</li><li>我使用Mingw-w64生成Makefile，然后使用make和make install完成编译过程。因此在使用cmake时，第一次点选configure需要选择MingW Makefile。</li><li>上述过程同样可以使用visual studio，但是需要注意vs的版本和位数（32 or 64）。选择中不带64的就是32位的，否则就是64的。很多教程都使用了vs，这里就不再赘述了。</li><li>注意python版本，如果系统是64位的，前面也用到了64位的（mingw 或vs），必须安装64位python。</li></ol><p>几个问题：</p><ol><li><p>“‘::hypot’ has not been declared”</p><p>确认你是否使用了32位python，如果是，请卸载并安装64位python。</p></li><li><p>“error invalid register for .seh_savexmm “</p><p>3.41版本会出现这个问题，<a href="https://github.com/opencv/opencv/pull/10936">github上已经解决了这个问题</a>，这里<a href="https://github.com/opencv/opencv/pull/10936/files">修改了两个文件</a>，照着改一下就可以。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;一直习惯了使用manjaro的aur搭建编程环境，对于opencv的搭建过程基本就是几条命令就可以完成。这几天使用windows搭建opencv开发环境，竟然用了一天半才编译成功。虽然opencv 的编译过程基本差别不大，但是编译过程中会存在一些小的问题致使编译失败。下面有几个需要注意的事情。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="opencv" scheme="https://vhdsih.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>LinuxShell3 - more commands</title>
    <link href="https://vhdsih.github.io/2018/04/28/LinuxShell3/"/>
    <id>https://vhdsih.github.io/2018/04/28/LinuxShell3/</id>
    <published>2018-04-28T05:31:28.000Z</published>
    <updated>2023-10-25T14:45:30.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="终端录制"><a href="#终端录制" class="headerlink" title="终端录制"></a>终端录制</h2><p>使用 script 和 scriptreplay 可以实现终端命令的录制播放。通常，录制视频需要大量的空间，而使用此命令得到的仅仅是文本文件，大小一般是KB级别的。 </p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 录制</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> script -t 2&gt; timing.log -a output.session</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Input Your Commands</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 播放</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> scriptreplay timing.log output.session</span></span><br></pre></td></tr></table></figure><h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>checksum用来从文件中生成校验和秘钥，然后利用这个校验和秘钥核实文件的完整性。使用校验和可以确保文件在传输过程中没有损坏。<br>最知名和最广泛使用的校验和技术是md5sum和SHA-1。它们对文件内容使用相应的算法来生成校验和。</p><ol><li><p>md5sum<br> 使用md5sum直接计算文件的md5sum</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> md5sum filename</span></span><br><span class="line">3234234... filename</span><br></pre></td></tr></table></figure><p> 输出的md5序列是一个16进制的字符串。我们可以将生成的md5重定向到一个文件md5sum.md5，然后用这个文件来核实数据的完整性</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum file &gt; md5sum.md5</span><br></pre></td></tr></table></figure><p> 当对多个文件求checksum时，输出的每一行为每个文件的checksum</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> md5sum file1 file2 file3</span></span><br><span class="line">[checksum1] file1</span><br><span class="line">[checksum2] file2</span><br><span class="line">[checksum3] file3</span><br></pre></td></tr></table></figure><p> 进行校验使用如下的命令参数</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> md5sum -c file.md5</span></span><br></pre></td></tr></table></figure></li><li><p>SHA-1<br> sha-1与md5sum使用方法类似，只需要将md5sum替换为sha1sum即可。</p></li><li><p>补充内容<br> 对于多个文件和文件夹，可以使用md5deep或sha1deep，你可能需要安装这些命令。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> md5deep -rl path &gt; dir.md5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r 表示使用递归，-l表示使用相对路径</span></span><br></pre></td></tr></table></figure><p> 当然，你也可以使用find命令来完成这个任务</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find path -type f -print0 | xargs -0 md5sum &gt;&gt; dir.md5</span><br></pre></td></tr></table></figure></li></ol><h2 id="加密和散列"><a href="#加密和散列" class="headerlink" title="加密和散列"></a>加密和散列</h2><p>加密技术可以防止数据遭到未被授权的访问。常见的加密和散列的工具包括：crypt、gpg、base64、md5sum、sha1sum以及openssl</p><ol><li><p>crypt</p><p> crypt是一个简单的加密工具，它从stdin接受一个文件以及口令作为输入，然后将加密后的数据输出到stdout。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> crypt &lt;input-file&gt; output-file</span></span><br><span class="line">Enter passphrase:</span><br></pre></td></tr></table></figure><p> 该命令需要输入一个口令。同样，我们也可以通过命令行参数提供口令：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> crypt PASSPHRASE -d &lt;encrypted-file&gt; output-file</span></span><br></pre></td></tr></table></figure></li><li><p>gpg<br> gpg(GNU隐私保护)是一种使用广泛的工具，它使用加密技术保护文件，确保数据到达目的地之前不会被读取。gpg签名同样用于电子邮件签名，从而证明发送方的真实性。<br> gpg加密</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> gpg -c filename</span></span><br></pre></td></tr></table></figure><p> 通过交互方式读取口令，生成filename.gpg，使用下面命令解密：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg filename.gpg</span><br></pre></td></tr></table></figure><p> 此外，base64、md5sum 和 sha1sum使用方法类似。</p></li><li><p>shadow-like散列(salt散列)</p><p> 例如存储在’/etc/shadow’下的用户密码，我们可以利用openssl生成shadow密码。shadow密码通常都是salt密码。所谓SALT就是额外的一个字符串，用来起混淆的作用，使密码难以破解。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> openssl passwd -1 -salt SALT PASSWD</span></span><br></pre></td></tr></table></figure><p> 其中，SALT和PASSWD分别是你的字符串和密码。</p></li></ol><h2 id="排序、唯一、重复"><a href="#排序、唯一、重复" class="headerlink" title="排序、唯一、重复"></a>排序、唯一、重复</h2><p>使用sort对文本和stdin排序，利用uniq去重。</p><ol><li><p>基础内容</p><p> 对一组文件排序</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sort file1 file2 file3 &gt; result.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sort file1 file2 file3 -o result.txt</span></span><br></pre></td></tr></table></figure><p> 也可以改变排序的顺序和确定顺序的依据</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 逆序</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sort -r file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照数字顺序</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sort -n file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照月份</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sort -M monthes.txt</span></span><br></pre></td></tr></table></figure><p> 合并两个有序的文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">sort -m file1 file2</span></span><br></pre></td></tr></table></figure><p> 找出有序文件中的不重复的行</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sort file1 file2 | unique</span></span><br></pre></td></tr></table></figure><blockquote><p>执行’sort -C filename’命令的返回值和文件是否有序有关系。如果文件有序，则返回0，否则返回非0。</p></blockquote></li><li><p>sort的复杂用法</p><p> sort可以对包含键值对结构的数据根据键或者列来进行排序，例如，我们有如下数据：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat data.txt</span></span><br><span class="line">1 mac 2000</span><br><span class="line">2 win 4000</span><br><span class="line">3 bsd 1000</span><br><span class="line">4 linux 1000</span><br></pre></td></tr></table></figure><p> 上述数据目前使用第一列的序号进行排序，我们也可以自行指定第二或者第三列进行排序。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sort -nrk 1</span></span><br><span class="line">4 linux 1000</span><br><span class="line">3 bsd 1000</span><br><span class="line">2 win 4000</span><br><span class="line">1 mac 2000</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sort -k 2</span></span><br><span class="line">3 bsd 1000</span><br><span class="line">4 linux 1000</span><br><span class="line">1 max 2000</span><br><span class="line">2 win 4000</span><br></pre></td></tr></table></figure><blockquote><p>要注意的是参数’-n’指的是使用数字顺序进行排序。如果需要以数字顺序排序，必须显示指出该参数。</p></blockquote><p> 此外，可以使用参宿’-b’忽略空格等多余字符，使用’-d’以字典序进行排序。也可以明确指明行内某些字符作为排序键，只需要指明起始位置：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sort -nk 1,4 data.txt</span></span><br></pre></td></tr></table></figure></li><li><p>uniq</p><blockquote><p>uniq的输入必须是有序的数据</p></blockquote><p> 该命令通过消除重复的内容，从给定的数据中找到唯一的行，也可以用来寻找重复的行。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat sorted.txt</span></span><br><span class="line">bash</span><br><span class="line">foss</span><br><span class="line">hack</span><br><span class="line">hack</span><br><span class="line"><span class="meta">#</span><span class="bash"> 去除重复</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> uniq sorted.txt</span></span><br><span class="line">bash</span><br><span class="line">foss</span><br><span class="line">hack</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sort unsorted.txt | uniq</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 唯一</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> uniq -u sorted.txt</span></span><br><span class="line">bash</span><br><span class="line">foss</span><br></pre></td></tr></table></figure><p> 统计每一行的数目</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sort unsorted.txt | uniq -c</span></span><br><span class="line">    1 bash</span><br><span class="line">    1 foss</span><br><span class="line">    2 hack</span><br></pre></td></tr></table></figure><p> 列出重复的行</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sort unsorted.txt | uniq -d</span></span><br><span class="line">hack</span><br></pre></td></tr></table></figure><p> 结合’-s’和’-w’参数可以指定键。其中s参数表示跳过前n个字符，w参数指定用于比较的最大的字符数目。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat data.txt</span></span><br><span class="line">u:01:gnu</span><br><span class="line">d:04:linux</span><br><span class="line">u:01:bash</span><br><span class="line">u:01:hack</span><br></pre></td></tr></table></figure><p> 对于上述文件，我们希望仅仅对其中的数字进行比较</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sort data.txt | uniq -s 2 -w 2</span></span><br><span class="line">d:04:linux</span><br><span class="line">u:01:bash</span><br></pre></td></tr></table></figure></li></ol><h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>Linux 的临时文件的存储目录为’/tmp’。其中的内容在每一次系统重启以后都会被清空。我们在创建临时文件时，可以采用不同的方法来为临时数据生成标准的文件名。</p><p>使用mktemp在’/tmp’目录中生成一个临时文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> filename=`mktemp`</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$filename</span></span></span><br><span class="line">/tmp/tmp.Adsijidi</span><br></pre></td></tr></table></figure><p>使用’-d’参数生成目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> dirname=`mktemp -d`</span></span><br></pre></td></tr></table></figure><p>如果仅仅需要名字，不需要在磁盘中创建相应文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> tempfile= `mktemp -u`</span></span><br></pre></td></tr></table></figure><p>根据模板创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> mktemp test.XXX</span></span><br><span class="line">test.ase</span><br></pre></td></tr></table></figure><blockquote><p>使模板正常工作，至少需要3个’X’</p></blockquote><h2 id="文件分割"><a href="#文件分割" class="headerlink" title="文件分割"></a>文件分割</h2><p>当需要将一个大文件分割成多个小文件时，我们需要使用’split’命令。下面是几种不同的文件分割方法。</p><p>按照大小分割。例如将一个大小为100KB的文件分割为每一个为10KB的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> split -b 10k input.data</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ls</span></span><br><span class="line">input.data xaa xab ...</span><br></pre></td></tr></table></figure><p>切分以后，文件名以xaa、xab命名。如果以数字为后缀，可以使用参数’-d’，使用’-a’来限制后缀的长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> split -b 10k input.data -d -a 4</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ls</span></span><br><span class="line">input.data x0009 x0019 ...</span><br></pre></td></tr></table></figure><p>此外，除了k以外，还可以使用M、G、c（byte）、w（word）等后缀。</p><p>制定文件前缀名：在命令后添加前缀名即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> split -b 10k data.file d -a 4 split_file</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ls</span></span><br><span class="line">split_file0000    split_file0001 ...</span><br></pre></td></tr></table></figure><p>使用参数”-l nu_of_lines”按照数据的行数来进行切分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; split -l 10 data.txt</span><br><span class="line"># 得到各是10行的文件</span><br></pre></td></tr></table></figure><blockquote><p>Another One: csplit</p></blockquote><p>csplit 是split的一个变体。后者仅仅能根据文件的大小和行数进行切分，但是前者可以根据文本自身的特点进行分割。是否存在某个单词或者文本内容都可以作为分割文件的条件。</p><p>有如下的日志文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat server.log </span><br><span class="line">SERVER-1</span><br><span class="line">[connection] 192.168.0.1 success </span><br><span class="line">[connection] 192.168.0.2 failed </span><br><span class="line">[disconnect] 192.168.0.3 pending </span><br><span class="line">[connection] 192.168.0.4 success </span><br><span class="line">SERVER-2 </span><br><span class="line">[connection] 192.168.0.1 failed </span><br><span class="line">[connection] 192.168.0.2 failed </span><br><span class="line">[disconnect] 192.168.0.3 success </span><br><span class="line">[connection] 192.168.0.4 failed </span><br><span class="line">SERVER-3 </span><br><span class="line">[connection] 192.168.0.1 </span><br><span class="line">pending [connection] 192.168.0.2 </span><br><span class="line">pending [disconnect] 192.168.0.3 </span><br><span class="line">pending [connection] 192.168.0.4 failed</span><br></pre></td></tr></table></figure><p>任务是将上述的文件分割为server1.log、server2.log和server3.log。可以使用如下的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csplit server.log /SERVER/ -n 2 -s &#123;*&#125; -f server -b &quot;%02d.log&quot; ; rm server00.log</span><br></pre></td></tr></table></figure><p>其中/SERVER/用来匹配一行，{*}表示重复执行分割，直至文件结尾。*可以替换为数字表示执行分割的次数。-s表示静默方式，不打印其他信息，-n表示分割文件后的文件名后缀的数字的个数。-f表示分割文件的前缀，-b表示后缀的格式。在这里文件名即前缀加后缀。</p><blockquote><p>根据扩展名切分文件名</p></blockquote><p>借助”%”符号可以方便将“名称.扩展名”这种名称提取出来。对于sample.jpg，下面是一个例子，将名称提取出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file=&quot;sample.jpg&quot;</span><br><span class="line">name=$&#123;file%.*&#125;</span><br><span class="line">echo name is $name</span><br><span class="line"></span><br><span class="line">output: name is sample</span><br></pre></td></tr></table></figure><p>对于${VAR%.*}的含义如下：首先删除位于%右侧的通配符，上述例子为”.*“，通配符由右侧向左侧进行匹配。然后为VAR赋值。对于sample.jpg，首先通配符匹配到.jpg，删除通配符对VAR进行赋值，得到sample。</p><p>注意”%”是非贪婪模式，仅仅匹配从右到左的最短的结果。还有一个是”%%”，但是该模式是从右到左贪婪的，即匹配最长结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> VAR=hack.fun.book.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR%.*&#125;</span></span></span><br><span class="line">hack.fun.book</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR%%.*&#125;</span></span></span><br><span class="line">hack</span><br></pre></td></tr></table></figure><blockquote><p>删除前缀</p></blockquote><p>使用#和##可以删除前缀。其用法与%类似，不同的是其是从左向右匹配的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> VAR=hack.fun.book.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR#*.&#125;</span></span></span><br><span class="line">fun.book.txt</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;VAR##*.&#125;</span></span></span><br><span class="line">txt</span><br></pre></td></tr></table></figure><h2 id="并行加速"><a href="#并行加速" class="headerlink" title="并行加速"></a>并行加速</h2><p>如果需要你的程序需要进行大量的计算，属于cpu密集的应用，为了提高运行效率，就应该充分利用多核。</p><p>举个栗子：对多个文件进行md5sum计算：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file name is md5.sh</span></span><br><span class="line"></span><br><span class="line">PIDARRAY=()</span><br><span class="line">for file in F1.iso F2.iso</span><br><span class="line">do</span><br><span class="line">    md5sum $file &amp;</span><br><span class="line">    PIDARRAY+=(&quot;$!&quot;)</span><br><span class="line">done</span><br><span class="line">wait $&#123;PIDARRAY[@]&#125;</span><br></pre></td></tr></table></figure><p>当执行上述脚本时，获得的结果与下面的运行结果相同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum F1.iso F2.iso</span><br></pre></td></tr></table></figure><p>但是由于多个命令是并行执行的，可以更快得到结果。其工作原理就是使用’&amp;’操作符将shell命令置于后台执行。为了避免循环结束时脚本退出，使用$!获取最后一个进程的PID，使用wait来等待这些进程。</p><h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><p>利用rename、mv结合find，命令可以实现批量操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">文件名: rename.sh</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">用途: 重命名 .jpg 和 .png 文件</span> </span><br><span class="line">count=1; </span><br><span class="line">for img in `find . -iname &#x27;*.png&#x27; -o -iname &#x27;*.jpg&#x27; -type f -maxdepth 1` </span><br><span class="line">do </span><br><span class="line">new=image-$count.$&#123;img##*.&#125; </span><br><span class="line">echo &quot;Renaming $img to $new&quot; </span><br><span class="line">mv &quot;$img&quot; &quot;$new&quot; </span><br><span class="line">let count++ </span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出如下：</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./rename.sh</span> </span><br><span class="line">Renaming hack.jpg to image-1.jpg </span><br><span class="line">Renaming new.jpg to image-2.jpg </span><br><span class="line">Renaming next.png to image-3.png</span><br></pre></td></tr></table></figure><blockquote><p>参考：Linux Shell 脚本攻略</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;终端录制&quot;&gt;&lt;a href=&quot;#终端录制&quot; class=&quot;headerlink&quot; title=&quot;终端录制&quot;&gt;&lt;/a&gt;终端录制&lt;/h2&gt;&lt;p&gt;使用 script 和 scriptreplay 可以实现终端命令的录制播放。通常，录制视频需要大量的空间，而使用此命令得到的仅仅是文本文件，大小一般是KB级别的。 &lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="shell" scheme="https://vhdsih.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>LinuxShell2 - cat, find, xargs and tr</title>
    <link href="https://vhdsih.github.io/2018/04/17/LinuxShell2/"/>
    <id>https://vhdsih.github.io/2018/04/17/LinuxShell2/</id>
    <published>2018-04-17T02:53:39.000Z</published>
    <updated>2023-10-25T14:47:32.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>cat通常用于读取、显示或者拼接文件内容，也可以用将来自标准输入和文件的数据进行组合。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 读取文件内容的一般写法：</span></span><br><span class="line">cat file1 file2 ...</span><br></pre></td></tr></table></figure><p>将标准输出和文件中的内容拼接在一起</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;a&#x27;</span> &gt; test.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;b&#x27;</span> | cat - test.txt <span class="comment"># - 作为stdin文件的文件名</span></span></span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>使用参数 ‘-s’ 压缩相邻的空白行，另外，对于这个任务也可以使用 ‘tr’ 命令实现</li><li>使用参数 ‘-T’ 使用’^I’显示Tab。</li><li>使用参数 ‘-n’ 在显示过程中添加行号。使用 ‘-b’ 忽略对空行的标号。</li><li>其他参数，请查看man手册。</li></ul><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find是Unix/Linux上最棒的工具之一，也是很复杂的命令之一，但是许多人并没有真正掌握它。<br>find命令的工作原理是沿着文件的层次结构向下遍历，匹配符合匹配条件的文件，并且执行相应的操作。下面是find指令的基本的应用场景和使用方法。</p><ol><li><p>开始<br> 列出某一个目录下的所有文件和文件夹。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> find base_path</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> example</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find /home/somebody/Musics</span></span><br><span class="line">output dirs and files</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用参数 -<span class="built_in">print</span> 打印</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果不用该参数会将所有文件打印出来</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时使用<span class="string">&#x27;\n&#x27;</span>分隔</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用参数 -print0 打印</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时使用<span class="string">&#x27;\0&#x27;</span>分隔</span></span><br></pre></td></tr></table></figure></li><li><p>使用正则搜索<br> 使用’-name’参数指明文件名必须要匹配的字符串。同时，也可以使用通配符，如’*.txt’表明所有以txt结尾的文件。然后使用’-print’打印目标。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在某目录下寻找所有的以txt结尾的文件并且打印出来</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find /home/me/ -name <span class="string">&#x27;*.txt&#x27;</span> -<span class="built_in">print</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> 使用参数’-iname’忽略字母大小写，其作用与’-name’类似，只不过该参数忽略大小写。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ls</span></span><br><span class="line">A.txt B.TXT</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -name <span class="string">&#x27;*.txt&#x27;</span> -<span class="built_in">print</span></span></span><br><span class="line">A.txt</span><br><span class="line">B.TXT</span><br></pre></td></tr></table></figure><p> 匹配多种文件，使用or操作。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ls</span></span><br><span class="line">a.txt b.pdf c.md</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . \( -name <span class="string">&#x27;*.txt&#x27;</span> -o -name <span class="string">&#x27;*.pdf&#x27;</span> \) -<span class="built_in">print</span></span></span><br><span class="line">a.txt</span><br><span class="line">b.pdf</span><br></pre></td></tr></table></figure><p> 选项’-path’来匹配文件路径。’-name’参数总是对给定的文件名进行匹配，而’-path’则将文件路径作为一个整体进行匹配。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -path <span class="string">&#x27;*/linux/*&#x27;</span> -<span class="built_in">print</span></span></span><br></pre></td></tr></table></figure><p> 选项’-regex’的参数和’-path’类似，但是前者是基于正则表达式进行的。正则表达式是通配符的高级形式。下面是几个例子：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匹配所有的py文件和sh文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -regex <span class="string">&quot;.*\(\.py\|\.sh\)$&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 匹配过程忽略大小写</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -iregex <span class="string">&quot;.*\(\.py\|\.sh\)$&quot;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>后续会有另外的博文介绍正则表达式!</p></blockquote></li><li><p>否定参数<br> find命令可以使用’!’否定命令参数，表示寻找不匹配某种模式的文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 寻找不以txt为结尾的文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . ! -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span></span></span><br></pre></td></tr></table></figure></li><li><p>基于目录深度的搜索<br> 在find指令运行过程中，可以采用深度选项来限制find遍历目录的深度。<br> 可以设置’-maxzdepth’指定最大深度，使用’-mindepth’设置最小的深度。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录下寻找以f开头的文件或者目录</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -maxdepth 1 -name <span class="string">&quot;f*&quot;</span> -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印距离当前目录最少有两个目录的文件（f开头）</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -mindepth 2 -name <span class="string">&quot;f*&quot;</span> -<span class="built_in">print</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注：-maxdepth和-mindepth两个参数应该作为find的第三个参数出现，否则将会影响到find的效率。因为find就不得不做一些不必要的检查。例如，当-type是第三个参数，-maxdepth是第四个参数，则会首先寻找符合type的文件，然后检查目录层次。反过来，会先检查目录层次，到达指定层次以后就不会继续深入了。</p></blockquote></li><li><p>根据文件类型搜索<br> Unix类操作系统将一切视为文件，文件类型包括普通文件，目录，符号链接，硬链接，字符设别，块设备，套接字，FIFO等。<br> 可以使用’-type’按照文件类型进行过滤。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出目录</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> d -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 普通文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> f -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 符号链接</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> l -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 字符设备 -- c</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 块设别   -- b</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 套接字   -- s</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FIFO     -- p</span></span><br></pre></td></tr></table></figure></li><li><p>按照时间搜索<br> Unix/Linux文件系统的三种时间戳如下：<br> (1) 访问时间 -atime: 用户最近一次访问文件的时间。<br> (2) 修改时间 -mtime: 文件内容最后被修改的时间。<br> (3) 变化时间 -ctime: 文件元数据（权限、所有者）信息最后修改时间。</p><blockquote><p>Unix中没有文件创建时间的概念！</p></blockquote><p> 结合以上时间戳和find指令，可以按照时间搜索文件，同时还会带有’+’、’-‘符号，前者表示大于，后者表示小于。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打印最近7天内被访问的所有文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find -<span class="built_in">type</span> f -atime -7 -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 刚好7天访问的文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find -<span class="built_in">type</span> f -atime 7 -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7天以前访问的所有文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find -<span class="built_in">type</span> f -atime +7 -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改时间和变化时间也同理</span></span><br></pre></td></tr></table></figure><p> 需要注意的是-xtime的单位都是天，基于分钟计算的如下：<br> (1) -amin<br> (2) -mmin<br> (3) -cmin</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 7min以内访问的文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> f -amin -7 -<span class="built_in">print</span></span></span><br></pre></td></tr></table></figure><p> 使用-newer参数通过与指定文件的时间戳相比较得到目的文件。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> f -newer file.txt -<span class="built_in">print</span></span></span><br></pre></td></tr></table></figure></li><li><p>基于文件大小的搜索</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 大2kB的文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> f -size +2k</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 小于2kB的文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> f -size -2k</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等于2kB</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> f -size 2k</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其它单位</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> b 块（512B）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> c 字节</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> w 字 （2字节）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> k</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> M</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> G</span></span><br></pre></td></tr></table></figure></li><li><p>删除匹配文件<br> 使用 ‘-delete’ 参数删除find得到的结果。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除当前目录下所有的.swp文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.swp&quot;</span> -delete</span></span><br></pre></td></tr></table></figure></li><li><p>权限匹配<br> 根据文件的权限进行查找，列出具备特定权限的文件。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找权限为644的文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> f -perm 644 -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有设置好权限的文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> f ! -perm 644 -<span class="built_in">print</span></span></span><br></pre></td></tr></table></figure><p> 查找某一个用户的文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> user参数可为用户名或者uid</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> f -user dongchangzhang -<span class="built_in">print</span></span></span><br></pre></td></tr></table></figure></li><li><p>执行命令<br>find借助 ‘-exec’ 选项与其他命令配合，使find命令具备强大的功能。<br>例如，我们找到了所有没有设定好权限的文件，并对其设定权限，只需要一条指令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> f !-perm 644 -<span class="built_in">exec</span> chmod 644 &#123;&#125; \;</span></span><br></pre></td></tr></table></figure><p>在以上的命令中 {} 会被替换为每一个匹配的文件名。’-exec’后面可以跟任何指令，{}依次替换为匹配后的文件名。每个文件执行一次指令。如果希望一次性执行命令，则在’-exec’中使用’+’替换。另外，虽然对每个文件单独执行命令，但是其全部的输出流是一个完整的。<br>需要注意的是，’-exec’命令不能跟多个命令，但是我们可以这样做：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> .... -<span class="built_in">exec</span> ./cmds.sh &#123;&#125; \;</span></span><br></pre></td></tr></table></figure></li><li><p>跳过目录<br>在查找过程中有一些目录是不需要搜索的，我们可以跳过以节约时间。该技巧也被成为修剪。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> find . \( -name <span class="string">&quot;.git&quot;</span> -prune \) -o \( -<span class="built_in">type</span> f -<span class="built_in">print</span> \)</span></span><br></pre></td></tr></table></figure><p>前者表示忽略.git文件夹，后者为具体查找命令。</p></li></ol><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>xargs擅长将标准输入数据转换成命令行参数。xargs也能将单行或者多行数据转换为其他的数据格式。例如将单行变为多行或者多行变为单行。<br>xargs应该紧跟在管道操作符之后，以标准输入作为主要的源数据流。它使用stdin并通过提供命令行参数来执行其他的命令。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cmd | xargs</span></span><br></pre></td></tr></table></figure><ol><li><p>单行转为多行<br> 以空格替换’\n’。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat a.txt</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cat a.txt | xargs</span></span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure></li><li><p>单行输入替换为多行输出<br> 指定每行的最大参数数量-n，可以将stdin中的文本划分为多行，每行n个参数。每个参数都是由” “分隔开的字符串。空格是默认的定界符。<br> 当然也可以自定义分界符：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;splitXsplitXsplitXsplit&quot;</span> | xargs -d X</span></span><br><span class="line">split split split split</span><br></pre></td></tr></table></figure><p> 结合’-n’我们可以将输出换为多行</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;splitXsplitXsplitXsplit&quot;</span> | xargs -d X -n 2</span></span><br><span class="line">split split</span><br><span class="line">split split</span><br></pre></td></tr></table></figure></li><li><p>读取stdin并且格式化参数传递给命令<br> 为了方便理解，我们有以下的脚本，脚本的作用是打印传递给脚本的参数，并且在参数后添加’#’。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file name a.sh</span></span><br><span class="line">echo $* &#x27;#&#x27;</span><br></pre></td></tr></table></figure><p> 当运行该脚本，我们会看到这样的结果：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./a.sh arg1 arg2</span></span><br><span class="line">arg1 arg2 #</span><br></pre></td></tr></table></figure><p> 此时我们遇到这样一个问题将一个含有参数列表的文件中的所有参数传递给上述脚本时，我们可以：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat args.txt</span></span><br><span class="line">arg1</span><br><span class="line">arg2</span><br><span class="line">arg2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cat args.txt | xargs -n 1 ./a.sh</span></span><br><span class="line">arg1 #</span><br><span class="line">arg2 #</span><br><span class="line">arg3 #</span><br></pre></td></tr></table></figure><p> 多么神奇的事情啊！如果你一次需要传递多个参数呢？</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat args.txt | xargs -n 2 ./a.out</span></span><br><span class="line">arg1 arg2 #</span><br><span class="line">arg3 #</span><br></pre></td></tr></table></figure><p> 当一次性传递所有的参数呢？</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat args.txt | xargs ./a.out</span></span><br><span class="line">arg1 arg2 arg3 #</span><br></pre></td></tr></table></figure><p> 除此之外，如果你的参数的一部分是固定的，而另一部分是需要从参数列表中变化的呢？<br> 可以使用’-I’指定需要替换的参数，{}将最终被参数替换。在与xargs命令结合使用时，对于每一个参数，命令都会执行一次。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat args.txt | xargs -I &#123;&#125; ./a.sh -p &#123;&#125; -l</span> </span><br><span class="line">-p arg1 -l #</span><br><span class="line">-p arg2 -l #</span><br><span class="line">-p arg3 -l #</span><br></pre></td></tr></table></figure></li><li><p>xargs和find<br> xargs和find可以结合在一起使用，并且可以大大提升工作效率。在简要了解find和xargs的使用方法之前，一种常犯的错误需要注意：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span> | xargs rm -f</span></span><br></pre></td></tr></table></figure><p> 上面的操作很危险，可能会删除不必要的文件！因为我们无法预测find输出的结果的定界符是什么，并且很多文件名包含空格，从而误删文件。</p><blockquote><p>因此，只要我们把find的输出作为xargs的输入使用，就必须使用-print0和find结合使用，使用字符’\0’来分割每一个查找到的文件</p></blockquote> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> xargs -0 使用<span class="string">&#x27;\0&#x27;</span>作为输入定界符</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> -print0 | xargs -0 rm -f</span></span><br></pre></td></tr></table></figure><p> 举栗子：统计所有c文件的行数</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> find path -<span class="built_in">type</span> f -name <span class="string">&quot;*.c&quot;</span> -print0 | xargs -0 wc -l</span></span><br></pre></td></tr></table></figure></li><li><p>运用while和子shell<br> xargs只能以有限的几种方式提供参数，而且不能为多组命令传递参数，要执行包含来自标准输入的多个参数的命令，有一种灵活的方法。包含while循环的子shell可以用来读取参数，然后通过一种巧妙的方式执行命令。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat files.txt | (<span class="keyword">while</span> <span class="built_in">read</span> arg; <span class="keyword">do</span> cat <span class="variable">$args</span>; <span class="keyword">done</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 和 cat files.txt | xargs -I &#123;&#125; cat &#123;&#125;</span></span><br></pre></td></tr></table></figure><p> 以上cat $args可以替换为多个命令。</p></li></ol><h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><p>tr可以用于对来自标准输入的内容进行字符的替换、删除以及重复字符的压缩。其也被称为转换命令。需要注意的是，tr命令只接受stdin，不能通过命令行参数来接受输入。它的一般的调用格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> tr [options] set1 set2</span></span><br></pre></td></tr></table></figure><p>上述的指令，将来自stdin的输入字符从set1映射到set2，然后输出到stdout。其中set1和set2均为字符类或者字符集。如果两个字符集和的长度不同，那么set2将会不断重复其最后一个字符，直到长度与set1相同。如果set2长度大于set1，那么超出的部分将会被忽略。</p><ol><li>大小写转换 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;HELLO, WORLD!&quot;</span> | tr <span class="string">&#x27;A-Z&#x27;</span> <span class="string">&#x27;a-z&#x27;</span></span></span><br><span class="line">hello, world!</span><br></pre></td></tr></table></figure> 上述’a-z’等都是集合。那么如何定义一个集合呢？<br> 我们可以按需追加字符或者字符类构造自己的集合。对于’a-z-}’、’a-ce-x’、’a-c0-9’、’aA.,’等都是合法的结合。定义字符无需写一连串字符，只需要定义’开始字符-终止字符’即可，但是如果上述的开始和终止字符没有顺序关系，那么就将其看为3个独立的字符了。<br> 当然，tr也可以用于其他字符的替换。</li><li>加密和解密<br> tr将一个字符集映射到另外一个字符集的原理，我们可以用来进行对文本加密。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> 1234 | tr <span class="string">&#x27;0-9&#x27;</span> <span class="string">&#x27;9876543210&#x27;</span></span></span><br><span class="line">8765</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;tr came, tr saw, tr conquered.&#x27;</span> | tr <span class="string">&#x27;a-zA-Z&#x27;</span> <span class="string">&#x27;n-za-mN-ZA-M&#x27;</span></span></span><br><span class="line">ge pnzr, ge fnj, ge pbadhrerq.</span><br></pre></td></tr></table></figure></li><li>字符删除和求补<br> ‘tr’命令使用参数’-d’可以删除stdin中的特定字符集： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello 123 world 456&quot;</span> | tr -d <span class="string">&#x27;0-9&#x27;</span></span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure> 可以使用’-c’参数来求set1的补集<br> 如下面的例子，从输入文本中删除所有不在补集中的字符： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> hello 1 char 2 next 4 | tr -d -c <span class="string">&#x27;0-9&#x27;</span></span></span><br><span class="line">1 2 4</span><br></pre></td></tr></table></figure> 在上述例子中，补集包括除了数字、空格、换行符之外的所有字符。由于指定了参数’-d’，因此这些字符被删除了。</li><li>压缩字符<br> 在文本处理中的一个任务是压缩多个连续的空格为一个，或者其他类似的任务。使用tr可轻松实现这一个任务。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;hello     world    my   love&quot;</span> | tr -s <span class="string">&#x27; &#x27;</span></span></span><br><span class="line">hello world my love</span><br></pre></td></tr></table></figure> 对该用法我们可以举出这样的一个例子：将文件中的所有数字相加 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat nums.txt</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cat nums.txt | <span class="built_in">echo</span> $[ $(tr <span class="string">&#x27;\n&#x27;</span> <span class="string">&#x27;+&#x27;</span>) 0 ]</span></span><br><span class="line">15</span><br></pre></td></tr></table></figure> 在上述指令中的最后的0不可缺少。tr命令将stdin变为’1+2+3+4+5+’，最后填一个0使表达式完整。</li><li>字符类<br> tr可以使用不同的字符类：<br> 使用字符类的方法如下： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> tr [:lower:] [:upper:]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>type</th><th>描述</th></tr></thead><tbody><tr><td>alnum</td><td>字母和数字</td></tr><tr><td>alpha</td><td>字母</td></tr><tr><td>cntrl</td><td>控制字符</td></tr><tr><td>digit</td><td>数字</td></tr><tr><td>graph</td><td>图形字符</td></tr><tr><td>lower</td><td>小写字符</td></tr><tr><td>print</td><td>可打印字符</td></tr><tr><td>punct</td><td>标点符号</td></tr><tr><td>space</td><td>空白字符</td></tr><tr><td>xdigit</td><td>16进制字符</td></tr></tbody></table></li></ol><blockquote><p>参考：Linux Shell脚本攻略第二章</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;cat&quot;&gt;&lt;a href=&quot;#cat&quot; class=&quot;headerlink&quot; title=&quot;cat&quot;&gt;&lt;/a&gt;cat&lt;/h2&gt;&lt;p&gt;cat通常用于读取、显示或者拼接文件内容，也可以用将来自标准输入和文件的数据进行组合。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 读取文件内容的一般写法：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cat file1 file2 ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;将标准输出和文件中的内容拼接在一起&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt; &amp;gt; test.txt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;b&amp;#x27;&lt;/span&gt; | cat - test.txt &lt;span class=&quot;comment&quot;&gt;# - 作为stdin文件的文件名&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="shell" scheme="https://vhdsih.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>LinuxShell1 - 基础内容</title>
    <link href="https://vhdsih.github.io/2018/04/16/LinuxShell1/"/>
    <id>https://vhdsih.github.io/2018/04/16/LinuxShell1/</id>
    <published>2018-04-16T13:55:18.000Z</published>
    <updated>2023-10-25T14:47:54.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="终端打印"><a href="#终端打印" class="headerlink" title="终端打印"></a>终端打印</h2><ol><li><p>echo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用没有引号的<span class="built_in">echo</span>，不能输出<span class="string">&#x27;;&#x27;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> Hello World！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 变量替换在<span class="string">&#x27;&#x27;</span>中无效</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&quot;&quot;</span>中不能直接打印！，需要转义，<span class="string">&#x27;&#x27;</span>中忽略不会识别转义字符</span></span><br><span class="line">[Y]: echo &quot;Hello, World\!&quot;</span><br><span class="line">[N]: echo &quot;Hello, World!&quot;</span><br><span class="line">[Y]: echo &#x27;Hello, World!&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span>在<span class="string">&quot;&quot;</span>中引用变量</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> var1=1; var2=2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;hello <span class="subst">$(var1)</span>, <span class="variable">$var2</span>&quot;</span></span></span><br><span class="line">hello 1, 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&#x27;&#x27;</span>中变量不会被扩展</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;$var1&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">var1</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>使用选项-e使用转义字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">颜色输出：</span><br><span class="line">echo -e &quot;\e[1;32m hello, world\!\e[0m&quot;</span><br></pre></td></tr></table></figure><p>字体颜色码：</p><p>重置=0,黑色=30,红色=31,绿色=32,黄色=33,蓝色=34,洋红=35,青色=36,白色=37。</p><p>背景颜色码：</p><p>重置=0,黑色=40,红色=41,绿色=42,黄色=43,蓝色=44,洋红=45,青色=46,白色=47。</p></li><li><p>printf</p><p>类似于C语言的格式化输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">printf</span> <span class="string">&quot;hello %s&quot;</span> world!</span></span><br><span class="line">hello world!</span><br><span class="line"><span class="meta">#</span><span class="bash"> 引用变量</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">printf</span> <span class="string">&quot;<span class="variable">$var1</span>, <span class="subst">$(var2)</span>&quot;</span></span></span><br></pre></td></tr></table></figure></li></ol><p>需要注意，echo和prinf使用选项时需要出现在所有的字符串之前。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>使用pgrep查看进程的pid，然后可以据此查看该应用依赖的环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> pgrep vim</span></span><br><span class="line">15371</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cat /proc/15371/environ</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>变量赋值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以直接赋值，需要注意<span class="string">&#x27;=&#x27;</span>两边没有空格</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> var=value</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$var</span></span></span><br><span class="line">value</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> $(var)</span></span><br><span class="line">value</span><br></pre></td></tr></table></figure><p>使用export设置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP_PROXY=192.168.1.23:3128</span><br><span class="line">export HTTP_PROXY</span><br></pre></td></tr></table></figure><p>默认情况下，Linux中包含很多环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$PATH</span>， <span class="variable">$HOME</span>, <span class="variable">$PWD</span></span></span><br><span class="line">....</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在环境变量中添加一条新的变量，注意使用<span class="string">&#x27;:&#x27;</span>分割</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/home/user/bin&quot;</span></span></span><br></pre></td></tr></table></figure><p>其他技巧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 变量长度</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> length=<span class="variable">$&#123;#var&#125;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前使用的shell</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$0</span>, <span class="variable">$SHELL</span></span></span><br><span class="line">zsh, /bin/zsh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前用户是否为超级用户, root用户的uid为0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$UID</span></span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="算数计算"><a href="#算数计算" class="headerlink" title="算数计算"></a>算数计算</h2><p>在bash shell中可以使用let，(( ))，[ ] 来执行基本的算数运算，而高级操作也可以使用expr和bc。</p><ol><li><p>整数运算</p><p>当使用普通的赋值方法定义数值时，它会存储为字符串，我们可以使用let直接执行基本的算数运算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> a=1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> b=2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用<span class="built_in">let</span>，变量名前无需添加$</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">let</span> result=a+b</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$result</span></span></span><br><span class="line">3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 自加、减</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">let</span> a++</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">let</span> b--</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 简写</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">let</span> a+=5</span></span><br></pre></td></tr></table></figure><p>[ ]和let的作用类似</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> result=$[ a + b ]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当然，[ ]中也可以是使用$</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> result=$[ <span class="variable">$a</span> + b ]</span></span><br></pre></td></tr></table></figure><p>也可以使用(( ))，但是必须加上$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> result=$(( a + <span class="number">50</span>))</span></span><br></pre></td></tr></table></figure><p>expr也可以运用在基本运算上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> r1=`expr 3 + 4`</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> r2=$(expr <span class="variable">$a</span> + 5)</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>浮点数运算以及其他</p><p>bc是一个数学运算的高级工具，使用它可以进行浮点运算。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;4 * 0.56&quot;</span> | bc</span></span><br><span class="line">2.24</span><br></pre></td></tr></table></figure><p>设置精度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;scale=2;1/3&quot;</span> | bc</span></span><br><span class="line">0.33</span><br></pre></td></tr></table></figure><p>进制转换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输入10进制，输出2进制</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;obase=2;ibase=10;100&quot;</span> | bc</span></span><br><span class="line">1100100</span><br></pre></td></tr></table></figure><p>平方和平方根</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;sqrt(100)&quot;</span> | bc</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;10^10&quot;</span> | bc</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="文件描述符和重定向"><a href="#文件描述符和重定向" class="headerlink" title="文件描述符和重定向"></a>文件描述符和重定向</h2><p>文件描述符是和文件输入和输出相关联的整数，用来追踪已打开的文件。</p><ul><li>0: stdin</li><li>1: stdout</li><li>2: stderr</li></ul><ol><li><p>使用’&gt;’对输入和输出进行重定向操作。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;hello world!&quot;</span> &gt; a.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cat a.txt</span></span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure></li><li><p>使用’&gt;&gt;’将内容追加到文本。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;fuck x&#x27;</span> &gt;&gt; a.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cat a.txt</span></span><br><span class="line">hello world!</span><br><span class="line">fuck x</span><br></pre></td></tr></table></figure><blockquote><p>命令成功执行后，会返回0；执行失败则会返回非0的错误码。使用 ‘echo $?’可以查看上一个命令执行情况。</p></blockquote></li><li><p>当执行一个命令时，使用重定向仅仅是针对stdout，因此，当命令执行失败，其错误信息仍然会显示在终端。如果希望将stderr重定向：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ls no-such-file-in-this-dir &gt;out.txt</span></span><br><span class="line">No such file balabala...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ls no-such-file-in-this-dir 2&gt;out.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cat out.txt</span></span><br><span class="line">No such file balabala...</span><br></pre></td></tr></table></figure><p> 可以同时将stdin和stderr绑定</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cmd 2&gt;stderr.txt 1&gt;stdout.txt</span></span><br></pre></td></tr></table></figure><p> 也可以将stderr绑定到stdout</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cmd 2&gt;&amp;1 output.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cmd &amp;&gt; output.txxt</span></span><br></pre></td></tr></table></figure><p> 如果不希望看到stderr，可以将其绑定到/dev/null</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cmd 2&gt;/dev/null</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> null 设备通常被称作黑洞</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，如果已经将stdout或者stderr进行重定向，那么就导致没有什么内容可以通过管道输出了</p></blockquote></li><li><p>数据重定向到文件同时提供副本作为后续命令的输入</p><p> 使用tee命令实现</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command | tee file1 file2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cat a.txt | tee out.txt | cat -n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> stderr 中的内容不会输出到out.txt中</span></span><br></pre></td></tr></table></figure><blockquote><p>tee命令在默认情况下，会将已存在的文件覆盖，使用参数 -a 可以进行追加</p></blockquote></li><li><p>使用stdin作为命令参数</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd1 | cmd2 | cmd -</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> who is this | tee -</span></span><br></pre></td></tr></table></figure></li><li><p>stdin重定向</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd &lt; file</span><br></pre></td></tr></table></figure></li><li><p>脚本内部的文本块重定向</p><p> 在cat &lt;&lt; EOF &gt; log.txt到EOF之间的内容都会作为stdin。 </p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">cat&lt;&lt;EOF&gt;log.txt</span><br><span class="line">LOG FILE HEADER</span><br><span class="line">This is a test log file</span><br><span class="line">Function: System statistics</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>自定义文件描述符</p><p> 使用exec命令创建自己的文件描述符。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个文件描述符用于写入（截断）</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">exec</span> 4 &gt; out.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> new-things &gt;&amp;4</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cat out.txt</span></span><br><span class="line">new_things</span><br><span class="line"><span class="meta">#</span><span class="bash"> 追加模式</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">exec</span> 5 &gt;&gt; out.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> haha &gt;&amp;5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cat out.txt</span></span><br><span class="line">new_things</span><br><span class="line">haha</span><br></pre></td></tr></table></figure></li></ol><h2 id="数组与关联数组"><a href="#数组与关联数组" class="headerlink" title="数组与关联数组"></a>数组与关联数组</h2><ol><li><p>定义数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1</span></span><br><span class="line">array_var=(1 2 3 4 5)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2</span></span><br><span class="line">array_var[0]=&quot;a&quot;</span><br><span class="line">array_var[1]=&quot;b&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>数组访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 所有的内容</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;array_var[*]&#125;</span></span></span><br><span class="line">a b 3 4 5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;array_var[@]&#125;</span></span></span><br><span class="line">a b 3 4 5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定索引</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;array[1]&#125;</span></span></span><br><span class="line">b</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> index=2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span><span class="variable">$&#123;array[$index]&#125;</span></span></span><br><span class="line">2</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>数组长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;#array_var[*]&#125;</span></span></span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li><p>关联数组（bash 4.0+）</p><p>实现原理为散列技术。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先声明</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">declare</span> -A ass_array</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加元素1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ass_array=([index1]=val1 [index2]=val2)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加元素2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ass_array[index1]=val1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ass_array[index2]=val2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> indexn可以为apple也可以为123</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;ass_array[index1]&#125;</span></span></span><br><span class="line">val1</span><br></pre></td></tr></table></figure></li><li><p>列出数组的索引</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;!array_var[*]&#125;</span></span></span><br></pre></td></tr></table></figure></li><li><p>使用alias定义别名</p><blockquote><p>注意alias可能会导致安全问题，可以利用转义字符忽略可能存在的别名</p></blockquote></li></ol><h2 id="获取终端信息"><a href="#获取终端信息" class="headerlink" title="获取终端信息"></a>获取终端信息</h2><p>当前终端的相关信息，包括行数，列数、光标位置、密码等信息。有tput和stty两种终端处理工具。</p><ol><li><p>终端行数和列数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tput cols</span><br><span class="line">tput lines</span><br></pre></td></tr></table></figure></li><li><p>终端名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tput longname</span><br></pre></td></tr></table></figure></li><li><p>光标移动到目的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tput cup x y</span><br></pre></td></tr></table></figure></li><li><p>设置终端背景颜色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tputsetb n</span><br><span class="line"><span class="meta">#</span><span class="bash"> 0 &lt;= n &lt;= 7</span></span><br></pre></td></tr></table></figure></li><li><p>设置文本粗体</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tput bold</span><br></pre></td></tr></table></figure></li><li><p>密码</p><p>设置-echo禁止将输出发送到终端，echo允许；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Filename: password.sh</span></span><br><span class="line">echo -e &quot;Enter password: &quot;</span><br><span class="line">stty -echo</span><br><span class="line">read password</span><br><span class="line">stty echo</span><br><span class="line">echo</span><br><span class="line">echo Password read.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h2><ol><li><p>获取日期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> date</span></span><br><span class="line">Tue Apr 17 08:48:40 CST 2018</span><br></pre></td></tr></table></figure></li><li><p>纪元时</p><p>UTC，又称为世界标准时间或者世界协调时间。unix人文UTC1970年1月1日0点是纪元时间，也被成为posix时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 获取纪元时</span><br><span class="line">&gt; date +%s</span><br><span class="line"># 将日期字符串转换为纪元时</span><br><span class="line">&gt; date --date &quot;Thu Nov 18 08:07:21 IST 2010&quot; +%s</span><br><span class="line">1290047841</span><br></pre></td></tr></table></figure></li><li><p>格式输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 结合 <span class="string">&#x27;+&#x27;</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> date <span class="string">&quot;+%d %B %Y&quot;</span></span></span><br><span class="line">20 May 2010</span><br><span class="line"><span class="meta">#</span><span class="bash"> 星期 %a (Sat) %A (Saturday)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 月 %b (Nov) %B (November)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日 %d</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mm/dd/yy  %D</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 小时 、、、、、、、、、、%I  %H</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分钟 %M</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 秒 %S</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 纳秒 %N</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Unix纪元时  %s</span></span><br></pre></td></tr></table></figure></li><li><p>设置时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> date -s <span class="string">&quot;格式化的时间日期&quot;</span></span></span><br></pre></td></tr></table></figure></li><li><p>时间间隔</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start=$(date +%s)</span><br><span class="line">...</span><br><span class="line">end=$(date +%s)</span><br><span class="line">difference=$(( end - start ))</span><br></pre></td></tr></table></figure></li><li><p>延时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep n</span><br></pre></td></tr></table></figure></li></ol><h2 id="脚本调试"><a href="#脚本调试" class="headerlink" title="脚本调试"></a>脚本调试</h2><ol><li><p>使用-x对脚本跟踪调试，此时会打印出每一条指令以及其输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> bash -x x.sh</span></span><br></pre></td></tr></table></figure></li><li><p>利用set -x 和 set +x 局部调试</p><ul><li>set -x：执行时显示参数和命令</li><li>set +x：禁止调试</li><li>set -v：命令进行读取时显示输入</li><li>set +v：禁止打印输入</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">test</span> debug</span></span><br><span class="line">for i in &#123;1..6&#125;</span><br><span class="line">do</span><br><span class="line">set -x</span><br><span class="line">echo $i</span><br><span class="line">set +x</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p>通过传递环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">function DEBUG()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$1</span> <span class="variable">$2</span>... 访问第n个参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$@</span> 一次性访问所有参数 = <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="string">&quot;<span class="variable">$2</span>&quot;</span> ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> $* 类似<span class="variable">$@</span> 但是参数被当做单独的个体 = <span class="string">&quot;$1<span class="variable">$2</span>...&quot;</span></span></span><br><span class="line">[ &quot;$_DEBUG&quot; == &quot;on&quot; ] &amp;&amp; $@ || :</span><br><span class="line">&#125;</span><br><span class="line">for i in &#123;1..10&#125;</span><br><span class="line">do</span><br><span class="line">DEBUG echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>设置_DEBUG来运行脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> _DEBUG=on ./x.sh</span></span><br></pre></td></tr></table></figure></li><li><p>使用shebang</p><p>将#!/bin/bash替换为#!/bin/bash -xv</p></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li><p>定义函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方式1</span></span><br><span class="line">function fname()</span><br><span class="line">&#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式2</span></span><br><span class="line">fname()</span><br><span class="line">&#123;</span><br><span class="line">    statements;</span><br><span class="line">    # 可以包含返回值</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接使用函数名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> fname; <span class="comment"># 执行fname</span></span></span><br></pre></td></tr></table></figure></li><li><p>参数传递</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 参数以空格分割，跟在函数名后面</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> fname arg1 arg2 ...</span></span><br></pre></td></tr></table></figure></li><li><p>参数获取</p><ul><li>$n：访问第n个参数</li><li>$@：以列表的方式一次性打印所有的参数</li><li>$*：访问所有的参数，被当做一个整体</li></ul></li><li><p>递归函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F() &#123; echo $1; F hello; sleep 1; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>fork炸弹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:() &#123; :|:&amp; &#125;; :</span><br></pre></td></tr></table></figure><p>该函数不断递归自身，不断生成新的进程，最终造成拒绝服务攻击。</p></blockquote></li><li><p>导出函数</p><p>函数像环境变量一样用export导出，扩大作用域到子进程中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export -f filename</span><br></pre></td></tr></table></figure></li><li><p>获取函数返回值</p><p>$?返回上一条命令的返回值</p></li></ol><h2 id="比较与判断"><a href="#比较与判断" class="headerlink" title="比较与判断"></a>比较与判断</h2><p>基本格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition;</span><br><span class="line">then</span><br><span class="line">commands</span><br><span class="line">else if condition;</span><br><span class="line">then</span><br><span class="line">commands</span><br><span class="line">else</span><br><span class="line">commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ol><li><p>判断简化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ condition ] &amp;&amp; action; # condition为真，执行action</span><br><span class="line">[ condition ] || action; # condition为假，执行action</span><br></pre></td></tr></table></figure></li><li><p>算数比较</p><p>条件放在中括号中，注意空格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ $var -eq 0 ] # 两边一定有空格， 当var=0， return 1； else return 0</span><br></pre></td></tr></table></figure><ul><li>大于：-gt</li><li>小于：-lt</li><li>大于等于：-ge</li><li>小于等于：-le</li><li>逻辑与：-a</li><li>逻辑或：-o</li></ul></li><li><p>文件系统测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ -f $file ]: file 是文件</span><br><span class="line">[ -x $file ]: file 可执行</span><br><span class="line">[ -d $file ]: file 是目录</span><br><span class="line">[ -e $var ]: var 包含文件</span><br><span class="line">[ -c $var ]: 是一个字符设备文件</span><br><span class="line">[ -b $var ]: 是一个块设备</span><br><span class="line">[ -w $var ]: 可以写</span><br><span class="line">[ -r $var ]: 可以读</span><br><span class="line">[ -L $var ]: 是一个符号链接</span><br></pre></td></tr></table></figure></li><li><p>字符串比较</p><p>字符串比较最好使用 [[ ]]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[ $str1 op $str2 ]] # op : ==; !=; &gt;; &lt;</span><br><span class="line">[[ -z $str ]] # str 空吗？</span><br><span class="line">[[ -n $str ]] # str 非空吗？</span><br></pre></td></tr></table></figure></li><li><p>逻辑运算</p><p>使用 &amp;&amp; 或 || 可以组合条件；</p><p>test命令可以避免括号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if test $var -eq 0; then echo yes; fi;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等价于</span></span><br><span class="line">if [ $var -eq 0 ]; then echo yes; fi;</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ol><li><p>while</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while 条件</span><br><span class="line">do</span><br><span class="line">statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p>for</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> type1</span></span><br><span class="line">for var in list # list是字符串或者序列</span><br><span class="line">do</span><br><span class="line">commands</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> type2</span></span><br><span class="line">for ((i=0; i&lt;10;++i)) &#123; echo $i; &#125;</span><br></pre></td></tr></table></figure><p>生成序列的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;1..50&#125;</span></span> </span><br><span class="line"> 1 2 3 4 .. 50</span><br><span class="line"><span class="meta">#</span><span class="bash">2</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> &#123;a..z&#125;</span></span><br><span class="line"> a b c .. z</span><br></pre></td></tr></table></figure></li><li><p>until</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=0</span><br><span class="line">until [$x -eq 9 ];</span><br><span class="line">do</span><br><span class="line">let x++; echo $x</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>​</p><h2 id="向脚本传递命令行参数"><a href="#向脚本传递命令行参数" class="headerlink" title="向脚本传递命令行参数"></a>向脚本传递命令行参数</h2><p>我们希望向下面这个脚本中传递参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> script name is a.sh</span></span><br><span class="line"></span><br><span class="line">for x in $*</span><br><span class="line">do</span><br><span class="line">    echo $x</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>参数传递方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./a.sh a b c d e</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2></li><li><p>利用()定义一个子shell</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">dir1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> (<span class="built_in">cd</span> /bin; ls)</span></span><br><span class="line">somethings in /bin</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">dir1</span><br></pre></td></tr></table></figure></li><li><p>read命令</p><p> read可以实现不按回车读取数据</p><p> read  参数 var</p><ul><li>-n : 读取n个字符存入var</li><li>-s： 无回显方式读取密码</li><li>-p：显示提示信息</li><li>-t：特定时间内读取</li><li>-d：特殊符号作为输入结束</li></ul></li><li><p>执行直至成功</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repeat() &#123; while true; do $@ &amp;&amp; return; done &#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更快</span></span><br><span class="line">repeat() &#123; while :; do $@ &amp;&amp; return; done &#125;</span><br></pre></td></tr></table></figure></li><li><p>字段分隔符</p><p> 内部字段分隔符IFS</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">a=&quot;1:2:3&quot;</span><br><span class="line">oldIFS=$IFS</span><br><span class="line">IFS=&quot;:&quot;</span><br><span class="line">for i in $a</span><br><span class="line">do echo $i</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li><li><p>字符替换：<br> tr oldChar newChar</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> ababab | tr <span class="string">&#x27;a&#x27;</span> <span class="string">&#x27;b&#x27;</span></span></span><br><span class="line">bbbbbb</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>参考：Linux Shell脚本攻略　第一章</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;终端打印&quot;&gt;&lt;a href=&quot;#终端打印&quot; class=&quot;headerlink&quot; title=&quot;终端打印&quot;&gt;&lt;/a&gt;终端打印&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;echo&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 使用没有引号的&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt;，不能输出&lt;span class=&quot;string&quot;&gt;&amp;#x27;;&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; Hello World！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 变量替换在&lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;#x27;&lt;/span&gt;中无效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;中不能直接打印！，需要转义，&lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;#x27;&lt;/span&gt;中忽略不会识别转义字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[Y]: echo &amp;quot;Hello, World\!&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[N]: echo &amp;quot;Hello, World!&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[Y]: echo &amp;#x27;Hello, World!&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt;在&lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;中引用变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; var1=1; var2=2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;hello &lt;span class=&quot;subst&quot;&gt;$(var1)&lt;/span&gt;, &lt;span class=&quot;variable&quot;&gt;$var2&lt;/span&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hello 1, 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;#x27;&lt;/span&gt;中变量不会被扩展&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;$var1&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;var1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="shell" scheme="https://vhdsih.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>从一道简单的题反思自己的思维定式</title>
    <link href="https://vhdsih.github.io/2018/04/12/shit1/"/>
    <id>https://vhdsih.github.io/2018/04/12/shit1/</id>
    <published>2018-04-12T13:55:34.000Z</published>
    <updated>2023-10-25T14:47:01.645Z</updated>
    
    <content type="html"><![CDATA[<p>今天在Project Euler上做了一道题，题目是这样的：</p><blockquote><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p><p>Find the sum of all the multiples of 3 or 5 below 1000.</p></blockquote><p>其实这是一道很简单的题，基本属于a+b类型的那一种。对于我，很直观的想法就是从1遍历到1000，对于每一个数判断这个数字是否是3或5的倍数。在O(n)的时间内完成计算。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MultiplesOf3And5</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> || i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然题目给出的是数据范围仅仅是1000，然而对于一个更大的数据范围呢，比如说10亿，一个O(n)实现的算法是否是适合呢？</p><p>我其实没有深入考虑到这一步，当我写完上面的代码就打算做下一道题目了。然而在阅读题目解析的时候发现才发现自己思维的不足。</p><p>对于这个题目来说，其实还可以这样分析：</p><blockquote><p>计算1到1000中3和5倍数的加和等于3的倍数的加和和5的倍数的加和，然后减去多加的部分</p><p>sum_3 = 3 + 6 + 9 + … + 999 = 3 * (1 + 2 + 3 + … + 333)</p><p>sum_5 = 5 + 10 + 15 + … + 199 = 5 * (1 + 2 + 3 + … + 199)</p><p>多加的部分是15的倍数</p><p>sum_15 = 15 + 30 + … = 15 * (1 + 2 + …)</p><p>因此</p><p>sum = sum_3 + sum_5 - sum_15</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bestSolution</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sumDivisibleBy</span>(<span class="number">3</span>, limit) + <span class="built_in">sumDivisibleBy</span>(<span class="number">5</span>, limit) - <span class="built_in">sumDivisibleBy</span>(<span class="number">15</span>, limit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumDivisibleBy</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * (<span class="number">1</span> + (limit) / n) * (limit / n) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，对于任意范围的数据，只需要选择合适的数据类型，就能在O(1)的时间完成计算了。</p><p>我在做这道题的时候，想的过于简单，看完题习惯性的遍历一遍就得到了结果，相反进一步的思考这一个过程却被我忽略掉了。所以说，刷题也不能盲目的刷题，刷题不是目的，提高熟练程度、巩固算法基础、培养思维方式才是刷题过程中着重提高的（教科书版说教×_×）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天在Project Euler上做了一道题，题目是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.&lt;/p&gt;
&lt;p&gt;Find the sum of all the multiples of 3 or 5 below 1000.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实这是一道很简单的题，基本属于a+b类型的那一种。对于我，很直观的想法就是从1遍历到1000，对于每一个数判断这个数字是否是3或5的倍数。在O(n)的时间内完成计算。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="study" scheme="https://vhdsih.github.io/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>特征提取过程中的keypoints和descriptors</title>
    <link href="https://vhdsih.github.io/2018/04/09/keypoint-descriptor/"/>
    <id>https://vhdsih.github.io/2018/04/09/keypoint-descriptor/</id>
    <published>2018-04-09T09:39:12.000Z</published>
    <updated>2023-10-25T14:45:47.700Z</updated>
    
    <content type="html"><![CDATA[<p>在使用SIFT、SURF、ORB等方法对图片进行特征提取和匹配的过程中，基本的工作过程大致如下：</p><ol><li>从图片中提取keypoints；</li><li>根据keypoints获取特征描述符descriptors；</li><li>依据获取的特征描述符对待匹配的两张或多张图片进行特征匹配；</li><li>对匹配结果进行筛选，得到匹配效果比较好的特征点；</li><li>开始后续的工作…</li></ol><span id="more"></span><p>那么，什么是keypoints和descriptors，以及keypoints和descriptors有什么关系和区别，在特征匹配过程为什么要使用descriptors呢？</p><p>首先，在特征提取之后，我们所获得的是特征的位置信息，或者是近似圆形、椭圆形的区域，这也就是我们所得到的keypoints，但是其仅仅包含了位置信息，这些位置信息不足以描述特征，也没有足够的信息用来对特征进行匹配；</p><p>而对于这些常见的特征提取算法，如SIFT、SURF、ORB等，其提取后获得的keypoints通常位于突出的角点、斑点、边，仅仅利用位置信息并不能完整描述特征。</p><p>我们可以看这样两个例子：</p><ol><li>已有图片1，图片的内容是一只熊，其背景是纯白色。而另一只图片2是仅仅对图片1的少部分像素做了处理后得到的图片，那么对这两张图片中的熊提取了特征以后，得到的keypoints应该是相同的，这两张图片应该被认为是相同或者相似的。但是如果我们得到的仅仅是位置信息，那么当两张图片中的像素位置改变以后，我们就无法继续对这两张图片进行比较了。</li><li>同样有图片1，图片1里现在是一只鸭子，而图片2中的内容则是图片1中的鸭子放大两倍以后的鸭子。此时提从两张图片取出来的keypoints相对于两张图片中的鸭子来说是相同的，因此这两张图片仍然是相同或者说是相似的。但是所不同的是图片2中的keypoints的size是图片1中的2倍，而仅仅使用这些位置信息来完成这次比较仍然很困难。</li></ol><p>因此，在特征比较过程中我们就需要使用另外一种特征表示方式descriptors。它使用vector表示keypoints中的每一个特征点的特征，它包含了每个特征的强度、方向等信息。而descriptor包含如下的特性：</p><ol><li>descriptor与位置信息是相互独立的，对于不同位置的同一个特征，二者的descriptor是相同的。</li><li>descriptor具有健壮性，图片变换（亮度、旋转、平移等）不会影响到特征的识别。但是需要注意的是，没有绝对的健壮性。对于不同的图像变换，可能需要不同设计的descriptor来抵抗图片变换所造成的影响。</li><li>descriptor不受图像缩放的影响。两个不同尺寸的同样的特征，应该视为相同的。</li></ol><p>现在我们就可以使用计算得到的descriptors来比较keypoints，当然匹配方法有很多种。而descriptor是数字的向量,你可以用一些比较简单的欧式距离，或者也可以使用一些更复杂的距离作为相似性度量的方法。</p><blockquote><p>reference:</p><ol><li><a href="http://answers.opencv.org/question/37985/meaning-of-keypoints-and-descriptors/">Meaning of keypoints and Descriptors</a></li><li><a href="https://dsp.stackexchange.com/questions/10423/why-do-we-use-keypoint-descriptors">stackexchange.com</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用SIFT、SURF、ORB等方法对图片进行特征提取和匹配的过程中，基本的工作过程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从图片中提取keypoints；&lt;/li&gt;
&lt;li&gt;根据keypoints获取特征描述符descriptors；&lt;/li&gt;
&lt;li&gt;依据获取的特征描述符对待匹配的两张或多张图片进行特征匹配；&lt;/li&gt;
&lt;li&gt;对匹配结果进行筛选，得到匹配效果比较好的特征点；&lt;/li&gt;
&lt;li&gt;开始后续的工作…&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="opencv" scheme="https://vhdsih.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>数据库的问题集</title>
    <link href="https://vhdsih.github.io/2018/01/26/q-of-db/"/>
    <id>https://vhdsih.github.io/2018/01/26/q-of-db/</id>
    <published>2018-01-26T11:37:56.000Z</published>
    <updated>2023-10-25T14:46:43.237Z</updated>
    
    <content type="html"><![CDATA[<p>战神-中国大学MOOC数据库课后习题与知识点</p><span id="more"></span><h1 id="上"><a href="#上" class="headerlink" title="上"></a>上</h1><h2 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h2><ol><li>数据库管理系统是软件产品，而数据库系统不仅仅是软件产品。</li><li>数据库系统的构成包括数据库、数据库管理系统、数据库应用程序、数据库管理员以及计算机与网络基本系统。</li><li>从用户角度看数据库管理系统的功能，数据库管理系统就是通过数据库语言让用户操作进而提供数据库定义、数据库操纵和数据库控制功能的系统，同时提供了一系列程序能够实现对数据库的各种存储与维护。</li><li>从系统角度看数据库管理系统，其功能包括数据库语言及其编译、查询实现与查询优化、事务处理、数据存储与索引以及其它功能。</li><li>完整性控制、并发控制、通讯控制属于数据库管理系统的功能；处理剂控制属于操作系统的功能。</li><li>关于数据库系统的语言，包括DDL（数据库定义语言），DML（数据库操纵语言），DCL（数据库控制语言）。</li></ol><h2 id="第二讲"><a href="#第二讲" class="headerlink" title="第二讲"></a>第二讲</h2><ol><li>数据库的三级模式：外模式（用户模式，子模式）、模式（逻辑模式、概念模式、全局模式）、内模式（物理模式、存储模式，内模式）。</li><li>对于模式有两个映射：<ol><li>C-I映射：概念模式映射为内模式；实现了物理的独立性（一个业务系统可利用任何数据库管理系统实现）；</li><li>E-C映像：概念模式映射为外模式；实现了逻辑的独立性（全局模式变化只需改变EC映像）；</li></ol></li><li>模式是对数据的抽象、数据模型是对模式的抽象；模式是对数据模型的抽象，数据模型的结构性描述称为模式 。</li><li>数据库系统的数据独立性是指不会因为系统数据存储结构与数据逻辑结构的变化而影响应用程序。</li><li>第一代数据库系统：基于网状模型或层次模型的数据库系统。</li><li>第二代数据库系统：基于关系模型的数据库系统。</li><li>文件系统和数据库系统的差别：<ol><li>数据的组织是否依赖于具体的应用程序；</li><li>数据存取是否可以记录或记录的集合为单位进行操作；</li><li>不同文件之间以及不同记录之间是否有联系；</li></ol></li><li>关系数据库系统对层次/网状数据库系统的重大改进是：<ol><li>消除了由用户建立指针的弊端；</li><li>将逐一记录的操作改进为支持记录集合的操作；</li><li>数据检索操作不依赖于路径信息或过程信息，即非过程化的操作；</li></ol></li><li>面对对象数据库系统对关系数据库系统的重大改进是：<ol><li>允许复杂的数据类型存在;</li><li>突破了关系模型第一范式的限制;</li><li>既支持记录集合的操作，又支持面向对象的操作;</li></ol></li><li>数据模型</li><li>关系模型;</li><li>层次模型;</li><li>网状模型;</li><li>XML模型、面向对象模型、NoSQL模型；</li></ol><h2 id="第三讲"><a href="#第三讲" class="headerlink" title="第三讲"></a>第三讲</h2><ol><li><p>某关系R的外键是指其它关系的候选键，可以是R中的主属性或非主属性。</p></li><li><p>候选键可由其值能惟一标识该关系中任何元组的一个或多个属性组成。</p></li><li><p>若某属性非该关系的主键，却是另外一个关系的主键，则该属性称为外键。</p></li><li><p><strong>下列四项中说法正确的是_______</strong></p><ul><li>A.关系的任何属性都是不可再分的 【正确答案】</li></ul><ul><li>B.R(A1 , A2 , … , An )，这种描述又被称为关系模式，其中Ai 是指属性所对应的域</li><li>C.关系模式和关系都是不随时间变化的</li><li>D.同一关系模式下关系是唯一的</li></ul></li><li><p><strong>现有如下关系：患者（患者编号，患者姓名，性别，出生日期），医疗（患者编号，患者姓名，医生编号，医生姓名，诊断日期）。其中，“医疗”关系中的外键是_______</strong></p><ul><li>A.患者编号【正确答案】</li><li>B.患者姓名</li><li>C.患者编号和患者姓名</li><li>D.医生编号</li></ul></li><li><p><strong>关于关系模型完整性的说法，不正确的是______</strong></p><ul><li>A.外键如果取空值，则违反了参照完整性【正确答案】</li><li>B.数据库中有了空值会影响许多方面，如影响聚集函数运算的正确性等</li><li>C.用户自定义完整性是指用户针对具体的数据库应用所定义的完整性约束条件</li><li>D.实体完整性和参照完整性一般由DBMS系统自动支持</li></ul></li><li><p><strong>关于关系模式与关系，说法不正确的是_______</strong></p><ul><li>A.关系模式是稳定的；同一关系模式下，只有一种关系【正确答案】</li><li>B.同一关系模式下，可有很多的关系</li><li>C.关系模式是关系的结构, 关系是关系模式在某一时刻的数据</li><li>D.关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的</li></ul></li><li><p><strong>关于关系的特性，说法不正确的是______</strong></p><ul><li>A.关系是以属性在关系的位置来区分的【正确答案】</li><li>B.关系是以内容(名字或值)来区分的</li><li>C.区分哪一列是靠列名</li><li>D.区分哪一行是靠某一或某几列的值</li></ul></li><li><p><strong>关于关系的特性，说法不正确的是______</strong></p><ul><li>A.关系的任意两列上的值不能完全相同【正确答案】</li><li>B.关系的任意两个元组不能完全相同</li><li>C.元组相同是指两个元组的每个分量都相同</li><li>D.在同一个关系中如存在相同的元组，则仅保留其中的一个</li></ul></li><li><p>关系模型就是处理Table的，它由关系(或者表)、关系运算和完整性约束。</p></li><li><p>关系数据库中，体现“实体能够区分并唯一标识元组”的规则是实体完整性规则。</p></li><li><p>根据关系模型的完整性规则，一个关系中的主键不允许空值。</p></li><li><p>若规定工资表中的基本工资不得超过5000元，则这个规则属于用户定义完整性约束。</p></li><li><p>关系是一个由行与列组成的、能够表达数据及数据之间联系的二维表。</p></li><li><p><strong>关于关系的特性，说法不正确的是_________。</strong></p><ul><li>A.表中行的顺序、列的顺序不可以任意交换【选这个】</li><li>B.表中的每一列均需有一个唯一的名字</li><li>C.表中不允许出现完全相同的两列</li><li>D.表中行的顺序、列的顺序均可以任意交换</li></ul></li><li><p>实体完整性：关系主码不能为空</p></li><li><p>参照完整性：对外码而言，外码可以取得空值，否则必须相应表的主码值</p></li><li><p>用户自定义完整性：用户自定义；16、17为dbms自动支持。</p></li></ol><h2 id="第四讲"><a href="#第四讲" class="headerlink" title="第四讲"></a>第四讲</h2><ol><li><p>5个基本操作：并、差、积、选择、投影。</p></li><li><p>相容性：参与运算的两个关系及其相关属性之间有一定的对应性、可比性、意义关联性；</p></li><li><p>自然连接是构成新关系的有效方法。一般情况下，当对关系R和S使用自然连接时，要求R和S含有一个或多个共有的属性</p></li><li><p><strong>关系R与关系S只有一个公共属性，T1是R与S做θ连接的结果，T2是R与S自然连接的结果，则下列说法正确的是_______</strong></p><ul><li>A.T1的属性个数大于T2的属性个数</li><li>B.T1 的属性个数等于T2</li><li>C.T1的属性个数小于T2</li><li>D.T1的属性个数大于或等于T2的属性个数</li></ul><blockquote><p> 正确答案：A你错选为D</p></blockquote></li><li><p><strong>对于如下运算,结果正确的是_________。</strong></p><p><img src="https://nos.netease.com/edu-image/618A90C822E85E1DDD9B7D28F659C3FE.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.<img src="https://nos.netease.com/edu-image/F916E9B4AE93F7BEE53CAE779D6CD044.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>B.<img src="https://nos.netease.com/edu-image/7483399AA5071E9E3F91A5A9BF40185E.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>C.<img src="https://nos.netease.com/edu-image/FB5B61B26C79ECD997B68BEF652B6C8C.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>D.<img src="https://nos.netease.com/edu-image/4230700CDA40334FADCBA4E786178E59.png?imageView&thumbnail=520x520&quality=100" alt="img"></li></ul><blockquote><p>正确答案：A你错选为C</p></blockquote></li><li><p><strong>已知关系S(S#,Sname,Sage,Sclass), SC(S#,C#,Score)。如下所示关系代数表达式的含义是________。</strong></p><p><img src="https://nos.netease.com/edu-image/59F24C56F07146B09A29D0EDA648B7B1.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.其他全不对</li><li>B.查询没有学习过课程号为002号课程的学生姓名和年龄</li><li>C.查询不仅仅学习课程号为002号课程的学生姓名和年龄</li><li>D.查询学习课程号为002号课程的学生姓名和年龄</li></ul><blockquote><p>正确答案：A你错选为B</p></blockquote></li><li><p><strong>已知关系：学生（学号，姓名，性别，年龄），课程（课程号，课程名，教师，学分），选课（学号，课程号，成绩）。表达查询“选修了教师01所教全部课程的学生的姓名”的关系代数操作是_________。</strong></p><ul><li>A.<img src="https://nos.netease.com/edu-image/3BED77968B6F7629F781F937FD9AC270.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>B.<img src="https://nos.netease.com/edu-image/0596343593EE391D1521CAC465F94DB9.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>C.<img src="https://nos.netease.com/edu-image/6F356F9007A5D0CDFB40FEF8CCABA6EB.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>D.<img src="https://nos.netease.com/edu-image/A76E817F90E6E5347EA9B5AA2115CF1C.png?imageView&thumbnail=520x520&quality=100" alt="img"></li></ul><blockquote><p>正确答案：A你没选择任何选项</p></blockquote></li><li><p>R x S与 S x R运算的结果是同一个关系</p></li><li><p><strong>设关系R和S的属性个数分别为n和m，那么R×S操作结果的属性个数为________。</strong></p><ul><li>A.n+m</li><li>B.n-m</li><li>C.n×m</li><li>D.max(n,m)</li></ul><blockquote><p>正确答案：A你错选为C</p></blockquote></li></ol><h2 id="第五讲"><a href="#第五讲" class="headerlink" title="第五讲"></a>第五讲</h2><ol><li><p><strong>关于关系运算，下列说法正确的是_______。</strong></p><ul><li>A.安全的元组演算公式和安全的域演算公式可以等价变换</li><li>B.关系代数运算和关系演算之间是互补的，即它们可以利用各自特点解决彼此不能解决的问题</li><li>C.关系代数和关系演算不一定是安全的</li><li>D.关系演算以属性为基本处理单位</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>已知下述关系，S(学号, 姓名, 年龄, 性别, 院系)，SC(学号，课程号,分数)，C(课程号,课程名,学分，教师名）。检索学习过刘玲老师所授课程的所有学生。表达正确的是________。</strong></p><ul><li>A.<img src="https://nos.netease.com/edu-image/E957F4A2C298FD23F08BADD9807D65CC.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>B.<img src="https://nos.netease.com/edu-image/8C8CF192B5E701D72952DB8E54EA3DD4.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>C.<img src="https://nos.netease.com/edu-image/A4DE771759C9940D9C9BF0BB51E14581.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>D.<img src="https://nos.netease.com/edu-image/0013A82A13E9A7380ABBA8CF90E01729.png?imageView&thumbnail=520x520&quality=100" alt="img"></li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>已知下述关系，S(学号, 姓名, 年龄, 性别, 院系),SC(学号，课程号,分数),C(课程号,课程名,学分，教师名）。检索学号为S3学生所学课程的课程号与任课教师名。表达正确的是________。</strong></p><ul><li>A.** { &lt;t[1],t[4]&gt;| tÎC Ù $ (uÎS) $ (vÎSC)(u[1]=‘S3’ Ùu[1]=v[1] Ùt[1]=v[2])**</li><li>B.<img src="https://nos.netease.com/edu-image/56388A947EA8C272C829C592BFDB0214.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>C.<img src="https://nos.netease.com/edu-image/971574DC33BB2F7BBAEB556711AFE701.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>D.<img src="https://nos.netease.com/edu-image/3B5E2A4011C244C0113A911C576980B4.png?imageView&thumbnail=520x520&quality=100" alt="img"></li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>已知下述关系，Student(学号, 姓名, 年龄, 性别, 院系),SC(学号，课程号,分数),C(课程号,课程名,学分，教师名）。请用关系演算公式表达“检索出年龄不是最小的，所学课程都及格的所有同学”，表达结果正确的是_______。</strong></p><ul><li>A.<img src="https://nos.netease.com/edu-image/2EA072D36EBE2B2D76CC026B26378ECE.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>B.<img src="https://nos.netease.com/edu-image/53B4B0B0174635C95C9C4F7E79EE7493.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>C.<img src="https://nos.netease.com/edu-image/2C5358FDE58842E28F966E8E73EB40C2.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>D.<img src="https://nos.netease.com/edu-image/6746F6E068B7C7B5BEE43CE03EF9192F.png?imageView&thumbnail=520x520&quality=100" alt="img"></li></ul><blockquote><p>正确答案：A你错选为D</p></blockquote></li><li><p><strong>关于关系运算的安全性，说法不正确的是________。</strong></p><ul><li>A.关系演算是安全的</li><li>B.关系代数是一种集合运算，是安全的</li><li>C.任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性。</li><li>D.集合本身是有限的，有限元素集合的有限次运算仍旧是有限的</li></ul><blockquote><p>正确答案：A你错选为D</p></blockquote></li><li><p><strong>关于关系运算的说法，不正确的是________。</strong></p><ul><li>A. 相比之下：域演算的非过程性最好，关系代数次之，元组演算最差</li><li>B.关系代数与安全的元组演算表达式与安全的域演算表达式是等价的</li><li>C.一个数据库语言如果能够等价地实现这三种关系运算的操作，则说该语言是完备的</li><li>D. 目前多数数据库语言都能够实现这三种运算的操作，在此基础上还增加了许多其他的操作，如赋值操作、聚集操作等</li></ul><blockquote><p>正确答案：A你错选为B</p></blockquote></li><li><p><strong>假设R(A,B,C)，S(D,E)分别是三元和二元关系，把表达式<img src="https://nos.netease.com/edu-image/7A2BAC291A581A29DF0AAEBF6E6C0384.png?imageView&thumbnail=520x520&quality=100" alt="img">转换成等价的元组表达式正确的是_________。</strong></p><ul><li>A.<img src="https://nos.netease.com/edu-image/BA1D0958C26D921FD6B127FAA1159B73.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>B.<img src="https://nos.netease.com/edu-image/87E7D893253A00B1932824CC3CC78BBF.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>C.<img src="https://nos.netease.com/edu-image/91F7DA91E4F6EF4235B6962FBADD727C.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>D.<img src="https://nos.netease.com/edu-image/D235FEE5A6DAE29B0ED815787B8D436B.png?imageView&thumbnail=520x520&quality=100" alt="img"></li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li></ol><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ol><li><p><strong>SQL语言集数据查询、数据操纵、数据定义和数据控制功能于一体，其中，CREATE、DROP、ALTER语句是实现哪种功能_________。</strong></p><ul><li>A.数据定义</li><li>B.数据查询</li><li>C.数据操纵</li><li>D.数据控制</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>在关系模型中关于结果唯一性问题，结果排序问题，模糊查询问题，如下说法不正确的是_________。</strong></p><ul><li>A.结果排序是在Select语句中通过增加order by子句实现的，后只能跟DESC或省略为降序。</li><li>B.在Table中要求无重复元组是通过定义Primary key或Unique来保证的;而在检索结果中要求无重复元组, 是通过在SELECT子句中引入DISTINCT保留字来实现的。</li><li>C.模糊查询是通过在Select语句的Where子句中引入运算符like来实现的</li><li>D.在SELECT语句的Like条件中，用“%”去匹配字符%，用_ 去匹配字符_</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>SQL语言中，删除一个表的命令是________。</strong></p><ul><li>A.DROP</li><li>B.DELETE</li><li>C.CLEAR</li><li>D.REMOVE</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>学生关系S（S#,Sname,Ssex,Sage,D#,Sclass）,S的属性分别表示学生的学号、姓名、性别、年龄。要在表S中删除一个属性“年龄”，可选用的SQL语句是_________。</strong></p><ul><li>A.ALTER  TABLE  S  DROP  Sage</li><li>B.DELETE  Sage  from</li><li>C.UPDATE  S  Sage</li><li>D.ALTER  TABLE  S ‘Sage’</li></ul><blockquote><p>正确答案：A你错选为D</p></blockquote></li><li><p><strong>查询结果输出时要求按“总评成绩”降序排列，相同者按“性别”升序，正确的子句是_________。</strong></p><ul><li>A.ORDER BY 总评成绩 DESC,性别</li><li>B.ORDER BY 总评成绩,性别 DESC</li><li>C.ORDER BY 总评成绩 DESC,性别 DESC</li><li>D.ORDER BY 总评成绩 ASC,性别 DESC</li></ul><blockquote><p>正确答案：A你选对了</p><p>注：order by默认为升序</p></blockquote></li><li><p>**在下列SQL语句中，属于数据控制语言DCL的是_________**<strong>。</strong></p><p><strong>1、CREATE  2、SELECT  3、UPDATE  4、GRANT  5、DELETE  6、ALTER   7、INSERT   8、REVOKE</strong></p><ul><li>A.4，8</li><li>B.1，5，6，7</li><li>C.2，3，6，8</li><li>D.1，5，7</li></ul><blockquote><p>正确答案：A你选对了</p><p>NOTE: </p><p>DDL包括create、alter、drop；</p><p>DML包括insert、delete、update、select；</p><p>DCL包括grant（授权）、revoke（撤销授权）；</p></blockquote></li><li><p><strong>在SELECT语句中，与关系代数中s运算符对应的是________子句。</strong></p><ul><li>A.WHERE</li><li>B.SELECT</li><li>C. FROM</li><li>D.GROUP BY</li></ul><blockquote><p>正确答案：A你错选为B</p></blockquote></li></ol><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ol><li><p>SQL语言中，子查询是嵌套到另一个查询语句中的查询语句；</p></li><li><p><strong>陈述A：SubQuery1 UNION SubQuery2语句，其中SubQuery1和SubQuery2查询中相应的列必须以同一顺序出现。 陈述B：GROUP BY和HAVING子句不能在子查询中使用，这些子句只能用在最后一个查询结束时来总结和排序最后结果集。 关于陈述A和B，下列说法正确的是_________。</strong></p><ul><li>A.陈述A正确，陈述B错误</li><li>B.都是正确的</li><li>C.都是错误的</li><li>D.陈述A错误，陈述B正确</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>下面有关HAVING子句，说法不正确的是_________。</strong></p><ul><li>A.使用HAVING子句的同时不能使用WHERE子句</li><li>B.HAVING子句必须与GROUP BY 子句同时使用，不能单独使用</li><li>C.使用HAVING子句的同时可以使用WHERE子句</li><li>D.使用HAVING子句的作用是过滤掉不满足条件的分组</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>关于SQL视图更新的可执行性，下列说法不正确的是_________。</strong></p><ul><li>A.对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选择、投影操作导出的，并且包含了基本表的主键，则不能更新</li><li>B.如果视图的select目标列包含聚集函数，则不能更新</li><li>C.如果视图中包括了group by子句，则不能更新</li><li>D.如果视图是由单个表的列构成，但并没有包括主键，则不能更新</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>合并多个查询结果集，应使用_________保留字。</strong></p><ul><li>A.union</li><li>B.join</li><li>C.into</li><li>D.and</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>假如有两个表的连接是这样的：table_1 INNER JOIN table_2，其中table_1和table_2是两个具有公共属性的表，这种连接会生成哪种结果集_________。</strong></p><ul><li>A.只包括table_1和table_2中满足条件的行的组合结果</li><li>B.包括table_1中的所有行但不包括table_2的不匹配行的所有组合结果</li><li>C.包括table_2中的所有行但不包括table_1的不匹配行的所有组合结果</li><li>D.包括两个表的所有行的组合结果</li></ul><blockquote><p> 正确答案：A你选对了</p><p> 内连接：两者公共，左外连接：保留左边标的所有元素，右侧没有满足条件的为空；右外与左外类似；全外连接是上两者的并集；</p></blockquote></li><li><p><strong>有关SQL语言的空值处理，以下说法不正确的是_________。</strong></p><ul><li>A.除is [not] null之外，空值满足任何查找条件</li><li>B.如果null参与比较运算，有些情况下是可以判断为真的或为假的。</li><li>C.如果null参与聚集运算，则除count(*)之外其它聚集函数都忽略null</li><li>D.如果null参与算术运算，则该算术表达式的值为null</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>已知如下关系：学生Student(S#, Sname)，课程Course(C#, Cname, T#)，选课SC(S#, C#, Score)，教师T(T#, Tname)。其中S#为学号，Sname为学生命名，C#为课号，Cname为课程名，T#为教师编号，Score为成绩，Tname为教师名。</strong></p><p><strong>阅读SQL语句</strong></p><p><strong>SELECT S# FROM SC WHERE Score&lt;60 AND Count(*)&gt;2 GROUP BY S#；</strong></p><p>**关于其查询结果，下列说法正确的是_____**<strong>。</strong></p><ul><li>A.其它选项的说法都不正确</li><li>B.有2门以上不及格课程的同学的学号</li><li>C.有2门以上及格课程的同学的学号</li><li>D.有2人以上不及格课程的同学的学号</li></ul><blockquote><p>正确答案：A你错选为B</p></blockquote></li><li><p><strong>已知如下关系：学生Student(S#, Sname)，课程Course(C#, Cname, T#)，选课SC(S#, C#, Score)，教师T(T#, Tname)。其中S#为学号，Sname为学生命名，C#为课号，Cname为课程名，T#为教师编号，Score为成绩，Tname为教师名。</strong></p><p><strong>阅读SQL语句</strong></p><p><strong>SELECT S# FROM SC WHERE Score&lt;60 GROUP BY C# HAVING Count(*)&gt;2；</strong></p><p>**关于其查询结果，下列说法正确的是_____**<strong>。</strong></p><p>得分/总分</p><ul><li>A.有2门以上不及格课程的同学的学号</li><li>B.其它选项的说法都不正确</li><li>C.有2人以上及格课程的同学的学号</li><li>D.有2人以上不及格课程的同学的学号</li></ul><blockquote><p>正确答案：D你错选为B</p><p><strong>解析：</strong>  A、此选项不正确。是2人，而不是2门。GROUP BY 是分组查询。Score&lt;60 GROUP BY S# HAVING Count(*)&gt;2，表示两门以上课程成绩小于60，所以整个语句表示有2人以上不及格课程的同学的学号  B、此选项不正确。其它中有正确的。  C、此选项不正确。不是及格，而是不及格。  D、此选项正确。GROUP BY 是分组查询，Score&lt;60 GROUP BY C# HAVING Count(*)&gt;2，表示两人以上课程成绩小于60，所以整个语句表示有2人以上不及格课程的同学的学号</p></blockquote></li><li><p><strong>现有关系数据库如下：学生（学号，姓名，性别，专业、奖学金），课程（课程号，课程名，学分），选课（学号，课程号，分数），用SQL语言实现题目：检索没有任何一门课程成绩在80分以下的所有学生的信息，包括学号、姓名和专业，正确的SQL语句是_____。</strong></p></li></ol><ul><li>A.SELECT 学号，姓名，专业 FROM 学生 WHERE 学号 NOT  IN  (SELECT 学号 FROM 选课  WHERE 分数&lt;80)</li><li>B.SELECT 学号，姓名，专业 FROM 学生，选课 WHERE 学号 NOT  IN  (SELECT 学号 FROM 选课  WHERE 分数&lt;80)</li><li>C.SELECT 学号，姓名，专业 FROM 学生，选课 WHERE 学号 IN  (SELECT 学号 FROM 选课   WHERE 分数&lt;80)</li><li>D.SELECT 学号，姓名，专业 FROM 学生  WHERE 学号 IN  (SELECT 学号 FROM 选课  WHERE 学生.学号=选课.学号 AND分数&lt;80)</li></ul><blockquote><p>正确答案：A你错选为B</p></blockquote><ol start="11"><li><p><strong>假设一个元组在子查询1中出现m次，在子查询2中出现n次，其中m&gt;0,n&gt;0, 则下列说法正确的是____ ____。</strong></p><ul><li>A.该元组在“子查询1  Except  子查询2”中出现0次；</li><li>B.该元组在“子查询1  Union  子查询2”中出现m + n次；</li><li>C.该元组在 “子查询1  Except  ALL  子查询2”中出现m – n次；</li><li>D.该元组在“子查询1  Intersect  子查询2”中出现min(m,n)次；</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>假设一个元组在子查询1中出现m次，在子查询2中出现n次，其中m&gt;0,n&gt;0,则下列说法正确的是_________。</strong></p><ul><li>A.该元组在“子查询1  Union  ALL 子查询2”中出现m + n次；</li><li>B.该元组在 “子查询1 Union  子查询2”中出现m+n次；</li><li>C.该元组在“子查询1  Union  ALL 子查询2”中出现1次；</li><li>D.该元组在 “子查询1 Union  子查询2”中出现Min(m,n)次；</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>假设一个元组在子查询1中出现m次，在子查询2中出现n次，其中m&gt;0,n&gt;0,则下列说法正确的是_________。</strong></p><ul><li>A.该元组在“子查询1  Except  子查询2”中出现0次；</li><li>B.该元组在“子查询1  Union  子查询2”中出现m + n次；</li><li>C.该元组在 “子查询1  Except All 子查询2”中出现m – n次；</li><li>D.该元组在“子查询1  Union All  子查询2”中出现max(m,n)次；</li></ul><blockquote><p>正确答案：A你选对了</p><p>带all的会有重复元素，不带的没有重复元素，注意！</p></blockquote></li><li><p><strong>在下列关于视图的叙述中，正确的是_______。</strong></p><ul><li>A.当某一视图删除后，由该视图导出的其它视图也将自动删除；</li><li>B.若导出某视图的基本表被删除，该视图将不受任何影响；</li><li>C.视图—旦建立，就不能被删除；</li><li>D.当修改某一视图时，导出该视图的基本表也随之修改。</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>SQL语言中的视图是一种_________。</strong></p><ul><li>A.子模式及子模式到模式的映像；</li><li>B.全局模式及全局模式到子模式的映像；</li><li>C.内模式及内模式到模式的映像；</li><li>D.模式及模式到概念模式的映像；</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>有一个学生表student，包含主键S#（学生编号）等。又有分数表SC，包含S#（学生编号）、score（分数）等。已知student表中共有50个学生，有45人参加了考试（分数存在SC表中），其中10人不及格。执行以下SQL语句：select * from student where exists (select S# from SC where score&lt;60 )， 可返回_________条记录。</strong></p><ul><li>A.50</li><li>B.45</li><li>C.10</li><li>D.35</li></ul><blockquote><p>正确答案：A你错选为C</p><p>exits后面的select语句有返回则 True；</p></blockquote></li></ol><h2 id="第八讲"><a href="#第八讲" class="headerlink" title="第八讲"></a>第八讲</h2><ol><li><p><strong>QL语言的GRANT和REVOKE语句主要是用来维护数据库的_________。</strong></p><ul><li>A.安全性</li><li>B.完整性</li><li>C.可靠性</li><li>D.一致性</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p>安全性控制的对象是非法非授权对象；</p></li><li><p>在数据库的安全性控制中，授权数据对象的范围越小，授权子系统就越灵活；</p></li><li><p>关系模型的完整性包括：实体完整性、参照完整性（外键）、用户自定义完整性；</p></li><li><p><strong>已知employee表中具有默认约束df_email，删除该约束的语句为_________。</strong></p><ul><li>A.alter table employee drop constraint df_email</li><li>B.alter table employee remove constraint df_email</li><li>C.alter table employee delete constraint df_email</li><li>D.remove constraint df_email from table employee</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p><strong>关于DBMS的安全机制，下列说法不正确的是_________。</strong></p><ul><li>A.当有对DB访问操作时，任何人都被允许访问</li><li>B.强制安全性机制是通过对数据和用户强制分类，从而使得不同类别用户能够访问不同级别的数据</li><li>C.自主安全性是通过授权机制来实现的</li><li>D.推断控制机制是防止通过历史信息或统计信息，推断出不该被其知道的信息，防止通过公开信息推断出私密信息</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p>create table的三种功能包括：定义关系模式、完整性约束、物理存储模式；</p></li><li><p><strong>Col_constr列约束只能应用在单一列上，下面不是应用在单一列上的约束是_________。</strong></p><ul><li>A.FOREIGN KEY</li><li>B.UNIQUE</li><li>C.search_cond</li><li>D.PRIMARY KEY</li></ul><blockquote><p>正确答案：A你错选为D</p></blockquote></li></ol><h2 id="第九讲"><a href="#第九讲" class="headerlink" title="第九讲"></a>第九讲</h2><ol><li><p>以下嵌入式SQL语句，没有错误的是_________。</p><ul><li>A.exec sql select Sname,Sage into vSname,vSage from Student where Sname = specName;</li><li>B.exec sql begin declare section char vSname[10], specName[2]=“lzt”；int vSage;</li><li>C.exec sql select Sname,Sage into :vSname, :vSage from Student where Sname = :specName;</li><li>D.其他有多于一个的选项没有错误。</li></ul><blockquote><p>正确答案：C你错选为A</p><p>使用高级语言的变量需要在变量前添加冒号；</p></blockquote></li><li><p>关于事务，下列说法正确的是__________。</p><ul><li>A.必须以Begin  Transaction和End  Transaction显性地标记开始和结束；</li><li>B.事务在处理过程中是可以被中断的，且中断前的执行结果也是有效的；</li><li>C.一个事务仅能包含一条SQL语句，多条SQL语句将产生多个事务；</li><li>D.SQL语句在执行过程中，必须有提交或撤消语句才能确认其对数据库的永久操作结果；</li></ul><blockquote><p>正确答案：D你选对了</p></blockquote></li><li><p>关于游标，下列说法正确的是_________。</p><ul><li>A.游标使用之前需要先声明再打开；</li><li>B.一个游标只能打开与关闭一次；</li><li>C.游标中的 SQL语句被执行并产生结果是在Declare Cursor时进行的；</li><li>D.若要重新执行游标中的SQL语句，需要重新声明游标并打开游标；</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p>嵌入式SQL语言 中Whenever的作用范围是_________。</p><ul><li>A.其后的所有Exec SQL语句直到程序结束；</li><li>B.其后的所有Exec SQL语句直到与数据库断开连接；</li><li>C.其后的所有Exec SQL语句直到程序中出现另一条相同条件的Whenever语句为止。</li><li>D.其后的所有Exec SQL语句直到其执行过程中遇到另一条相同条件的 Whenever语句为止。</li></ul><blockquote><p>正确答案：C你错选为A</p></blockquote></li><li><p>关于事务，下列说法不正确的是_________。</p><ul><li>A.事务是一条或多条SQL语句的一次执行；</li><li>B.事务的一组更新操作是原子不可分的；</li><li>C.事务的操作状态是正确的，符合一致性的操作规则；</li><li>D.并发执行的多个事务之间可能互相影响，需要程序员考虑周全；</li></ul><blockquote><p>正确答案：D你错选为C</p></blockquote></li><li><p>以下哪一个不是状态捕获语句exec sql whenever condition action中condition所指代的条件__________。</p><ul><li>A.SQLERROR</li><li>B.NOT FOUND</li><li>C.SQLWARNING</li><li>D.CONTINUE</li></ul><blockquote><p>正确答案：D你错选为A</p></blockquote></li><li><p>关于嵌入式SQL语言状态捕获处理机制的说法，不正确的是_________。</p><ul><li>A.状态捕获及处理机制由三部分构成：(1)设置SQL通信区SQLCA；(2)设置状态捕获语句；(3)状态处理程序。</li><li>B.状态捕获语句可以作用于整个程序。</li><li>C.状态捕获语句容易引发整个程序进入无限循环。</li><li>D.DBMS记录状态信息有三种方法： (1)sqlcode；(2)sqlca.sqlcode；(3)sqlstate</li></ul><blockquote><p>正确答案：B你错选为C</p></blockquote></li><li><p>事务是数据库运行的基本单位。如果一个事务执行成功，则全部更新结果将被写到永久存储设施上；如果一个事务执行失败，则对永久存储设施上的数据已做过的更新被恢复原状，好像整个数据库从未有过这些更新，这样保持了数据库处于_________状态。</p><ul><li>A.安全性</li><li>B.一致性</li><li>C.完整性</li><li>D.可靠性</li></ul><blockquote><p>正确答案：B你错选为A</p></blockquote></li><li><p>通过游标对表进行删除或者更新操作时，WHERE CURRENT OF的作用是允许更新或删除当前游标的记录.</p></li><li><p>执行下面的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">  exec sql  whenever  sqlerror  <span class="keyword">goto</span>  handle_error；</span><br><span class="line">  <span class="function">exec sql  create table <span class="title">customers</span><span class="params">(cid  <span class="keyword">char</span>(<span class="number">4</span>)  <span class="keyword">not</span> null, cname varchar(<span class="number">13</span>), …)</span>；</span></span><br><span class="line"><span class="function">  … </span></span><br><span class="line"><span class="function">  handle_error：</span></span><br><span class="line"><span class="function">  exec sql drop customers；</span></span><br><span class="line"><span class="function">  exec sql disconnect；</span></span><br><span class="line"><span class="function">  <span class="title">fprintf</span><span class="params">(<span class="built_in">stderr</span>,”could <span class="keyword">not</span> create customers table\n”)</span>；</span></span><br><span class="line"><span class="function">  <span class="keyword">return</span> -1；</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>​</p><p>如果customers表在执行过程中出现了问题，没有人为干预，则该程序“Exec sql drop customers；”语句将被执行的次数为_________。</p><ul><li>A.0次</li><li>B.1次</li><li>C.不确定的有限次数</li><li>D.无限次数</li></ul><blockquote><p>正确答案：D你错选为A</p></blockquote></li></ol><h2 id="第十讲"><a href="#第十讲" class="headerlink" title="第十讲"></a>第十讲</h2><ol><li><p>数据字典是数据库系统中最重要的数据之一，是DBMS记录“表”的定义的数据，当然也保存着关于“表”的各种运行参数。DBMS中的数据字典可以________。</p><ul><li>A.用SQL语言查询</li><li>B.由任何用户使用</li><li>C.没有</li><li>D.由用户创建</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p>数据字典通常是由下面哪个组成_________。</p><ul><li>A.表和视图</li><li>B.用户和权限</li><li>C.角色和视图</li><li>D.用户和表</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p>下面关于数据字典的描述中，不正确的是________。</p><ul><li>A.数据字典是用户通过SQL-DML(SELECT, UPDATE, DELETE, INSERT)建立和维护的；</li><li>B.数据字典是元数据而不是数据本身</li><li>C.数据字典通常也用二维表结构存储相关的数据</li><li>D.数据字典是DBMS维护和查询数据库所依赖的重要数据</li></ul><blockquote><p>正确答案：A你错选为D</p></blockquote></li><li><p>以下关于JDBC的叙述，不正确的是_________。</p><ul><li>A.JDBC通过一组Java接口实现其目标</li><li>B.JDBC使用java.sql.DriverManager类和java.sql.Driver类连接到数据库</li><li>C.JDBC可做三件事：与数据库建立连接、创建SQL语句对象并执行、返回结果数据集并提取数据给高级语言程序</li><li>D.JDBC是一种用于执行SQL语句的Java API 的面向对象的应用程序接口</li></ul><blockquote><p>正确答案：B你错选为C</p></blockquote></li><li><p>应用程序使用JDBC API访问数据库的具体实施过程有4步：</p><p>(1) 通过URL得到一个Connection对象, 建立数据库连接；</p><p>(2) 创建一个Statement对象(PreparedStatement或CallableStatement)，用来查询或者修改数据库；</p><p>(3) 传递一个Driver给DriverManager，加载数据库驱动；</p><p>(4) 执行查询并返回一个ResultSet，提取数据到应用程序。</p><p>若要使用这四步，正确顺序是_________。</p><ul><li>A.3124</li><li>B.3214</li><li>C.1234</li><li>D.1324</li></ul><blockquote><p>正确答案：A你错选为B</p></blockquote></li><li><p>下列关于动态SQL语句的叙述中，不正确的是_________。</p><ul><li>A.动态SQL 语句是SQL 标准提供的一种语句运行机制</li><li>B.<br>动态SQL 语句是指在程序编译时尚未确定，需要在程序执行过程中临时生成的SQL语句</li><li>C.SQL 标准引入动态SQL 语句的原因是由于静态SQL 语句不能提供足够的编程灵活性</li><li>D.SQL 标准提供的动态SQL 语句的执行方式只有立即执行方式</li></ul><blockquote><p>正确答案：D你错选为A</p></blockquote></li><li><p>下列关于动态SQL、静态SQL的叙述中，不正确的是_________。</p><ul><li>A.SQL语句在程序中已经按要求写好，体现为一个可执行的SQL语句，把一些参数通过变量传送给SQL语句即可执行，这是静态SQL</li><li>B.SQL语句在程序中动态构造，体现为一个字符串，然后再交给DBMS执行，执行时可以传递变量，这是动态SQL</li><li>C.动态SQL语句的执行方式只能是Prepare-Execute-Using方式，即预编译-传递参量并执行</li><li>D.动态SQL 语句是指在程序编译时尚未确定，需要在程序执行过程中临时生成的SQL语句</li></ul><blockquote><p>正确答案：C你选对了</p></blockquote></li><li><p>SQLCA和SQLDA是嵌入在C语言中的SQL语言经常使用的两种数据结构。关于SQLCA和SQLDA，下列说法正确的是_________。</p><ul><li>A.SQLCA是SQL通讯区，记录着SQL语句被DBMS执行后返回的状态信息；SQLDA是SQL描述区，记录着数据库/表等对象的定义信息。</li><li>B.SQLCA是SQL通讯区，记录着数据库/表等对象的定义信息；SQLDA是SQL描述区，记录着SQL语句被DBMS执行后返回的状态信息。</li><li>C.SQLCA是SQL描述区，记录着SQL语句被DBMS执行后返回的状态信息；SQLDA是SQL通讯区，记录着数据库/表等对象的定义信息。</li><li>D.SQLCA是SQL描述区，记录着数据库/表等对象的定义信息；SQLDA是SQL描述区，记录着SQL语句被DBMS执行后返回的状态信息。</li></ul><blockquote><p>正确答案：A你错选为B</p></blockquote></li><li><p>关于嵌入式SQL语言的思维模式：建立数据库连接、声明一个游标(游标与SQL语句绑定)、打开游标(执行SQL语句)、循环地获取一条一条记录(属性与高级语言变量绑定)、关闭游标、可循环地再打开到关闭游标、断开数据库连接。</p></li><li><p> ODBC思维：建立数据库连接、请求分配语句句柄(申请内存空间)、用句柄执行SQL(句柄与SQL语句绑定)、建立高级语言变量与句柄属性的对应、循环地获取一条一条记录、释放语句句柄→断开数据库连接；</p></li><li><p>SQL语句执行后，需要将结果记录集中的属性值，读到高级语言的变量中，那什么时候建立高级语言变量与属性的绑定，下列说法不正确的是_________。</p><ul><li>A.嵌入式SQL语言：在一条一条地读取记录时(Fetch)建立绑定。</li><li>B.ODBC：在开始一条一条地读取记录之前用专门的语句建立绑定。</li><li>C. JDBC：一条一条记录的，边绑定，边读取相应的属性值。</li><li>D.其他选项说法有不正确的。</li></ul><blockquote><p>正确答案：D你没选择任何选项</p></blockquote></li></ol><h1 id="中"><a href="#中" class="headerlink" title="中"></a>中</h1><h2 id="第一讲-1"><a href="#第一讲-1" class="headerlink" title="第一讲"></a>第一讲</h2><ol><li><p>如右图所示E-R图，“保存”是一个联系，其指向“图书”的基数为__________。</p><p><img src="https://nos.netease.com/edu-image/7C97443EEE584FEDA0ED57FBD40670C6.jpg?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.0..1；</li><li>B.1..1；</li><li>C.0..m；</li><li>D.1..m；</li></ul><blockquote><p>正确答案：C你错选为B</p><p>一个书架既可以放0本书也可以放多本书</p></blockquote></li><li><p>如图所示，这是为民政局开发的婚姻管理系统的E-R图，“婚姻”是一个联系，其指向“女人”的基数为__________。</p><p><img src="https://nos.netease.com/edu-image/35B47E6AD200CCFE3B700EB4735D1610.jpg?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.0..1；</li><li>B.1..1；</li><li>C.0..m；</li><li>D.1..m；</li></ul><blockquote><p>正确答案：C你错选为B</p><p>因为是民政局婚姻管理系统,其管理的是人们的历史婚姻状况,那一个人可以有多次婚姻关系,也可以没有婚姻关系,因此选项 C 正确。而 A 至多一次、B 必须一次且仅一次、D 至少一次,都是不正确的。此题理解的关键是“民政局”,它是管理历史婚姻状况的机构,当然也管理当前婚姻状况。</p></blockquote></li><li><p>如图所示E-R图，“teaches”是一个联系，下列描述其蕴涵的规则，正确的是_______。</p><p><img src="https://nos.netease.com/edu-image/1B1E5750E3C764AE512518E5D0FBA7CA.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.一个Professor可以给多个Class授课，一个Class可以由多个Professor来授课。</li><li>B.一个Professor可以给多个Class授课，也可以不授课；一个Class必须有一个Professor来授课；</li><li>C.一个Professor可以给多个Class授课，也可以不授课；一个Class可以由多个Professor来授课，也可以不由任何Professor来授课；</li><li>D.一个Professor必须给一个Class授课；一个Class可以有多个Professor来授课，也可以没有Professor来授课；</li></ul><blockquote><p>正确答案：B你错选为D</p><p>解析:由图中 Class 端标示的是 0 到多,Professor 端标示的是 1,说明一个Professor 可以教多个 Class,也可以不教 Class。而一个 Class 只能由一个 Professor 来教。因此选项 B 正确。选项 A 的“一个 Class 可以由多个Professor 来授课”不正确;选项 C 的“一个 Class 可以由多个 Professor 来授课,也可以不由任何 Professor 来授课”不正确 ;选项 D的每一部分都不正确。</p></blockquote></li><li><p>如图所示E-R图，“takes”是一个联系，下列描述其蕴涵的规则，正确的是_________。</p><p><img src="https://nos.netease.com/edu-image/6A22BA92E9A51608E111565BD532C1F8.jpg?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.一个student可以选择多个class，也可以一个都不选；一个class可以有多个student来选，也可以没有student选择；</li><li>B.一个student至少选择一个class，也可以选择多个；一个class至少有一个student选择，也可以有多个student来选；</li><li>C.一个student可以选择多个class，也可以一个都不选；一个class至少有一个student选择，也可以有多个student来选；</li><li>D.一个student至少选择一个class，也可以选择多个；一个class可以有多个student来选，也可以没有student选择；</li></ul><blockquote><p>正确答案:D。解析:由图中 Class 端标示的是 1 到多,Student 端标示的是 0 到多,说明一个 Student 至少选择一个 Class,也可以选择多个 Class。而一个 Class 可以由多个 Student 来选择,也可以没有 Student 选择。 因此选项 D 正确。选项 A 和 C 的“一个 Student 可以一个(Class)都不选”不正确; 选项 B 和 C 的“一个 Class 至少有一个 Student 选择”不正确 ;选项 C 的每一部分都不正确。</p></blockquote></li><li><p>关系模型是数据模型，ER模型是概念模型；</p></li><li><p>E-R图建模过程中分析实体和联系是很重要的。 关于实体和联系，下列说法不正确的是___ ______。</p><ul><li>A.实体虽然是指一个个可相互区分的个体，但E-R图建模是要寻找这些个体的“型”，而非这些个体本身；</li><li>B.实体是可以用重叠量词来形容的，在问题域中不能用重叠量词形容的则不是实体；</li><li>C.联系是指一个实体的实例与另一个实体的实例之间可能存在的某种联系；</li><li>D.E-R图建模关键是发现实体之间存在什么联系，其重点是发现实体之间联系的度数或元数。</li></ul><blockquote><p>正确答案：D你选对了</p></blockquote></li><li><p>现实世界中经常出现如图所示的结构关系，比如产品结构、组织结构等等，若要为其建立E-R模型。则E-R图表达相对最正确的是____________</p><p><img src="https://nos.netease.com/edu-image/FAC1A820D19A2C2BDBDC4435A374BAD8.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.<img src="https://nos.netease.com/edu-image/11674DD247E0AA2AB9954E2F8AD7CBAA.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>B.<img src="https://nos.netease.com/edu-image/B3B3CF56BDCF7E6E9636DF90550B3C85.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>C.<img src="https://nos.netease.com/edu-image/91A763573F6C6D742C13130F7EA4AB55.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>D.<img src="https://nos.netease.com/edu-image/8B72C838934216ADAE24BC9AA59C3265.png?imageView&thumbnail=520x520&quality=100" alt="img"></li></ul><blockquote><p>正确答案：C你错选为A</p><p>解析:选项 A,没有进行抽象,绘制的是实体的实例关系,不正确;选项 B,的边应是联系,如此表达说不清楚结点和边的联系又是什么。选项 C 的表达相对是最正确的。选项 D,出现的结点 1 和结点 2 在 E-R 图建模中实际上是同一个实体,故此不正确。</p></blockquote></li><li><p>若要用E-R图表达“学生按班级选课”，则E-R图表达相对最正确的是____________</p><ul><li>A.<img src="https://nos.netease.com/edu-image/D944EEEBC2DA598AE435584098EFDF72.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>B.<img src="https://nos.netease.com/edu-image/893277E9238B4A68F7E060C36DBF9B53.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>C.<img src="https://nos.netease.com/edu-image/A79AB7FA07B88D3BA19769F17BD2B912.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>D.<img src="https://nos.netease.com/edu-image/A036B3E58CD1BFFB34EC954AD61E0E40.png?imageView&thumbnail=520x520&quality=100" alt="img"></li></ul><blockquote><p>正确答案：A你错选为B</p><p>解析:选项 A,“学生按班级选课”是一个功能,不要受其影响。其最本质的还是“学生”选修“课程”,学生是有班级属性的,“按班级选课”可以通过程序予以实现,而 E-R 图应反映的是选课的结果是怎样的。故此选项 A 最正确;选项 B,<br>“班级”不宜做实体,因为似乎找不到其他的刻画班级的属性(注意不要钻字眼),虽然说要按班级选课,但可通过程序实现该功能,只要保留选课的结果即可,相比 A,此选项不正确。选项 C,将“班级”属性置放于“课程”实体中不合适,因为一门课程可能对应多个班级,故不正确。选项D,没有建立学生和班级的联系,而这才是最重要的,故此不正确。</p></blockquote></li><li><p>若要为一个浴池开发信息系统，有搓澡工、收银员等，请仔细理解需求，并用E-R图表达需求。则E-R图表达需求，相对最正确的是____________</p><ul><li>A.<img src="https://nos.netease.com/edu-image/1C5696A7EDABBAFD700DDD460B50AF8D.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>B.<img src="https://nos.netease.com/edu-image/8B168E36D7DC48734FFECAA91110675A.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>C.<img src="https://nos.netease.com/edu-image/E5891ECC42301F69EFDFD366D2CF3CA3.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>D.<img src="https://nos.netease.com/edu-image/227B930DC2443759969812BB9F969AD6.png?imageView&thumbnail=520x520&quality=100" alt="img"></li></ul><blockquote><p>正确答案：D你错选为A。</p><p>解析:选项 A,在此问题中“老板”不能用一个个类似的重叠量词来形容,应不是实体,故不正确。选项 B,这是为某一个浴池开发信息系统,在此背景下,“浴池”也不能用一个个类似的重叠量词来形容,应不是实体,故不正确。选项 C 和选项 D 所发现的实体“客户”“员工”“服务项目”都是正确的,所不同的是“收费”这个联系,选项 C 建立的是客户和员工之间的联系,表明哪一个员工收取哪一个客户的费用,而选项 D 建立的是客户和服务项目之间的联系,表明哪一个客户为哪些服务项目支付费用,从应用的角度选项 D 的联系更为重要,故选项 D 正确。</p></blockquote></li><li><p>关于模型和元模型，下列说法不正确的是____________</p></li></ol><ul><li>A.模型是依据元模型中的抽象概念及其关系，对现实世界进行理解，获得具体概念及其具体关系所形成的；</li><li>B.元模型是对模型的抽象，而模型是对现实世界的抽象；</li><li>C.同一元模型，可以产生不同的模型；而同一现实世界，也可以产生不同的模型；</li><li>D.相比元模型，模型是由一组抽象概念及其之间关系构成的。</li></ul><blockquote><p>正确答案：D你错选为A</p><p>解析:选项 A 说法是正确的,这是元模型和模型之间的关系;选项 B 的说法是正确的,这是元模型和模型之间的关系;选项 C 的说法是正确的,同一元模型,针对不同的问题领域是有不同的模型的,比如我们学习的 E-R 图就是一种元模型,但针对图书馆信息系统、学生管理系统等则会绘制出不同的 E-R 图。同一现实世界,不同人进行理解,也是可以产生不同的模型的。选项 D 的说法是不正确的,相比元模型,模型是由一组具体概念及其之间关系构成的。这里应该是“具体”,比如元模型中的“实体”是抽象概念,而学生管理系统中的“学生”“课程”等则就是具体的概念。</p></blockquote><p>   ​</p><h2 id="第二讲-1"><a href="#第二讲-1" class="headerlink" title="第二讲"></a>第二讲</h2><ol><li><p>下列哪些实体不是IDEF1X中的实体。不是IDEF1X中实体的选项为____________</p><ul><li>A.独立实体与从属实体</li><li>B.相交实体或相关实体</li><li>C.类实体与对象实体</li><li>D.一般实体与分类实体</li></ul><blockquote><p>正确答案：C你选对了</p><p>解析:IDEF1X 将实体细化,区分为独立实体和从属实体;为了消除非确定联系,引入了相交实体或相关实体;为了表达泛化与具体化,引入了一般实体和分类实体。故此选项 A、B 和 D 中都是 IDEF1X 的实体。而选项 C,类实体和对象实体,在 IDEF1X 中是不存在的。实体有型与值的区分,实体的型简单称实体,而实体的值称为实例。因此,实<br>体相当于类的概念,而实例则相当于对象的概念。但不存在类实体和对象实体的概念。</p></blockquote></li><li><p>关于IDEF1X中的联系，下列说法不正确的是____________。</p><ul><li>A.标定联系和非标定联系都是一对多的联系（含一对一的联系）</li><li>B.分类联系就是对实体的实例进行分类，将一个实体的实例分类为若干个实体的实例，分类实体的属性和被分类实体的属性完全一致</li><li>C.不确定联系是多对多的联系，不能直接表达，需要将其转换为一对多的联系进行表达</li><li>D.IDEF1X图的联系已经通过属性继承和相交实体反映出来了，因此图中实体连线上标注的联系名字仅起辅助阅读的作用，数据库设计时可以不考虑它</li></ul><blockquote><p>正确答案：B你错选为D</p><p>解析:选项 A 的说法是正确的;选项 B 的说法是不正确的,分类联系不等同<br>于分类,如果分类实体的属性和被分类实体的属性完全一致,则其就不是分类实体也就不是分类联系,分类联系要求各个分类实体的关键字属性与被分类实体的关键字属性完全相同,但每个分类实体都有不同于其他分类实体的属性存在,因此选项 B 的说法不正确。选项 C的说法是正确的,要通过引入相交实体或称相关实体,将不确定联系转换为对相关实体的两个一对多联系进行表达。选项 D 的说法也是正确的,在 IDEF1X 图中,无论是实体还是联系都通过实体反映出来了(一是实体中的属性继承,一是相交/相关实体),因此实体之间的连线(无论有名字与无名字)仅起到辅助阅读的作用,数据库设计时完全不考虑它。</p></blockquote></li><li><p>关于IDEF1X中的实体与联系，下列说法不正确的是____________</p><ul><li>A.IDEF1X的“实体”将来要转换成关系模式，而其“联系”仅起辅助阅读的作用；</li><li>B.IDEF1X是通过“属性继承”在实体中建立了与另一个实体的连接联系(一对一或一对多的联系)；</li><li>C.IDEF1X是通过“相交实体”建立了两个实体之间的多对多联系，因此相交实体本质上是一种联系。</li><li>D.IDEF1X是通过继承另一个实体的关键字属性来建立两个实体之间联系的。被继承的关键字属性在本实体中作为一般属性还是作为关键字属性，没有什么差别；</li></ul><blockquote><p>正确答案：D你错选为A</p><p>被继承属性作为关键字属性,则其取值是不能为空的,即完全参与联系,而作为一般属性,则其取值是可以为空的,即不完全参与联系。</p></blockquote></li><li><p>下面两个图表达了合同与合同条目之间的关系。下列说法正确的是____________。</p><p><img src="https://nos.netease.com/edu-image/6C791EDD498FA568DE2158BC74AA9EF7.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.图(a)是正确的，图(b)是正确的</li><li>B.图(a)是不正确的，图(b)是正确的</li><li>C.图(a)是正确的，图(b)是不正确的</li><li>D.图(a)是不正确的，图(b)是不正确的</li></ul><blockquote><p>正确答案：D你错选为B</p><p>解析:图(a)的“合同条目”实体应继承“合同”实体的主关键字,这里没有属性继承,故不正确;图(b)“合同条目”本身不是独立实体,应是从属实体。虽然说明合同项总序号可以区分开每一合同条目,但此处的合并反映不出“有联系,就要有属性继承”,故图(b)也是不正确的。</p></blockquote></li><li><p>在某企业，通常多种物资可以一次性入库，填写一张入库单，则表达“入库单”与“物资”实体联系的IDEF1X图，相比之下最正确的是____________(注意，图中有意忽略联系的名称)</p><ul><li>A.<img src="https://nos.netease.com/edu-image/74B365798838FC8EEB3E5842103C3719.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>B.<img src="https://nos.netease.com/edu-image/50CA909E7D220388C83C59D569A250CF.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>C.<img src="https://nos.netease.com/edu-image/2DD110B85B0D99FAF7488F3F4836A473.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>D.<img src="https://nos.netease.com/edu-image/B89EA10C8F322221A56C79A0CD21ACC5.png?imageView&thumbnail=520x520&quality=100" alt="img"></li></ul><blockquote><p>正确答案：D你错选为C</p><p>解析:选项 A 图,从语法角度没有问题,但从内容角度是有问题的,此图表达的是“一张入库单只能填写一种物资(当然可以不填写)”与题意不符。选项 B 图,从语法角度没有问题,但从内容角度是有问题的,此图表达的是“一张入库单只能填写一种物资(当然可以不填写)”与题意不符。选项 C 图,从内容角度是没有问题的,此图表达的是“一张入库单可以填写多种物资”与题意相符,但从语法角度是有问题的,标定联系需用实线,而此处用的是虚线,故不正确。选项 D 图,从内容角度是没有问题的,此图表达的是“一张入库单可以填写多种物资”与题意相符,从语法角度也是没有问题的。</p></blockquote></li><li><p>如下图所示为某同学绘制的IDEF1X图。该图表达的业务规则是____________。</p><p><img src="https://nos.netease.com/edu-image/ACF6FB087B85E04FADC509EFF60ECA26.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.一个客户可以产生多张订单，一种商品能对应零或多个订单号，不同客户的相同订单号的订单对应不同种商品</li><li>B.一个客户可以产生多张订单，一种商品仅能对应零或一个订单号，不同客户的相同订单号的订单对应不同种商品</li><li>C.一个客户可以产生多张订单，一种商品仅能对应零或一个订单号，不同客户的相同订单号的订单对应同一种商品</li><li>D.一个客户可以产生多张订单，一种商品能对应零或多个订单号，不同客户的相同订单号的订单对应同一种商品</li></ul><blockquote><p>正确答案：C你错选为A</p><p>解析:选项 A+,该图表达的是一种商品能对应 0 或 1 个订单号,因为此实体的关键字是商品编码,每种商品仅出现一次,也就只能填一个订单号;此选项说对应多个订单号是不正确的;选项 C,因为商品实体仅继承了订单实体的部分关键字属性,此即不同客户的相同订单号的订单对应同一种商品,此选项说对应不同种商品是不正确的;选项 C,此说法符合图中的意思。选项 D,该图表达的是一种商品能对应 0 或 1 个订单号,因为此实体的关键字是商品编码,每种商品仅出现一次,也就只能填一个订单号;此选项说对应多个订单号是不正确的。</p></blockquote></li><li><p>若要用IDEF1X表达实体X与实体Y之间的多对多的联系，引入一个相交实体Z。则如果要表达实体X的实例和实体Y的实例的一个组合，可以出现多次的情况，且实体X和实体Y的实例均不能以空值组合出现，IDEF1X图绘制正确的是____________。</p><ul><li>A.<img src="https://nos.netease.com/edu-image/C862E81C10DC9B388E896B99BE201691.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>B.<img src="https://nos.netease.com/edu-image/E57B7BE73D9492748BCC6803B1717166.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>C.<img src="https://nos.netease.com/edu-image/BED79333B074A3577C741B08D79553DD.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>D.<img src="https://nos.netease.com/edu-image/DF3CC80D3855CA056B443F83CFA5B8EA.png?imageView&thumbnail=520x520&quality=100" alt="img"></li></ul><blockquote><p>正确答案：C你错选为B</p><p>解析:由“实体 X 和实体 Y 的实例均不能以空值组合出现”则可排除选项 B和选项 D,因为作为一般属性继承的外键是可以为空值的。由“实体 X 的实例和实体 Y 的实例的一个组合,可以出现多次的情况”,则可排除选项 A,选项 A 是一种组合只能出现一次,而选项 C,则是一种组合可以出现多次。故此题答案为选项 C。</p></blockquote></li></ol><h2 id="第三讲-1"><a href="#第三讲-1" class="headerlink" title="第三讲"></a>第三讲</h2><ol><li><p>如果采用关系数据库来实现应用，在数据库设计的逻辑设计阶段将关系模式进行规范化处理；</p></li><li><p>需求分析：收集需求和理解需求；</p></li><li><p>概念数据库设计：建立概念模型，ER图、IDEF1X图</p></li><li><p>逻辑数据库设计：简历物理模型，“create table”包括物理数据组织等、依赖于具体的dbms；</p></li><li><p>关于数据库设计，下列说法正确的是                        。</p><ul><li>A.若要开发一个信息系统，首先要确定使用哪一个DBMS来进行管理，然后才能进行数据库设计</li><li>B.概念数据库设计需要关注用E-R Diagram的思想来理解需求，而不能仅仅关注绘制E-R Diagram的图形</li><li>C.逻辑数据库设计的关注点是属性、结构和命名的冲突问题，数据库设计的规范性问题和DBMS的选型问题</li><li>D.物理数据库设计仅需要考虑数据量的大小、磁盘空间占用及存储结构等特性，但无关具体的DBMS</li></ul><blockquote><p>正确答案：B你选对了</p></blockquote></li><li><p>若要对E-R图<img src="https://nos.netease.com/edu-image/7308B4ADD74D59264F6B169B80B96EA0.png?imageView&thumbnail=520x520&quality=100" alt="img">中“班主任”联系进行处理，说法正确的是<strong>。</strong></p><ul><li>A.需要建立一个“班主任”的关系</li><li>B.不需要建立“班主任”关系，也不需任何处理</li><li>C.不需要建立“班主任”关系，但需要做处理，即将“教师”实体的关键字作为“学生”实体对应关系的属性</li><li>D.不需要建立“班主任”关系，但需要做处理，即将“学生”实体的关键字作为“教师”实体对应关系的属性</li></ul><blockquote><p>正确答案：C你错选为A</p><p>解析:这是一个一对多的联系。选项 A 说法不正确,不需要单独为“班主任”建立一个关系。选项 B 说法不正确。不需要建立“班主任”关系,但需做处理;选项 C 说法正确。选项 D 说法不正确,属性继承时,是多方实体对应的关系继承单方实体的关键字作为属性。</p></blockquote></li><li><p>如下所示Crow’s Foot方法表达的E-R图，问需要几个关系模式才能实现该E-R图。正确的选项是         。</p><p><img src="https://nos.netease.com/edu-image/3E5A3656015DED0C8A301FC95C6726DC.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.5个</li><li>B.4个</li><li>C.3个</li><li>D.2个</li></ul><blockquote><p>正确答案：B你选对了</p><p>解析:此图有三个实体可以用三个关系模式实现,有一个多对多的联系需要一个关系模式来实现,还有一个一对多的联系“聘任”,其可由实体“员工”对应的关系模式来实现,即在员工对应的关系模式中增加一个属性“商店号”即可。因此总计需要 4 个关系模式。</p></blockquote></li><li><p>如下所示Chen方法表达的E-R图，将其转换为关系模式。不正确的选项是________。</p><p><img src="https://nos.netease.com/edu-image/036C50A30B3A41ADBB08DD6283EB7E3F.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.学生(学号，姓名，出生日期)</li><li>B.学生(学号，姓名，年，月，日)</li><li>C.学生(学号，姓名，出生日期(年，月，日))</li><li>D.学生(学号，姓名，出生日期)，出生日期(年，月，日)</li></ul><blockquote><p>正确答案：C你错选为D</p><p>解析:选项 A 的转换是可以的,用程序解析出生日期提取年月日相关信息;选项 B 的转换是可以的,用程序合并年月日形成出生日期;选项 C 是不可以的,违反了关系的第一范式;选项 D 是可以的,出生日期这个关系可能没有什么意义,但从规则角度,类似这种类型的 E-R 图是可以这样转换的。</p></blockquote></li><li><p>如下所示Chen方法表达的E-R图，将其转换为关系模式。不正确的选项是_________。</p><p><img src="https://nos.netease.com/edu-image/3B7474D087DDDD934CDA0D2064909535.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.可以如下转换person（name, street, city）customer（name, credit-rating）employee（name, salary）</li><li>B.可以如下转换person（name, street, city）customer（name, street, city, credit-rating）employee（name, street, city, salary）</li><li>C.在一定条件下也可以如下转换customer（name, street, city, credit-rating）employee（name, street, city, salary）</li><li>D.在一定条件下也可以如下转换customer（name, credit-rating）employee（name, street, city, salary）</li></ul><blockquote><p>正确答案：D你错选为A</p><p>D。解析:选项 A 的转换是可以的,尽管存在查询 employee 的地址需要访问两个表的不利情况;选项 B 的转换是可以的,尽管存在地址信息可能同时存储三次的情况。选项 C 的转换是可以的,一定条件是指“ISA 联系是完全分类联系”。选项 D 的转换是不可以的,customer 丢失了相关地址信息,不符题意,故不正确。</p></blockquote></li><li><p>关于E-R 图向关系模式的转换的规则正确的是_________。</p><ul><li>A.复合属性转换时只能将每个分量属性作为所在实体对应关系的属性</li><li>B.一对一联系的转换只能将联系定义为一个新的关系，再将属性设为参与双方的关键字属性</li><li>C.泛化实体与具体化实体在转换时，可以不要泛化实体，而仅将具体化实体转换成关系</li><li>D.一对多联系的转换，需将多方参与实体的关键字作为单方参与实体对应关系的属性</li></ul><blockquote><p>正确答案：C你错选为A</p><p>解析:选项 A 说法不正确,复合属性转换时,有两种方案并非单一一种,即:或者仅将分量属性转换到关系的属性,或者可将复合属性作为单一属性转换到关系的属性;选项 B 说法不正确,一对一联系的转换不需要定义新的关系,可将其与某一个实体一并转换成一个关系。选项 C 的说法是正确的,泛化实体与具体化实体在转换过程中,可以仅将具体化实体转换成关系。选项 D 的说法是不正确的,说反了,一对多联系的转换,需将单方参与实体的关键字作为多方参与实体对应关系的属性。</p></blockquote></li><li><p><strong>下列由E-R图向关系模式转换具体实例中，明显不正确的是________。注意：关系模式中带下划线的属性为主键。</strong></p><ul><li>A.<img src="https://nos.netease.com/edu-image/4DED9E5B241263E61C0953556398DC16.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>B.<img src="https://nos.netease.com/edu-image/3A832D385907E9BA1C91ED836C067076.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>C.<img src="https://nos.netease.com/edu-image/AEBC1959253576E8DEE681FA95351A20.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>D.<img src="https://nos.netease.com/edu-image/4317254E9551797FC348FC2AF049A684.png?imageView&thumbnail=520x520&quality=100" alt="img"></li></ul><blockquote><p>正确答案：D你错选为A</p><p>解析:选项 A 虽然也不是很正确,“一个供应商对一个项目供应零件仅能一次”这个假设是不正确的,但却有可能正确,因未明确给出。选项 B 的转换是正确的。选项C 的转换也是正确的。选项 D 的转换是不正确的,因为明确给出了“学生包含本科生、研究生、留学生、交换生等”,此分类联系是不完全分类联系,因此在转换关系模式的时候,泛化实体/一般实体是不能被弃掉的。</p></blockquote></li></ol><h2 id="第四讲-1"><a href="#第四讲-1" class="headerlink" title="第四讲"></a>第四讲</h2><ol><li><p>如果X决定Y，且在X决定Y中X没有多余的属性，则X→Y是**__**___。</p><ul><li>A.部分函数依赖</li><li>B.传递函数依赖</li><li>C.完全函数依赖</li><li>D.多值依赖</li></ul><blockquote><p>正确答案：C你选对了</p></blockquote></li><li><p>在关系模式R(U，F)中，如果X→Y，存在X的真子集X1，使X1→Y，称函数依赖X→Y为**__****__**_。</p><ul><li>A.平凡函数依赖</li><li>B.部分函数依赖</li><li>C.完全函数依赖</li><li>D.传递函数依赖</li></ul><blockquote><p>正确答案：B你选对了</p></blockquote></li><li><p>如果X→Y，且Y→Z，则X→Z一定为**__**___。</p><ul><li>A.部分函数依赖</li><li>B.传递函数依赖</li><li>C.完全函数依赖</li><li>D.都不正确</li></ul><blockquote><p>正确答案：D你错选为B</p><p>解析：如果 X→Y，Y→Z，则 X→Z 是恒成立的，即其符合传递律。但若称其为传递函数依赖，则还需补充一些条件，即传递函数依赖比传递律要严格一些。故此，D正确。 </p></blockquote></li><li><p>关系模式R(A1，A2，A3，A4，A5，A6)，如果A1→(A3，A4)； (A2，A4)→A5； (A3，A5)→ A6，则关于R的说法正确的是**__**___。</p><ul><li>A.即不存在对候选键的部分函数依赖，又不存在对候选键的传递函数依赖</li><li>B.存在对候选键的部分函数依赖，但不存在对候选键的传递函数依赖</li><li>C.不存在对候选键的部分函数依赖，但存在对候选键的传递函数依赖</li><li>D.既存在对候选键的部分函数依赖，又存在对候选键的传递函数依赖</li></ul><blockquote><p>正确答案：D你错选为C</p><p>解析：此题候选键为(A1,A2)，能决定所有属性，但因有 A1→(A3,A4)，即存在部分函数依赖；又因有(A1，A2)→(A3，A5)；(A3，A5)→A6，所以存在传递函数依赖。</p></blockquote></li><li><p>已知关系R如下表所示。仅就此表而言，函数依赖全部存在于R中的选项为**__**___。</p><table><thead><tr><th><strong>A1</strong></th><th><strong>A2</strong></th><th><strong>A3</strong></th><th><strong>A4</strong></th><th><strong>A5</strong></th></tr></thead><tbody><tr><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>5</strong></td><td><strong>4</strong></td><td><strong>8</strong></td></tr><tr><td><strong>2</strong></td><td><strong>3</strong></td><td><strong>6</strong></td><td><strong>6</strong></td><td><strong>9</strong></td></tr><tr><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>5</strong></td><td><strong>4</strong></td><td><strong>8</strong></td></tr><tr><td><strong>2</strong></td><td><strong>3</strong></td><td><strong>7</strong></td><td><strong>6</strong></td><td><strong>5</strong></td></tr><tr><td><strong>5</strong></td><td><strong>4</strong></td><td><strong>5</strong></td><td><strong>4</strong></td><td><strong>8</strong></td></tr><tr><td><strong>1</strong></td><td><strong>4</strong></td><td><strong>8</strong></td><td><strong>5</strong></td><td><strong>6</strong></td></tr><tr><td><strong>1</strong></td><td><strong>8</strong></td><td><strong>5</strong></td><td><strong>4</strong></td><td><strong>8</strong></td></tr><tr><td><strong>7</strong></td><td><strong>9</strong></td><td><strong>8</strong></td><td><strong>7</strong></td><td><strong>6</strong></td></tr></tbody></table><ul><li>A.(A1，A2)→A4,  (A5, A4)→A3</li><li>B.A1 →A4,   A5→A3</li><li>C.(A2，A3)→A4，(A4，A5)→A2</li><li>D.(A1，A3)→A4，(A3，A5)→A4</li></ul><blockquote><p>正确答案：A你错选为D</p><p>解析：选项 A，这两个函数依赖均存在于 R 中；选项 B，这两个函数依赖均不存在于 R 中；选项 C，仅有（A2,A3）→A4 存在于 R 中；选项 D，仅有(A1,A3)→A4 存在于 R 中。 </p></blockquote></li><li><p>已知关系R(A，B，C，D，E，F，G)，函数依赖集F为{ AB → CF，AD→CE，AG→B，D→C，B→D }，问：F的最小覆盖为**__**___。</p><ul><li>A.{ AB→C，AB→F，AD→C，AD→E，AG→B，B→D，D→C}</li><li>B.{ AB→F，AD→E，AG→B，D→C，B→D}</li><li>C.{ AB→F，AD→C，AG→B，D→C，B→D}</li><li>D.{ A→F，B→F，AD→E，A→B，G→B，D→C，B→D}</li></ul><blockquote><p>正确答案：B你错选为D</p></blockquote></li><li><p>已知关系R(A，B，C，D，E，F，G)，函数依赖集F为{ A →B，B→CDE，AD→G，CG→F }，问：能从F中推导出的函数依赖是**__**___。</p><ul><li>A.A→G， A→F</li><li>B.C→F，G→F</li><li>C.D→G，B→E</li><li>D.B→G，C→G</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li></ol><h2 id="第五讲-1"><a href="#第五讲-1" class="headerlink" title="第五讲"></a>第五讲</h2><ol><li><p>1NF即每个属性都是不可分的，没有复合属性和多值属性；</p></li><li><p>2NF即每个非主属性都完全依赖于候选键；</p></li><li><p>3NF没有传递依赖；</p></li><li><p>满足3NF必满足2NF，满足2NF必满足1NF</p></li><li><p>数据库的规范化是为了解决数据库中的插入问题、删除问题、以及数据冗余问题；</p></li><li><p>设有关系模式W(C,P,S,G,T,R)，其中各属性的含义是：C课程，P教师，S学生，G成绩，T时间，R教室，根据定义有如下数据依赖集  D={ C→P，(S,C)→G，(T,R)→C，(T,P)→R，(T,S)→R}。关系模式W的一个候选键是_____，W的规范化程度最高达到_____。 正确选项为__________。</p><ul><li>A. (S,C)，1NF</li><li>B.(T,R)，3NF</li><li>C.(T,P)，4NF</li><li>D.(T,S)，2NF</li></ul><blockquote><p>正确答案：D你选对了</p></blockquote></li><li><p>在关系模式R(U，F)中，如果F是最小函数依赖集，则____________。</p><ul><li>A.R∈2NF</li><li>B.R∈3NF</li><li>C.R∈BCNF</li><li>D.R的规范化程度与F是否最小函数依赖集无关。</li></ul><blockquote><p>正确答案：D你没选择任何选项</p><p>注意一下</p></blockquote></li><li><p>在关系模式R(U，F)中，R中任何非主属性对候选键完全函数依赖是R∈3NF的___________。</p><ul><li>A.充分必要条件</li><li>B.必要条件</li><li>C.充分条件</li><li>D.既不充分也不必要条件</li></ul><blockquote><p>正确答案：B你选对了</p><p>前者是2NF的条件</p></blockquote></li><li><p>对关系模式：学生(学号,姓名,课程号,课程名,成绩)，说法正确的是_________。</p><ul><li>A.不满足第2范式</li><li>B.满足第2范式但不满足第3范式</li><li>C.满足第3范式</li><li>D.其他都不对</li></ul><blockquote><p>正确答案：A你选对了</p><p>有部分函数依赖</p></blockquote></li><li><p>对关系模式：邮编(城市, 街道, 邮政编码)，说法正确的是_________。</p><ul><li>A.不满足第2范式</li><li>B.满足第2范式但不满足第3范式</li><li>C.满足第3范式</li><li>D.其他都不对</li></ul><blockquote><p>正确答案：C你选对了</p></blockquote></li><li><p>一般情况，企业会将从一个供应商处一次所进的多种货物办理一次入库，因此设计了关系模式：入库单(单号, 日期, 库房, 供应商，物品, 数量, 金额)，下列说法正确的是___ ______。</p><ul><li>A.不满足第2范式</li><li>B.满足第2范式但不满足第3范式</li><li>C.满足第3范式</li><li>D.其他都不对</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p>对连锁商店的管理，设计了关系模式：商店(商店, 商品部, 商品，商品部经理)，下列说法正确的是_________。</p><ul><li>A.不满足第2范式</li><li>B.满足第2范式但不满足第3范式</li><li>C.满足第3范式</li><li>D.其他都不对</li></ul><blockquote><p>正确答案：B你错选为C</p><p>解析:依据题意寻找函数依赖有:(商店,商品)商品部,(商店,商品部),商品部经理。因此本题的候选键为(商店,商品),可以看出不存在部分函数依赖,满足第 2范式;但存在传递依赖,即商品部经理传递依赖于(商店,商品),不满足第 3 范式。故选项 B 正确。</p></blockquote></li><li><p>对图书管理，已知一种图书只能放在一个房间，可放置在多个书架，一个书架可放置多本图书，一个房间有多个书架，一个房间有一个管理员，请分析关系模式：图书(书号, 书名, 出版日期, 出版社, 房间号, 书架号, 管理员)，说法正确的是        。</p><ul><li>A.不满足第2范式</li><li>B.满足第2范式但不满足第3范式</li><li>C.满足第3范式</li><li>D.其他都不对</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p>对设备管理，请分析关系模式：设备(设备编号, 设备名, 生产商编号，生产商名称，生产商地址，配件编号，配件名称，配件价格，设备价格)，说法正确的是_______________。</p><ul><li>A.不满足第2范式</li><li>B.满足第2范式但不满足第3范式</li><li>C.满足第3范式</li><li>D.其他不对</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p>已知关系模式R（A，B，C），函数依赖集F={B→C, B→A，A→BC}。则关于R，说法正确的是_______________。</p><ul><li>A.R不满足第2范式</li><li>B.R满足第2范式但不满足第3范式</li><li>C.R满足第3范式但不满足Boyce-Codd范式</li><li>D.R满足Boyce-Codd范式</li></ul><blockquote><p>正确答案：D你错选为B</p><p>解析:首先确定候选键,候选键为 A 能完全所有属性,B 也能完全决定所有属性,所以 A 和 B 为候选键,非主属性为 C。再进一步判断不存在部分函数依赖,不存在传递依赖,所以满足第 2 和第 3 范式。再看有没有不依赖于候选键的函数依赖,也不存在,故此 R 满足 Boyce-Codd 范式。选项 D 正确。</p></blockquote></li><li><p>已知关系模式R（A，B，C，D），函数依赖集F={ A→C, DA→B }。则关于R，说法正确的是_______________。</p><ul><li>A.R不满足第2范式</li><li>B.R满足第2范式但不满足第3范式</li><li>C.R满足第3范式但不满足Boyce-Codd范式</li><li>D.R满足Boyce-Codd范式</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p>已知Sid商店，Pid商品编号，Cid商品名称，Did经营部，Mgr经营部经理，Scale经营部规模。下列属于3NF的关系模式是_________。</p><ul><li>A.R(Sid，Pid，Cid，Did，Mgr，Scale)</li><li>B.R(Sid，Pid，Did)</li><li>C.R(Sid，Pid，Cid，Did )</li><li>D.R(Sid，Pid，Did，Scale)</li></ul><blockquote><p>正确答案：B你选对了</p></blockquote></li><li><p>在R（XY）中，如果X→Y，并且对于X的某一个真子集X’，有X’→Y，则______。</p><ul><li>A.Y函数决定X</li><li>B.Y对X完全函数依赖</li><li>C.X为关系R的超码</li><li>D.关系R属于2NF</li></ul><blockquote><p>正确答案：C你选对了</p></blockquote></li><li><p>设有关系模式R(A，B，C，D，E，F)，其函数依赖集为 { E→D，C→B，CE→F，B→A}，则R最高属于第几范式_________。</p><ul><li>A.1NF</li><li>B.2NF</li><li>C.3NF</li><li>D.BCNF（Boyce-Codd范式）</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p>设有关系模式R(A，B，C，D，E)，其函数依赖集为{A→B，CE→A，B→D}，则R最高属于第几范式_________。</p><ul><li>A.1NF</li><li>B.2NF</li><li>C.3NF</li><li>D.BCNF（Boyce-Codd范式）</li></ul><blockquote><p>正确答案：B你选对了</p></blockquote></li></ol><h2 id="第六讲"><a href="#第六讲" class="headerlink" title="第六讲"></a>第六讲</h2><ol><li><p>关于模式分解，下列说法正确的是___________。</p><ul><li>A.一个数据库模式可以任意地分解为两个或多个模式，而其内容和依赖关系均将保持不变；</li><li>B.将一个数据库模式R分解为两个模式R1和R2，则R上的任何关系r都有r = 投影(R1) (Natural-Join) 投影(R2)；</li><li>C.将一个数据库模式R分解为两个模式R1和R2，则R1,R2一定能保证R上的函数依赖关系；</li><li>D.我们可以找出将模式R既保持依赖又能无损连接的分解为两个模式R1和R2的方法。</li></ul><blockquote><p>正确答案：D你错选为B</p><p>解析:选项 A 的说法不正确,如果任意分解,内容和依赖关系不会保持不变。选项 B 的说法不正确,后面公式代表的是无损连接分解,任意分解是不一定会保证无损连接性的。 C 的说法不正确,任意分解是不一定会保持函数依赖关系的。选项 D 的说法是正确的,是有办法的。</p></blockquote></li><li><p>关于关系的规范化，下列说法正确的是________。</p><ul><li>A.对于一个关系模式来说，规范化程度越高越好。</li><li>B.满足Boyce-Codd范式的关系模式一定满足第三范式。</li><li>C.第一范式要求非主属性完全函数依赖于候选键。</li><li>D.当关系模式不满足某一范式时，可将其任意分解为两个关系模式并使每一个关系模式都满足该范式即可。</li></ul><blockquote><p>正确答案：B你选对了</p><p>解析:选项 A 说法不正确,通常达到第 3NF 或 Boyce-Codd 范式即可,并不是越高越好。选项 B 说法正确,满足 Boyce-Codd 范式则一定满足第三范式,反之则不然。选项 C 说法不正确,第一范式要求数据项是原子的,第二范式要求非主属性完全函数依赖于候选键。选项 D 说法不正确,不能任意分解,分解时要考虑无损连接性和保持依赖性。</p></blockquote></li><li><p>给定关系模式R(U, F)，其中U={A1，A2，A3，A4，A5，A6} ，给定函数依赖集合F=A1→(A2,A3)；A3→A4；(A2,A3)→(A5,A6)； A6→A1 }，有一个分解r=R1(A1,A2,A3,A4)，R2(A3,A4,A5,A6)}，问该分解__________。</p><ul><li>A.既具有无损连接性，又保持函数依赖</li><li>B.不具有无损连接性，但保持函数依赖</li><li>C.具有无损连接性，但不保持函数依赖</li><li>D.既不具有无损连接性，又不保持函数依赖</li></ul><blockquote><p>正确答案：D你选对了</p><p>解析:R1交R2 = (A3,A4) ,(A3,A4)既不能决定 A5,A6,又不能决定 A1,A2,故不具有无损连接性,因 A6→A1 既没有被 R1 保持,又没有被 R2 保持,所以不保持依赖。</p></blockquote></li><li><p>注：如何判断是否能够无损连接：对几个小集合取交集，如果交集这个集合可以确定原来的集合，就能保证无损连接；</p></li><li><p>给定关系模式R(U, F)，其中U={A1，A2，A3，A4，A5，A6} ，给定函数依赖集合F=A1→(A2,A3)；A3→A4；(A2,A3)→(A5,A6)； A5→A1 }，有一个分解r=R1(A1,A2,A3,A4)，R2(A2,A3,A5,A6)}，问该分解__________。</p><ul><li>A.既具有无损连接性，又保持函数依赖</li><li>B.不具有无损连接性，但保持函数依赖</li><li>C.具有无损连接性，但不保持函数依赖</li><li>D.既不具有无损连接性，又不保持函数依赖</li></ul><blockquote><p>正确答案：C你选对了</p></blockquote></li><li><p>注：如何判断某一个分解是否保持函数依赖：看分解后的集合中是否具有所有原来的依赖关系</p></li><li><p>给定关系模式R(U, F)，其中U={A1，A2，A3，A4，A5，A6} ，给定函数依赖集合F=A1→(A2,A3)；A3→A4；(A2,A3)→(A5,A6)；A5→A2 }，有一个分解r=R1(A1,A2,A3,A4)，R2(A2,A3,A5,A6)}，问该分解__________。</p><ul><li>A.既具有无损连接性，又保持函数依赖</li><li>B.不具有无损连接性，但保持函数依赖</li><li>C.具有无损连接性，但不保持函数依赖</li><li>D.既不具有无损连接性，又不保持函数依赖</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p>给定关系模式R(U, F)，其中U={A1，A2，A3，A4，A5，A6} ，给定函数依赖集合F=A1→(A2,A3)；A3→A4；(A2，A3)→A5；A6→A3 }，有一个分解r=R1(A1,A2,A3,A4)，R2(A2,A3,A5,A6)}，问该分解__________。</p><ul><li>A.既具有无损连接性，又保持函数依赖</li><li>B.不具有无损连接性，但保持函数依赖</li><li>C.具有无损连接性，但不保持函数依赖</li><li>D.既不具有无损连接性，又不保持函数依赖</li></ul><blockquote><p>正确答案：B你错选为A</p><p>求出交集A2，A3，两个元素不能决定原来集合中的所有的元素因此不具备无损连接的特性；</p></blockquote></li><li><p>给定关系模式R(U, F)，其中U={A1，A2，A3，A4，A5 } ，给定函数依赖集合F=A2→A1；A4→A1；A1→A5；(A1,A3)→A2；}。有一个分解r={R1(A1,A2,A3,A5)，R2(A3,A4)}，问该分解__________。</p><ul><li>A.既具有无损连接性，又保持函数依赖</li><li>B.不具有无损连接性，但保持函数依赖</li><li>C.具有无损连接性，但不保持函数依赖</li><li>D.既不具有无损连接性，又不保持函数依赖</li></ul><blockquote><p>正确答案：D你选对了</p></blockquote></li><li><p>关系模式R(A1，A2，A3，A4，A5，A6)，给定函数依赖集合F={ A2→(A3，A5)；(A1，A3)→A6；(A2，A6)→ A4 }，则关于R，既保持依赖又无损连接地分解成第三范式，分解正确的是_________。</p><ul><li>A.r={R1(A2,A3, A5)，R2(A1,A3,A6)，R3(A2,A4,A6) }</li><li>B.r={R1(A2,A3, A5)，R2(A1,A3,A6)，R3(A2,A4,A6)，R4(A1,A2) }</li><li>C.r={R1(A2,A3,A5)，R2(A1,A2,A3,A4,A6)}</li><li>D.r={R1(A1,A2,A3,A5)，R2(A2,A4,A6)}</li></ul><blockquote><p>正确答案：B你没选择任何选项</p><p>解析:选项 A,满足第三范式,保持依赖但不一定无损连接。选项 B,满足第三范式,保持依赖又无损连接,在保持依赖的基础上增加了包含候选键的关系。选项 C,保持依赖又无损连接,但不满足第三范式,此时 R2 候选键为(A1,A2,A3),A4 传递依赖于(A1,A2,A3),存在传递函数依赖。选项 D,既不保持依赖又不具无损连接性,而且不满足第<br>二范式,也就不满足第三范式;</p></blockquote><p>备注：上题需要判断是否满足第三范式，判断是否满足保持依赖，是否满足无损连接三个调节，可以逐一排除；满足第三范式，即在满足第一第二范式的基础上（每个元素不可分、每个非主属性都完全依赖于候选键）不存在传递依赖；</p></li><li><p>关系模式R(A1，A2，A3，A4，A5，A6，A7)，给定函数依赖集合F={ A1→A2； A1→A3； A3→A4；A3→A5；A5→(A6,A7) } 则关于R，既保持依赖又无损连接地分解成第三范式，分解正确的是_________。</p><ul><li>A.r={R1(A1,A2, A3)，R2(A3,A4,A5)，R3(A5,A6,A7) }</li><li>B.r={R1(A1,A2,A3, A4,A5)，R2(A5,A6,A7) }</li><li>C.r={R1(A1,A2, A3)，R2(A3,A4,A5,A6,A7) }</li><li>D.r={R1(A2,A3,A6,A7)，R2(A1,A4,A5)}</li></ul><blockquote><p>正确答案：A你没选择任何选项</p><p>解析:选项 A,满足第三范式,保持依赖且无损连接。选项 B,保持依赖且无损连接,但存在传递依赖。选项 C,保持依赖且无损连接,但存在传递依赖。选项 D,满足第三范式,但即不具无损连接性,又不保持依赖。</p></blockquote></li></ol><h1 id="下"><a href="#下" class="headerlink" title="下"></a>下</h1><h2 id="第一讲-2"><a href="#第一讲-2" class="headerlink" title="第一讲"></a>第一讲</h2><ol><li><p>学习数据库物理存储，首先要理解磁盘的结构及其工作原理。下列说法正确的是_________。</p><ul><li>A.磁盘是由一组盘面构成，每个盘面又被从内到外划分成若干个同心圆，被称为磁道，而每个磁道又按圆周被划分成若干个扇形区域，被称为扇区。磁盘就是按照“盘面：磁道：扇区”来确定信息的存储地址的。一次磁盘操作只能读写一个盘面一个磁道的一个扇区。</li><li>B.磁盘的盘面可以围绕主轴做高速旋转，进而可使某一扇区移动到磁头所在位置。一次磁盘操作可读写一个磁道的所有信息。</li><li>C.磁盘通常有一个机械装置，称为读写臂，读写臂可使磁头沿磁盘的径向运动，使磁头在内侧磁道和外侧磁道之间移动，进而使磁头移动到某一磁道的某一扇区位置。一次磁盘操作可读写一个盘面的所有信息。</li><li>D.一个磁盘的若干盘面可以同时旋转，位于不同盘面上的磁头可以同时移动。一次磁盘操作可以一次性读写多个盘面上相同磁道位置的扇区，即一次性读写多个扇区。</li></ul><blockquote><p>正确答案：D你选对了</p><p>解析：选项 A 说法不正确，“一次磁盘操作只能读写一个盘面一个磁道的一个扇区”不正确，可一次性读写多个扇区。</p><p>选项 B 说法不正确，“一次磁盘操作可读写一个磁道的所有信息”不正确，一个磁道的所有扇区不能一次性读写出来。</p><p>选项 C 说法不正确，“一次磁盘操作可读写一个盘面的所有信息”不正确，一个盘面包含多个磁道多个扇区，不能一次性读写完成。</p><p>选项 D 说法是正确的。一次磁盘操作可以一次性读写多个盘面上相同磁道位置的扇区，即一次性读写多个扇区，因此不同盘面相同磁道位置被称为“柱面”，物理存储地址又可记为“盘面：柱面：扇区”。 </p></blockquote></li><li><p>关于磁盘的读写问题。下列说法正确的是_________。</p><ul><li>A.磁盘可以一个存储字一个存储字的读写。</li><li>B.磁盘仅可以以一个扇区为单位进行读写。</li><li>C.磁盘可以以多个扇区为单位进行读写。</li><li>D.其他说法都不正确。</li></ul><blockquote><p>正确答案：C你错选为A</p><p>。解析：选项 A 说法不正确，磁盘是机电装置，读写需要时间，所以不能以存储字为单位(太小)进行读写，应以批量换速度，一次读写更多的数据。选项 B 说法不正确，磁盘可以一次性读写多个扇区—相同柱面不同盘面的扇区可以一次性读写。选项 C 说法是正确的，磁盘可以以多个扇区为单位进行读写，相同柱面不同盘面的相同位置的扇区可以一次性读写。选项 D 说法是不正确的，因为其他中有正确的，故其本身不正确。</p></blockquote></li><li><p>于磁盘的快速读写问题。下列说法不正确的是_________。</p><ul><li>A.将信息分块存储在同一磁道的连续扇区中，可以缩短磁盘读写数据的时间。</li><li>B.将信息分块存储在不同盘面的相同柱面上，可以缩短磁盘读写数据的时间。</li><li>C.将信息分块存储在多个磁盘上，多个磁盘同步工作，可以缩短磁盘读写数据的时间。</li><li>D.将信息分块分散在不同柱面上存储，可以缩短磁盘读写数据的时间。</li></ul><blockquote><p>正确答案：D你选对了</p><p>不同柱面上的扇区是不能一次性读写完成的。</p></blockquote></li><li><p>RAID，独立磁盘冗余阵列，是提高数据读写正确性和速度的重要方法。下列哪一项不是RAID可能采取的技术_________。</p><ul><li>A.块级拆分，将一个文件的不同块存储在不同磁盘上，保证数据读写的快速性。</li><li>B.比特级拆分，将一个字节的不同位存储在不同磁盘上，保证数据读写的快速性。</li><li>C.流水线，将数据组织成适宜于流水作业处理的结构，保存在多个磁盘上， 保证数据读写的快速性。</li><li>D.互为校验盘，多个磁盘间互为校验盘，保证数据读写正确性。</li></ul><blockquote><p>正确答案：C你选对了</p><p>块级拆分，并行存取；，比特级拆分，并行存取；互为校验盘，可保证数据读写正确性；，盘内奇偶校验与盘间校验相结合，可进行纠错；</p></blockquote></li><li><p>一个磁盘的基本信息为32个圆盘，64个盘面，每个盘面有65536个磁道，每个磁道(平均)有256个扇区，每个扇区有512个字节，问该磁盘的存储容量为_________。</p><ul><li>A.<img src="https://img2.ph.126.net/GL0kEohLl41OcABPSnf4dA==/6631680193678210214.png" alt="img"></li><li>B.<img src="https://img2.ph.126.net/Q0Oq4CdXSbuo3t6wTp9IAA==/6631649407352626460.png" alt="img"></li><li>C.<img src="https://img0.ph.126.net/P4aXTmQ53lgAIGOA8Tt2RQ==/6631271175349750104.png" alt="img"></li><li>D.<img src="https://img1.ph.126.net/kvdr19rBg9K7bzEnIGEL1Q==/6631573541050311133.png" alt="img"></li></ul><blockquote><p>正确答案：B你错选为C</p><p>单位为B；</p></blockquote></li><li><p>一个磁盘的基本信息为：磁盘以7200转/min旋转。柱面之间移动磁头组合从启动到停止需要1ms，每移动4000个柱面另加1ms。32个圆盘，64个盘面，每个盘面有65536个磁道，每个磁道(平均)有256个扇区，一个扇区512个字节，一个磁盘块=连续8个扇区的数据传输时间约为0.13毫秒。则读写16KB数据的时间为_________。</p><ul><li>A.最小时间为0.13毫秒</li><li>B.最小时间为0.52毫秒</li><li>C.最长时间为10.76毫秒</li><li>D.最长时间为52.46毫秒</li></ul><blockquote><p>B</p></blockquote></li><li><p>下列说法正确的是_________。</p><ul><li>A.当数据库经过频繁的增加和删除记录后，数据库查询效率是不会发生变化的，即这种情况不会影响查询的。</li><li>B.数据库以排序文件来组织，每当新增一条记录，都需要移动数据库记录以腾出空间将新增记录插入到其相应的排序位置。</li><li>C.数据库以排序文件来组织，每当新增一条记录，将其写入溢出文件，DBA周期性地执行数据库命令以将溢出文件并入到排序文件中。</li><li>D.建立一个股票交易数据库，应采用排序文件来组织，以提高检索速度。</li></ul><blockquote><p>正确答案：C你选对了</p><p>。解析：选项 A 说法不正确，频繁的增删记录后，数据库中会留存有被删除的记录(存在但不会显示出来)，会浪费存储空间，是会影响查询效率的。选项 B 说法不正确，每当新增记录时是将其放入溢出文件，待数据库重组时再合并到主文件中，因为大批量移动数据是危险的动作。选项 C 说法是正确的。选项 D 说法是不正确的，股票交易重要的是增删改数据的快速性，而不是检索速度，因此宜选用堆文件（无序文件）来组织数据。 </p></blockquote></li><li><p>关于数据库的组织与存取方法，下列说法不正确的是________。</p><ul><li>A.当数据库是按照排序文件进行组织时，增加一条记录是将其写入溢出文件中，而不是直接写入排序文件；</li><li>B.当对数据更新速度有较高要求时，通常采用无序记录文件即堆文件来组织；</li><li>C.堆文件的查询访问速度要远高于排序文件的查询速度；</li><li>D.无论是堆文件组织还是排序文件组织，在一段时间后都需要对数据库进行重组操作。</li></ul><blockquote><p>正确答案：C你选对了</p><p>数据库经过一段时间运行后需要进行重组，数据库重组可以提高数据库的访问效率。 </p></blockquote></li><li><p>数据库重组是__________。</p><ul><li>A.对数据表的数据项进行调整；</li><li>B.对数据表的记录进行调整；</li><li>C.对数据表的物理存储进行调整；</li><li>D.对数据表的结构进行调整；</li></ul><blockquote><p>正确答案：C你选对了</p><p>解析：选项 A 说法是不正确的，对数据表的数据项进行调整，是数据库操纵，如 Update 语句；  选项 B 说法是不正确的，对数据表的记录进行调整，是数据库操纵，如Update 语句；选项 C 说法是正确的，调整数据表的物理存储是“数据库重组”；选项 D 说法是不正确的，改变数据表的结构或者说改变模式的定义，被称为“数据库重构”而不是“数据库重组”。 </p></blockquote></li><li><p>关于数据库物理存储，下面说法正确的是__________。</p></li></ol><ul><li>A.DBMS总是把一个“表”存储成一个文件，一个文件仅包含一个表中的数据；</li><li>B.DBMS既可以将若干个“表”的数据存储在一个文件中，又可以将一个“表”的数据存储在多个文件中；</li><li>C.DBMS可以将若干个“表”的数据存储在一个文件中，但不可以将一个“表”的数据存储在多个文件中；</li><li>D.DBMS不可以将若干个“表”的数据存储在一个文件中，但可以将一个“表”的数据存储在多个文件中；</li></ul><blockquote><p>正确答案：B你选对了</p><p>解析：选项 A 说法是不正确的，DBMS 并不总是把一个“表”存储成一个文件的。选项 B 说法是正确的，DBMS 既可以将若干个“表”的数据存储在一个文件中，又可以将一个“表”的数据存储在多个文件中，DBMS 可以将多个文件的数据组织成“表空间”进行管理。选项 C 说法是不正确的，DBMS 是可以将一个“表”的数据存储在多个文件中的。选项 D 说法是不正确的，DBMS 是可以将若干个“表”的数据存储在一个文件中的。 </p></blockquote><ol start="11"><li><p>在_________组织结构中，记录通常是以输入顺序存储的。</p><ul><li>A.顺序文件</li><li>B.堆文件</li><li>C.散列文件</li><li>D.聚簇文件</li></ul><blockquote><p>正确答案：B你错选为A</p><p>。解析：顺序文件是按照某一键值的顺序（升序或降序）存储；堆文件是无序记录文件，通常是按照记录的输入顺序存储的，但如要利用被删除记录的空间，则也可能将其插入到被删除记录的空间中。散列文件是按照关于键值的某一散列函数值确定的位置进行存储。聚簇文件是将一个表或多个表的数据集中在一起进行存储。</p></blockquote></li><li><p>如果要将一批记录均匀地存储在n个数据块中，应采用_________组织结构。</p><ul><li>A.顺序文件</li><li>B.堆文件</li><li>C.散列文件</li><li>D.聚簇文件</li></ul><blockquote><p>正确答案：C你错选为D</p><p>散列文件组织具有将一批记录均匀存储在 n 个数据块中的特性。聚簇文件是将一个表或多个表的数据集中在一起进行存储。 </p></blockquote></li></ol><h2 id="第二讲-2"><a href="#第二讲-2" class="headerlink" title="第二讲"></a>第二讲</h2><ol><li><p>关于索引的下列说法正确的是_______。</p><ul><li>A.一个主文件上可以建立多个索引，但更新主文件数据时只更新一个索引</li><li>B.一个主文件上只能建立一个索引，无论是更新还是查询都利用该索引</li><li>C.一个主文件上只能有一个可决定物理存储的索引</li><li>D.一个主文件上可以有一个或多个可决定物理存储的索引</li></ul><blockquote><p>正确答案：C你选对了</p><p>解析:选项 A 说法是不正确的,更新主文件时必须更新该主文件的所有索引。选项 B 的说法是不正确的,一个主文件上可以建立多个索引。选项 C 说法是正确的,虽然一个主文件上可以建立多个索引,但只能有一个可决定物理存储的索引。选项 D 说法是不正确的,一个主文件上只能有一个可决定物理存储的索引。</p></blockquote></li><li><p>关于索引的下列说法不正确的是_______。</p><ul><li>A.索引文件比主文件存储小很多，通常先查索引再找主文件速度会快很多</li><li>B.索引文件存在与否不改变主文件的物理存储，所以索引可以随时被删除并重建</li><li>C.虽然索引文件存在与否不改变主文件的物理存储，但更新主文件数据时要同步更新所有的索引</li><li>D.索引文件增加了存储空间和维护负担，所以当主文件数据量很大时使用索引是效率不高的</li></ul><blockquote><p>正确答案：D你选对了</p><p>索引是辅助存储结构,可以被随时删除并重建。</p></blockquote></li><li><p>关于稀疏索引和稠密索引，下列说法正确的是_______。</p><ul><li>A.如果一个搜索码的值在稀疏索引中不存在，则在主文件中对应该搜索码值的记录也不存在</li><li>B.如果一个搜索码的值在稀疏索引中存在一个，则在主文件中对应该搜索码值的记录也只存在一个</li><li>C.如果一个搜索码的值在稠密索引中不存在，则在主文件中对应该搜索码值的记录也不存在</li><li>D.如果一个搜索码的值在稠密索引中存在一个，则在主文件中对应该搜索码值的记录也只存在一个</li></ul><blockquote><p>正确答案：C你选对了</p><p>解析:选项 A 说法是不正确的,稀疏索引是不一定包含主文件索引项的所有不同值的索引,所以搜索码的值在稀疏索引中不存在,不代表在主文件中也不存在。选项 B的说法是不正确的,稀疏索引可能是按索引项排序且无冗余存储的,如果索引项是非键属性,则搜索码的值在稀疏索引中仅存在一个,但在主文件中则可能存在多个。选项 C 说法是正确的,是这样的。选项 D 说法是不正确的,如果是非键属性上的索引,则搜索码的值在稠密索引上存在一个,其在主文件中可能存在多个。</p></blockquote></li><li><p>关于主索引，下列说法不正确的是_______。</p><ul><li>A.主索引是对每一个存储块都有一个索引项</li><li>B.主索引通常建立在有序主文件的基于主码的排序字段上</li><li>C.主索引是关于主码的稠密索引</li><li>D.主索引是按索引字段值进行排序的一个有序文件</li></ul><blockquote><p>正确答案：C你选对了</p><p>解析:选项 A 说法是正确的,主索引是对每一存储块有一个索引项。选项 B说法是正确的,主索引通常建立在有序主文件的基于主码的排序字段上;选项 C 说法是不正确的,主索引通常是稀疏索引;选项 D 说法是正确的,主索引确实是按索引字段值进行排序的一个有序文件。</p></blockquote></li><li><p>数据库主索引是一种_________的索引。</p><ul><li>A.对每一记录，都有一个索引项</li><li>B.对每一存储块有一个索引项</li><li>C.对索引字段上的每一个不同值有一个索引项</li><li>D.其他都不对</li></ul><blockquote><p>正确答案：B你选对了</p></blockquote></li><li><p>关于稠密索引的下列说法正确的是________。</p><ul><li>A.稠密索引是对每一个存储块都有一个索引项</li><li>B.稠密索引的索引项的个数x与主文件索引字段上的不同值个数y有密切关系，一般而言要求x £ y</li><li>C.主索引通常是关于主码的稠密索引</li><li>D.稠密索引通常是按索引字段值进行排序的一个有序文件</li></ul><blockquote><p>正确答案：D你选对了</p><p>解析:选项 A 说法是不正确的,“每一存储块有一个索引项”通常是稀疏索引。选项 B 说法是不正确的,稠密索引要求 x&gt;=y,即至少要包含主文件索引字段上的每一个不同值;选项 C 说法是不正确的,主索引通常是关于主码的稀疏索引;选项 D 说法是正确的,稠密索引确实是按索引字段值进行排序的一个有序文件。</p></blockquote></li><li><p>关于索引的下列说法正确的是____________。</p><ul><li>A.在任何情况下，用索引进行查询都比不用索引进行查询要快</li><li>B.执行一条查询语句，当有索引时，DBMS总是首先在索引中查找，然后根据索引中的指针到主文件中查找</li><li>C.索引是DBMS自动建立和维护的，DBA或者用户无需建立也不能建立索引</li><li>D.主索引是DBMS自动建立和维护的，关于其他数据项上的索引需要DBA来建立，DBMS可自动维护DBA建立的索引</li></ul><blockquote><p>正确答案：D你错选为B</p><p>解析:选项 A 说法是不正确的,当主文件数据量较少时,用索引进行查询可能要多花一些时间,因为检索完索引,再检索主文件。选项 B 说法是不正确的,DBMS 会依据检索条件确定是否使用索引;选项 C 说法是不正确的,除主索引是 DBMS 自动建立的,其他索引可以由用户或 DBA 依据需要建立,但所有索引都是 DBMS 自动维护的;选项 D 说<br>法是正确的。</p></blockquote></li><li><p>关于索引的下列说法不正确的是__________。</p><ul><li>A.主索引是对每一个存储块都有一个索引项</li><li>B.稠密索引，对于Table中索引字段的每一个不同值，总是有一个索引项</li><li>C.稠密索引，对于Table中的每一个记录，总是有一个索引项</li><li>D.稀疏索引是对于Table中的部分记录有索引项</li></ul><blockquote><p>正确答案：C你错选为B</p><p>解析:选项 A 说法是正确的,主索引确实是对每一个存储块都有一个索引项;选项 B 说法是正确的,稠密索引是对于 Table 中索引字段的每一个不同值,都有一个索引项;选项 C 说法是不正确的,稠密索引对于 Table 中的每一个记录,并不总是有一个索引项,而对于 Table 中索引字段的每一个不同值总是有一个索引项;选项 D 说法是正确的,稀疏索<br>引确实是对于 Table 中的部分记录有索引项。</p></blockquote></li><li><p>关于聚簇索引和非聚簇索引，下列说法正确的是__________。</p><ul><li>A.聚簇索引中邻近的记录在主文件中不一定是邻近存储的，聚簇索引中一定不存在重复键值的索引项</li><li>B.聚簇索引中邻近的记录在主文件中一定是邻近存储的，聚簇索引中一定不存在重复键值的索引项</li><li>C.一个主文件只能有一个聚簇索引文件，但可以有多个非聚簇索引文件</li><li>D.一个主文件可以有多个聚簇索引文件，也可以有多个非聚簇索引文件</li></ul><blockquote><p>正确答案：C你错选为D</p><p>解析:选项 A 说法是不正确的,两个错误点:“不一定临近存储”和“一定不存在重复键值”。选项 B 说法是不正确的,一个错误点:“一定不存在重复键值”。选项 C说法是正确的。选项 D 说法是不正确的,一个错误点:“有多个聚簇索引文件”。</p></blockquote></li><li><p>用B+树建立主索引，下列说法正确的是__________。</p><ul><li>A.叶结点某索引项X的左侧指针，指向键值=X记录所在的主文件存储块</li><li>B.非叶结点某索引项X的左侧指针，指向键值=X记录所在的主文件存储块</li><li>C.叶结点某索引项X的左侧指针指向键值&lt;X记录所在的主文件存储块</li><li>D.非叶结点某索引项X的左侧指针指向键值&lt;X记录所在的主文件存储块；</li></ul><blockquote><p>正确答案：A你错选为C</p><p>解析:选项 A 说法是正确的。选项 B 说法是不正确的,非叶结点索引项 X 的左侧指针指向的是键值小于 X 的索引文件存储块。两个错误点,一是“=X”不正确,二是“主文件存储块”。选项 C 说法是不正确的,“&lt;X”不正确。选项 D 说法是不正确的,“主文件存储块”不正确,应是“索引文件存储块”。</p><p>注意看是否是叶节点，叶节点直接指向了对应的文件存储块；</p></blockquote></li><li><p>用B+树建立主索引，下列说法正确的是__________。</p><ul><li>A.叶结点某索引项X的左侧指针，指向键值=X记录所在的索引文件存储块</li><li>B.非叶结点某索引项X的左侧指针，指向键值=X记录所在的索引文件存储块</li><li>C.叶结点某索引项X的左侧指针指向键值&lt;=X记录所在的索引文件存储块</li><li>D.非叶结点某索引项X的左侧指针指向键值&lt;X记录所在的索引文件存储块</li></ul><blockquote><p>正确答案：D你错选为C</p><p>没有&lt;=这一说</p></blockquote></li><li><p>已知存储块大小为4096字节，在整型属性(一个整型数值占有4个字节)上建立B+树索引，一个指针占有8个字节，则该存储块最多能有______个索引项和______个指针。</p><ul><li>A.340， 341；</li><li>B. 339， 340；</li><li>C.341， 342；</li><li>D.341， 340；</li></ul><blockquote><p>正确答案：A你没选择任何选项</p><p>解析:首先是具有 n 个索引项,n+1 个指针,因此选项 D 不正确,被排除。其次应用公式 4n+8(n+1)&lt;=4096,n 最大为 340.66 取整即为 340。索引项为 340 个,指针为341 个,选项 A 正确,选项 B 不正确和选项 C 不正确。</p></blockquote></li><li><p>已知存储块大小为4096字节，在整型属性(一个整型数值占有4个字节)上建立B树索引，一个指针占有8个字节，则该非叶结点存储块最多能有______个索引项和______个指针。</p><ul><li>A.340， 341；</li><li>B.340， 342；</li><li>C.204， 410；</li><li>D.204， 408；</li></ul><blockquote><p>正确答案：C你没选择任何选项</p><p>解析:这里要注意 B 树和 B+树的差别是 B 树非叶结点,每个索引项包含两个指针,一个指针指向索引文件存储块,一个指针指向主文件存储块。非叶结点首先是具有n 个索引项,(n+1)*2 个指针,应用公式 4n+8(n+1)*2&lt;=4096,n 的最大值为 204。由此可知204 个索引项,和 410 个指针,选项 C 是正确的。</p></blockquote></li><li><p>关于B+树可以建立何种索引，下列说法不正确的是_________。</p><ul><li>A.用B+树可义建立候选键属性上的稀疏索引，但主文件必须按该属性排序存储</li><li>B.用B+树可义建立候选键属性上的稠密索引，但主文件必须按该属性排序存储</li><li>C.用B+树可义建立非候选键属性上的稠密索引；主文件可以按该属性排序存储，也可以不按该属性排序存储</li><li>D.用B+树可义建立候选键属性上的稠密索引；主文件可以按该属性排序存储，也可以不按该属性排序存储</li></ul><blockquote><p>正确答案：B你错选为D</p><p>解析:选项 A 说法是正确的。选项 B 说法不正确,如果建立候选键属性的稠密索引,主文件可以按该属性排序存储,也可以不按该属性排序存储。选项 C 说法是正确的。选项 D 说法是正确的。</p></blockquote></li><li><p>关于B+树，下列说法不正确的是_________。</p><ul><li>A.如果发生合并，则一定会减少索引存储块的数目</li><li>B.如果发生合并，则不一定会减少索引存储块的数目</li><li>C.如果发生分裂，则一定会增加索引存储块的数目；</li><li>D.如果发生分裂与合并，则一定伴随着指针的调整</li></ul><blockquote><p>正确答案：A你错选为B</p><p>解析:选项 A 说法是不正确的,合并可能会调整左右相邻结点的索引项,不一定会增加索引存储块的数目。选项 B 说法是正确的。选项 C 说法是正确的。选项 D 说法d是正确的。</p></blockquote></li><li><p>关于B+树，下列说法正确的是_________。</p><ul><li>A.B+树在任何情况下都可以保证结点中指针的使用率大于等于50%</li><li>B.B+树中所有结点的索引项，才能覆盖主文件的完整索引</li><li>C.如果用B+树建立主索引，则B+树中所有结点的索引项都包含指向主文件存储块的指针</li><li>D.B+树索引的所有叶子结点构成主文件的一个排序索引</li></ul><blockquote><p>正确答案：D你选对了</p><p>选项 A 说法是不正确的,根结点中指针的使用不必一定大于等于 50%。选项 B 说法是不正确的,B 树是所有结点的索引项才能覆盖主文件的完整索引,但 B+树仅需要所有叶子结点的索引项,即可覆盖主文件的完整索引。选项 C 说法是不正确的,B+树中只有叶子结点的索引项包含指向主文件存储块的指针。选项 D 说法是正确的。</p></blockquote></li><li><p>某同学X欲产生一棵B+树，绘制出了如下图所示的结果。另一位同学Y总结了该图作为B+树存在的问题如下： (I) 键值45的非叶结点的索引项不正确；(II) 键值13的叶结点的最右指针指向不正确；(III) 键值30的非叶结点不应该存在，应被合并到键值45的结点中；(IV)键值35的结点应被删除，因为键值30的结点被合并后，不需要了。(V)键值13的叶结点也应该被合并。按照B+树要求，你认为Y同学的说法哪些是正确的。正确的选项是_______________。</p><p><img src="https://nos.netease.com/edu-image/F836D272898ECB57BB6709294CB6B7D9.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.Y同学的(I)-(V)说法都是正确的</li><li>B.Y同学的(I)(II)III)(IV)(V)说法都是不正确的</li><li>C.Y同学的(I)(II)III)(IV)说法是正确的，(V)说法不正确</li><li>D.Y同学的(I)(II)(III)说法是正确的，(IV)(V)说法不正确</li></ul><blockquote><p>正确答案：C你错选为D</p><p>解析:Y 同学的说法(I)正确,键值 45 的非叶结点的索引项不正确,与左侧指针指向的索引项键值相等不符合要求;说法(II)正确,键值 13 的叶结点的最右指针应指向下<br>一叶结点,不应指向 Null;说法(III)正确,键值 30 的非叶结点利用的指针数少于 1/2,应被合并。说法(IV)正确,键值 35 的结点确实不需要了,因为只需一个非叶结点即可。说法(V)不正确,键值 13 的叶结点可以不被合并。因此说(I)(II)(III)IIV)说法正确,而(V)说法不正确。因此,选项 C 是本题的正确答案。</p></blockquote></li><li><p>已知一个存储块可存放主文件的5条记录，或存放索引文件的20个索引项。已知主文件有n条记录， 则创建稠密索引和稀疏索引各需要的存储块数是____和_____。</p><ul><li>A.n，n/20</li><li>B.n/5，n/20</li><li>C.n/20，n/5</li><li>D.n/20，n/100</li></ul><blockquote><p>正确答案：D你选对了</p><p>解析:主文件有 n 条记录,则索引键值个数可能有 n 个,即索引项个数可能有 n 个,一块可存放 20 个索引项,故创建稠密索引需要的存储块数是 n/20。而稀疏索引可以是为每一主文件的磁盘块建立一索引项,主文件 n 条记录,每存储块可存放 5 条记录,因此共需 n/5 个磁盘块,即有 n/5 个稀疏索引的索引项,一块可存放 20 个索引项,故创建稀疏<br>索引所需要的存储块数是 n/5/20,即 n/100。选项 D 正确。</p><p>​</p></blockquote></li><li><p>已知一个存储块可存放主文件的50条记录，或存放索引文件的500个索引项，要求存放主文件数据和存放索引文件数据的存储块最多只能填满80%， 已知主文件有n条记录， 则创建稠密索引和稀疏索引各需要的存储块数是____和_____。</p><ul><li>A.n/50，n/500</li><li>B.n/40，n/400</li><li>C.n/500，n/25000</li><li>D.n/400，n/16000</li></ul><blockquote><p>正确答案：D你错选为C</p><p>解析:主文件有 n 条记录,则索引键值个数可能有 n 个,即索引项个数可能有 n 个,一块可存放 500 个索引项但只能填满 80%,故创建稠密索引需要的存储块数是n/(500<em>0.8)。而稀疏索引可以是为每一主文件的磁盘块建立一索引项,主文件 n 条记录,每存储块可存放 50 条记录但只能填满 80%,因此共需 n/(50</em>0.8)个磁盘块,即有 n/(50<em>0.8)个<br>稀疏索引的索引项,一块可存放 500 个索引项但只能填满 80%,故创建稀疏索引所需要的存储块数是 n/((50</em>0.8)<em>(500</em>0.8)),即 n/100。选项 D 正确。</p></blockquote></li></ol><ol start="20"><li><p>主索引通常确定“表”数据的______。</p><ul><li>A.唯一性</li><li>B.取值范围</li><li>C.逻辑顺序</li><li>D.物理顺序</li></ul><blockquote><p>正确答案：D你错选为C</p><p>主索引通常是确定“表”数据物理存储顺序的索引。</p></blockquote></li></ol><h2 id="第三讲-2"><a href="#第三讲-2" class="headerlink" title="第三讲"></a>第三讲</h2><ol><li><p>已知BX为关系X的磁盘块数目，IX为关系X的元组的长度，TX为关系X的元组的数目，b为磁盘块或内存页的大小，M为可用内存页的数目。问：以下算法的适用条件是________。</p><p><img src="https://nos.netease.com/edu-image/BA039305AAD4E881298399C834A36BE7.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.BR &lt; BS，BS &lt;M</li><li>B.BR &gt; BS，BS &lt;M</li><li>C.BS&gt; BR，BR &lt;M</li><li>D.BS &lt; BR，BR &lt;M</li></ul><blockquote><p>正确答案：C你选对了</p><p>解析:如上算法是一次性将 R 完整的读入到内存,将 S 一块一块的读入内存进行处理,因此只要 B R &lt;M,则无论 S 有多大都能被处理,因此“B S &gt; B R ,B R &lt;M”是正确<br>的。</p></blockquote></li><li><p>已知BX为关系X的磁盘块数目，IX为关系X的元组的长度，TX为关系X的元组的数目，b为磁盘块或内存页的大小，M为可用内存页的数目，MX为分配给X的内存区域。问：不考虑结果关系的存取，以下算法的复杂性是________。</p><p><img src="https://nos.netease.com/edu-image/336A7E5B4886D67AEDF4A4C4BB8630DD.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.BRBS  + BS</li><li>B.(BR+BS )(M-2) + BS</li><li>C.BRBS /(M-2) + BS</li><li>D.(BR+BS )/(M-2)) + BS</li></ul><blockquote><p>正确答案：C你选对了</p><p>该算法一次性读入 S 的 M-2 个存储块,循环处理一遍 R 的每一个存储块。R 被循环读取了 B S /(M-2)次,S 被读取了一次。故正确答案为“B R B S /(M-2) + B S ”。</p></blockquote></li><li><p>已知BX为关系X的磁盘块数目，IX为关系X的元组的长度，TX为关系X的元组的数目，b为磁盘块或内存页的大小，M为可用内存页的数目，MX为分配给X的内存区域。问：关于以下两个算法(a)(b)，说法正确的是______________。</p><p><img src="https://nos.netease.com/edu-image/D4ADE76FF04A1490E7A1624166106A42.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.算法(a)和算法(b)的复杂性是相同的，算法(a)和算法(b)的适用条件是相同的</li><li>B.算法(a)和算法(b)的复杂性是相同的，算法(a)和算法(b)的适用条件是不同的</li><li>C.算法(a)和算法(b)的复杂性是不同的，算法(a)和算法(b)的适用条件是相同的</li><li>D.算法(a)和算法(b)的复杂性是不同的，算法(a)和算法(b)的适用条件是不同的</li></ul><blockquote><p>正确答案：B你错选为D</p><p>。解析:算法(a)和(b)的复杂性都是 B R +B S ,是相同的。但适用条件是不同的,算法(a)适用于内存充分大,足以装得下两个关系时才可应用;而算法(b)适用于内存只要能够完整的装下一个关系时即可应用。</p></blockquote></li><li><p>下列关系代数操作，任何时候都能够用一趟算法实现的是______。</p><ul><li>A.<img src="https://nos.netease.com/edu-image/3AFBB10B2A971E6BCE5167C733EC2184.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>B.<img src="https://nos.netease.com/edu-image/83067DB3DF4857172AE854F869E90E67.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>C.<img src="https://nos.netease.com/edu-image/7314ABF314F972F5A99ADFFD909FC811.png?imageView&thumbnail=520x520&quality=100" alt="img"></li><li>D.其他都不对</li></ul><blockquote><p>正确答案：B你错选为D</p><p>解析:选择操作和包上的并操作,在任何时候都可以用一趟算法实现之。而集合上的并操作则不一定能够用一趟算法实现之。故选项(B)是正确的。</p></blockquote></li><li><p>关于给出的九个关系代数操作：</p><p><img src="https://nos.netease.com/edu-image/5B02D30BBDBCBEA69387445D48A7FF21.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><p>问任何时候都能够用一趟算法实现的操作的个数是_______。</p><ul><li>A.0</li><li>B.1</li><li>C.2</li><li>D.大于2</li></ul><blockquote><p>正确答案：B你没选择任何选项</p><p>解析:这九个操作只有包上的并操作,在任何时候都可以用一趟算法实现之。其他均都不一定能够用一趟算法实现之。故选项(B)是正确的。</p></blockquote></li><li><p>已知R和S的参数BR=BS=10,000，可用内存页数目为M。若要进行R和S的Theta-连接操作，没有索引可以使用，忽略结果存取的I/O次数。问：M分别应是怎样的值，才能使磁盘的I/O次数不超过(1)200,000，(2)25,000，(3)20,000。结果正确的是______________。</p><ul><li>A.M&gt;560， M&gt;6,000， M&gt;20,000</li><li>B.M&gt;500， M&gt;10,000，M&gt;30,000</li><li>C.M&gt;530， M&gt;6700，M&gt;10,000</li><li>D.M&gt;630， M&gt;4,700，M&gt;15,000</li></ul><blockquote><p>正确答案：C你没选择任何选项</p><p>解析:<br>依据大关系算法复杂性“B R B S /(M-2) + B S ”。如 B R B S /(M-2) + B S &lt;200,000,则可求出 M 应大于 530,如 B R B S /(M-2) + B S &lt;25,000,则可求出 M 应大于 6700。20,000 次只允许 R 和 S 各装入内存一次,此时只需要将 R 或 S 中的某一个完全装入内存,而另一个可以一块一块装入,即 M 应大于 10,000 即可。故选项 C 是正确的。</p></blockquote></li><li><p>下面是一个迭代器实现算法。该算法实现的是____________操作。</p><p><img src="https://nos.netease.com/edu-image/D8CD4BBF45B7A2AFBF7D256D30877E35.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.R并S</li><li>B.R 交S</li><li>C.R - S</li><li>D.S - R</li></ul><blockquote><p>正确答案：A你没选择任何选项</p></blockquote></li><li><p>下面是一个迭代器实现算法。该算法实现的是____________操作。</p><p><img src="https://nos.netease.com/edu-image/3A8FEF0213469009B1AC9AAFD24DEB67.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.R 并S</li><li>B.R 交S</li><li>C.R - S</li><li>D.S - R</li></ul><blockquote><p>正确答案：C你没选择任何选项</p></blockquote></li><li><p>下面是一个迭代器实现算法。该算法实现的是____________操作。</p><p><img src="https://nos.netease.com/edu-image/918D586A4F1685C9D87FDC83F3219B61.png?imageView&thumbnail=520x520&quality=100" alt="img"></p><ul><li>A.R 并 S</li><li>B.R 交 S</li><li>C.R - S</li><li>D.S - R</li></ul><blockquote><p>正确答案：B你没选择任何选项</p></blockquote></li><li><p>假设关系R的元组个数为T(R)，元组的大小为I(R)，存储块的大小为b，B(R)=T(R)*I(R)/b。关于表空间扫描算法，下列说法正确的是________。</p><ul><li>A.表空间扫描算法的复杂性始终为B(R)</li><li>B.表空间扫描算法的复杂性可能为B(R)，也可能为T(R)</li><li>C.表空间扫描算法的复杂性始终为T(R)</li><li>D.其他说法都不正确</li></ul><blockquote><p>正确答案：B你没选择任何选项</p><p>解析:利用表空间扫描算法,还要看关系是如何存储的,如果是聚簇关系(一个块中仅是该关系的元组),则其复杂性为 B(R),但如果是非聚簇关系,如果一个块中多个关系的元组混合存放,则可能一个元组在一个块中,则其复杂性为 T(R)。故选项 B 是正确的。选项 E,因为其他中有正确的,故此不正确。</p></blockquote></li><li><p>已知关系R的参数如下：聚簇存储磁盘块数B(R) = 1,000，元组数T(R) = 20,000，R中属性A的不同值的个数记为V(R, A)=100。R上有基于属性A的排序索引。关于<strong>s</strong>A=0(R)，下列说法正确的是_______。</p><ul><li>A.如果R是聚簇存储的且不使用索引，则该操作的执行代价为1000个I/O</li><li>B.如果不使用索引，则该操作的执行代价为1000个I/O</li><li>C.如果R是聚簇存储的且使用索引，则该操作的执行代价为1000个I/O</li><li>D.如果R是聚簇存储的且使用索引，则该操作的执行代价平均为100个I/O</li></ul><blockquote><p>正确答案：A你没选择任何选项</p><p>解析:选项 A 是正确的,聚簇存储且不使用索引,查询代价为 B(R)。选项 B是不正确的,因为如果 R 是非聚簇存储的,则其执行代价可能是 I(R)=20,000,此时要看 R是聚簇存储的还是非聚簇存储的。选项 C 是不正确的,如果使用索引,则其执行代价通常是远小于 B(R)的。选项 D 是不正确的,如果 R 是聚簇存储的且使用索引,则查询代价=B(R)/V(R,A)=1000/100=10 个 I/O。</p></blockquote></li><li><p>关于<strong>去</strong>重复&amp;(R)操作的一趟扫描算法，下列说法不正确的是____________。</p><ul><li>A.非精确的讲，算法的应用前提是B(R) &lt; =M，其中M为可用内存块数，B(R)为R中数据所占用的磁盘块数。</li><li>B.算法的关键是建立内存数据结构，可以建立散列结构，也可以建立排序结构，目的是进行快速比较。</li><li>C.算法可以做到只与一个内存块中的数据进行比较，即可判断出是否有重复。</li><li>D.算法需要首先对R的所有数据建立内存数据结构，然后才能判断是否有重复的元组存在。</li></ul><blockquote><p>正确答案：D你选对了</p><p>解析:选项 A 说法是正确的,只要内存块数足以装得下整个关系,即可执行。更严格的说,只要内存块数足以装得下关系中不重复值的元组数目,即可执行。选项 B 说法是正确的。选项 C 说法是正确的,可以通过散列,将具有相同值的元组散列到同一内存块中,因此同一内存块中没有重复,则即是没有重复。选项 D 说法不正确,不需要首先对 R<br>的所有数据建立内存数据结构,可以边执行边建立即可。</p></blockquote></li><li><p>分组聚集操作的一趟扫描算法______________。</p><ul><li>A.非精确的讲，算法的应用前提是B(R) &lt; =M，其中M为可用内存块数，B(R)为R中数据所占用的磁盘块数</li><li>B.算法的关键是建立内存数据结构，可以建立散列结构，也可以建立排序结构，目的是进行快速比较</li><li>C.算法可以做到一条记录只与一个或少量几个内存块中的数据进行分组聚集计算</li><li>D.算法可以边执行边建立内存数据结构，即仅对已处理过的数据建立内存数据结构，便可进行各个分组的聚集计算</li></ul><blockquote><p>正确答案：D你错选为A</p><p>解析:选项 A 说法是正确的,只要内存块数足以装得下整个关系,即可执行。更严格的说,只要内存块数足以装得下关系中所有的分组及其每一分组上的不同值,即可执行。选项 B 说法是正确的。选项 C 说法是正确的,可以通过散列,将具有相同分组值的元组散列到同一内存块中。选项 D 说法是不正确的,有些分组聚集计算是在建立起完整的数据结构后才能进行,但有些是可以的。选项 E 说法是正确的,需要首先对 R 的所有数据建立内存数据结构(将相同组的数据聚集在一起),然后再分组聚集计算即可。</p></blockquote></li></ol><h2 id="第四讲-2"><a href="#第四讲-2" class="headerlink" title="第四讲"></a>第四讲</h2><ol><li><p>已知内存共有8块，若要排序有70块的数据集，应如何组织，才能使磁盘读写次数最少。下列方案中磁盘读写次数最少的方案是________。</p><ul><li>A.方案I：(1)以8块为一个单位划分子集合，每个子集合进行内排序并存储，形成9个已排序子集合（其中包含一个仅有6块的子集合）；(2)接着在9个子集合中选择3个子集合  (其中包含仅有6块的子集合)，进行一个三路归并，形成一个已排序子集合；(3)再将剩余5个子集合与刚才归并后形成的子集合，进行一个七路归并，形成最终的已排序集合。这个方案的磁盘读写次数最少。</li><li>B.方案II：(1)以7块为一个单位划分子集合，每个子集合进行内排序并存储，形成10个已排序子集合；(2)接着在10个子集合中任选5个子集合进行一个五路归并，形成一个已排序子集合；(3)再将剩余5个子集合与刚才归并后形成的子集合，进行一个六路归并，形成最终的已排序集合。这个方案的磁盘读写次数最少。</li><li>C.方案III：(1)以8块为一个单位划分子集合，每个子集合进行内排序并存储，形成9个已排序子集合（其中包含一个仅有6块的子集合）；(2)接着在9个子集合中任选七个子集合进行一个七路归并，形成一个已排序子集合；(3)再将剩余2个子集合与刚才归并后形成的子集合，进行一个三路归并，形成最终的已排序集合。这个方案的磁盘读写次数最少。</li><li>D.方案IV：(1)以8块为一个单位划分子集合，每个子集合进行内排序并存储，形成9个已排序子集合；(2)接着在9个子集合中任选5个子集合进行一个五路归并，形成一个已排序子集合；(3)再将剩余4个子集合与刚才归并后形成的子集合，进行一个五路归并，形成最终的已排序集合。这个方案的磁盘读写次数最少。</li></ul><blockquote><p>A</p><p>解析:少量内存排序大规模数据,首先是要划分子集合并进行子集合排序。划分原则是子集合块数&lt;=可用内存块数,然后将其装入内存并进行排序后再写回磁盘。此一步骤四个方案都满足要求,且磁盘读写次数都是 70<em>2=140 次(读一次,写一次)。关键是多路归并的磁盘读写次数的差异。方案 I,先做三路归并(3 个子集合</em>(8 块子集合+8 块子集合+6 块子集合)<em>2 次=44 次—因有一个集合为 6 块),再做 7 路归并(70</em>2=140 次),所以总的磁盘读写次数为 140+140+44=324 次。方案 II,先做五路归并(5 个子集合<em>7 块每个子集合</em>2次=70 次,再做六路归并(70<em>2=140 次),所以总的磁盘读写次数为 140+140+70=350 次。方案 III,先做七路归并(7 个子集合</em>8 块每个子集合<em>2 次=112 次,再做三路归并(70</em>2=140 次),所以总的磁盘读写次数为 140+140+112=392 次。方案 IV,先做五路归并(5 个子集合*8 块每个 子 集 合 <em>2 次 =80 次 , 再 做 五 路 归 并 (70</em>2=140 次 ) , 所 以 总 的 磁 盘 读 写 次 数 为140+140+80=360 次。通过比较:选项 A 方案的磁盘读写次数最少。</p></blockquote></li><li><p>已知内存共有100块，若要排序有10000块的数据集，则下列说法正确的是_____。</p><ul><li>A.该数据集可以在两趟内实现排序，磁盘读写次数为40000次。</li><li>B.该数据集不能在两趟内实现排序，磁盘读写次数为40400次。</li><li>C.该数据集可以在两趟内实现排序，磁盘读写次数为40400次。</li><li>D.该数据集不能在两趟内实现排序，磁盘读写次数为60000次。</li></ul><blockquote><p>正确答案：B你错选为C</p><p>B。解析:100 块内存,每个子集合 100 块,10000 块数据集需要划分为 100 个子集合。100 块内存,留出一块作为输出块,则最多可进行 99 路归并。因此在进行最终排序前,需要先做一个 2 路归并,即将 2 个子集合归并成 1 个有序集合,然后再做 99 路归并。因此,“该数据集不能在两趟内实现排序”,需要“外加一个 2 路归并”,因此总的次数应为10000*4+100(一百块每个子集合)*2(两个子集合)*2(读一次写一次)=40400 次。</p></blockquote></li><li><p>已知内存共有8块，若要排序有100块的数据集，则给定多路归并算法如下：(1)以8块为一个单位划分子集合，每个子集合进行内排序并存储，形成13个已排序子集合(含一个仅有4块的子集合)；(2)接着在13个子集合中任选7个子集合（包含仅有4块的子集合）进行一个七路归并，形成一个已排序子集合；(3)再将剩余6个子集合与刚才归并后形成的子集合，进行一个七路归并，形成最终的已排序集合。问：这个方案的磁盘读写次数是_______。</p><ul><li>A.200</li><li>B.400</li><li>C.504</li><li>D.512</li></ul><blockquote><p>正确答案：C你错选为D</p><p>解析:8 块内存,每个子集合 8 块,100 块数据集需要划分为 13 个子集合(其中一个仅有 4 块),读一次写一次,子集合划分并排序需要 100*2 次磁盘读写。8 块内存,留出一块作为输出块,则最多可进行 7 路归并,第一个七路归并的次数为 52(六个 8 块子集合+一个 4 块子集合) *2 (读一次写一次) =104 次。最后一个七路归并的次数为 100*2 (读<br>一次写一次)=200 次,因此,总的次数为 200+104+200=504 次。</p></blockquote></li><li><p>关于基于排序的两趟算法，下列说法不正确的是_______。</p><ul><li>A.基于排序的两趟算法的第一趟都是划分子表并排序。每一个子表应都能装入内存，并进行排序，然后再存回磁盘。</li><li>B.基于排序的两趟算法的第二趟是进行归并，在归并的过程中可以边排序边去重复，归并完成即去重复操作完成。</li><li>C.基于排序的两趟算法的第二趟是进行归并，在归并的过程中可以一边排序一边进行分组并进行聚集计算，归并完成即分组聚集计算操作完成。</li><li>D.基于排序的两趟算法的第二趟是进行归并，先归并处理第一个关系的元组，边归并边去重复，归并处理完成后，再归并处理第二个关系的元组，边归并边去重复，归并处理完成后即完成两个关系的集合并操作。</li></ul><blockquote><p>正确答案：D你错选为C</p><p>选项 C 说法是正确的,归并过程中,相同分组的元组会按归并次序出现,只要在归并过程中将同一分组的相关元组进行聚集计算即可完成分组聚集计算操作。</p><p>D 说法是不正确的,按该选项说法是不能完成集合并操作的,集合并操作的关键是在归并过程中是否存在 R 与 S 相同的元组,相同的元组只保留一个。应该将 R 与 S 同时进行归并,并区分是 R 的元组还是 S 的元组,然后判断 R 的元组和 S 的元组是否相同,只保留一个。</p></blockquote></li><li><p>已知关系R和S。关系占用的磁盘块数B(R)=1000，B(S)=1000，已知可用内存页数M=40。采用基于排序的算法，下列说法正确的是_______。</p><ul><li>A.用一趟算法即可实现R和S的集合并操作。</li><li>B.用两趟算法即可实现R和S的集合并操作。</li><li>C.用一趟算法即可实现R和S的包的并操作。</li><li>D.必须用两趟算法才能实现R和S的包的并操作。</li></ul><blockquote><p>正确答案：C你错选为B</p><p>解析:关系 R 需划分为 25 个子集合,S 需划分为 25 个子集合,子集合排序并存储,此为第一趟。在第二趟归并过程中至少需要 50 个内存块,而目前只有 40 个内存块,一次一趟归并不能够完成。因此:选项 A 说法是不正确的,集合并操作需要去重复,而R 的排序和 S 的排序都不能在一趟内完成。选项 B 说法是不正确的,集合并操作需要去重复,由于不能同时进行 R 和 S 的归并排序(需要先将 R 的 12 个子集合归并成 1 个子集合,使 R 有 14 个子集合,这样才能同时进行 R 和 S 的归并),即不能在两趟内完成。选项 C 说法是正确的,包的并不需要去重复,所以一趟内可以完成。选项 D 说法是不正确的,包的并不需要去重复,所以一趟内可以完成,不必用两趟。</p></blockquote></li><li><p>已知关系R和S。关系占用的磁盘块数B(R)=1000，B(S)=500，已知可用内存页数M=50。采用基于排序的算法，下列说法正确的是_______。</p><ul><li>A.用一趟算法即可实现R和S的集合并操作。</li><li>B.用两趟算法才能实现R和S的集合并操作。</li><li>C.用一趟算法即可实现R和S的集合交操作。</li><li>D.用两趟算法才能实现R和S的包的并操作。</li></ul><blockquote><p>正确答案：B你选对了</p></blockquote></li><li><p>关于基于散列的两趟算法，下列说法不正确的是_______。</p><ul><li>A.基于散列的两趟算法的第一趟是散列子表。用某一个散列函数，将具有相同散列值的元组散列到相同的子表中并存回磁盘。 </li><li>B.基于散列的两趟算法的第二趟是用与第一趟相同的散列函数，将子表再散列到内存的不同内存块中，在具有相同散列值的所有内存块中去重复，即是在整个关系上去重复。所有子表处理完成，去重复操作即告完成。</li><li>C.基于散列的两趟算法的第二趟是用与第一趟不同的散列函数，将子表再散列到内存的不同内存块中，在具有相同散列值的所有内存块中去重复，即是在整个关系上去重复。所有子表处理完成，去重复操作即告完成。</li><li>D.两次散列函数的选择是不同的，第一趟是在大范围上进行散列，将一个大数据集散列成若干个具有相同散列值的散列子表，第二趟是在小范围上进行散列，将具有某相同散列值的散列子表(大范围上散列值相等)散列到内存的某一块或几块(小范围上散列值相等)。</li></ul><blockquote><p>正确答案：B你选对了</p></blockquote></li><li><p>关于R与S的并、交、差运算的基于散列的两趟算法，其中第一趟都是划分子表，都要求子表的存储块数要小于可用内存块数，以便子表可以一次性装入内存进行处理。关于划分子表，下列说法正确的是_______。</p><ul><li>A.必须用相同的散列函数将R和S分别散列成若干个子表。</li><li>B.必须用不同的散列函数将R和S分别散列成若干个子表。 </li><li>C.可以用相同的散列函数，也可以用不同的散列函数，将R和S分别散列成若干子表。</li><li>D.划分子表根本不用散列函数。</li></ul><blockquote><p>正确答案：A你选对了</p></blockquote></li><li><p>关于基于散列的两趟算法和基于排序的两趟算法的基本思想，下列说法正确的是_______。</p><ul><li>A.排序算法是先划分子表，独立处理子表（第一趟），然后再对各子表进行关联性处理（第二趟）；散列算法是先划分子表，独立处理子表（第一趟），然后再对各子表进行关联性处理（第二趟）；</li><li>B.排序算法是先划分子表，独立处理子表（第一趟），然后再对各子表进行关联性处理（第二趟）；散列算法是先从关联性角度处理，形成子表（第一趟），然后再独立处理每一个子表（第二趟）。</li><li>C.排序算法是先从关联性角度处理，形成子表（第一趟），然后再独立处理每一个子表（第二趟）。散列算法是先划分子表，独立处理子表（第一趟），然后再对各子表进行关联性处理（第二趟）；</li><li>D.排序算法是先从关联性角度处理，形成子表（第一趟），然后再独立处理每一个子表（第二趟）；散列算法是先从关联性角度处理，形成子表（第一趟），然后再独立处理每一个子表（第二趟）。</li></ul><blockquote><p>正确答案：B你选对了</p></blockquote></li><li><p>关于连接运算R (JOIN on R.A=S.B) S的基于散列的两趟算法，下列说法不正确的是_______。</p><ul><li>A.必须以相同的散列函数分别散列R和S，形成若干个散列子表。</li><li>B.散列过程中，R必须以A属性值作为散列函数的键值，S必须以B属性值作为散列函数的键值。</li><li>C.散列过程中，R必须以A和B属性值作为散列函数的键值，S也必须以A和B属性值作为散列函数的键值。</li><li>D.第二趟处理中，须将R的子表再完整地散列到内存的若干块中，然后再一块一块处理S对应子表的每一块，以便快速决定可以连接的元组。</li></ul><blockquote><p>正确答案：C你选对了</p></blockquote></li><li><p>关于基于散列的两趟算法，下列说法正确的是_______。</p><ul><li>A.第一趟散列和第二趟散列的目的都是提高数据处理的速度。</li><li>B.第一趟散列的目的是提高数据处理的速度，而第二趟散列的目的是使数据子集具有某一种特性(如具有相同的散列值)。</li><li>C.第一趟散列的目的是使数据子集具有某一种特性(如具有相同的散列值)，而第二趟散列的目的是提高数据处理的速度。</li><li>D.第一趟散列和第二趟散列的目的都是使数据子集具有某一种特性。</li></ul><blockquote><p>正确答案：C你错选为D</p><p>解析:选项 C 说法是正确的。第一趟散列的目的是使数据子集具有某一种特性(如具有相同的散列值),以便于将“规模数据全集上的操作”等价地 转换为“(数据子集上操作)的简单并集”。而第二趟散列的目的是提高数据处理的速度,散列到不同内存块中,使得比较时快速地和少量内存块中的数据进行比较。</p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;战神-中国大学MOOC数据库课后习题与知识点&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://vhdsih.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="database" scheme="https://vhdsih.github.io/tags/database/"/>
    
    <category term="mooc" scheme="https://vhdsih.github.io/tags/mooc/"/>
    
  </entry>
  
  <entry>
    <title>我的CSDN</title>
    <link href="https://vhdsih.github.io/2017/12/27/csdn/"/>
    <id>https://vhdsih.github.io/2017/12/27/csdn/</id>
    <published>2017-12-27T13:21:47.000Z</published>
    <updated>2023-10-25T14:48:31.708Z</updated>
    
    <content type="html"><![CDATA[<p>我在csdn上的博客停止更新，请<a href="https://blog.csdn.net/dongchangzhang">在这里查看在CSDN的文章</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我在csdn上的博客停止更新，请&lt;a href=&quot;https://blog.csdn.net/dongchangzhang&quot;&gt;在这里查看在CSDN的文章&lt;/a&gt;。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="过去" scheme="https://vhdsih.github.io/categories/%E8%BF%87%E5%8E%BB/"/>
    
    
    <category term="csdn" scheme="https://vhdsih.github.io/tags/csdn/"/>
    
  </entry>
  
</feed>
